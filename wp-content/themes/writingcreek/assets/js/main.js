function currentBrowser() {
  var t =
      (!!window.opr && !!opr.addons) ||
      !!window.opera ||
      0 <= navigator.userAgent.indexOf(" OPR/"),
    e = "undefined" != typeof InstallTrigger,
    i =
      /constructor/i.test(window.HTMLElement) ||
      "[object SafariRemoteNotification]" ===
        (
          !window.safari ||
          ("undefined" != typeof safari && safari.pushNotification)
        ).toString(),
    a = !!document.documentMode,
    s = !a && !!window.StyleMedia,
    n = !!window.chrome && !!window.chrome.webstore,
    o = (n || t) && !!window.CSS;
  return t
    ? "opera"
    : e
    ? "firefox"
    : i
    ? "safari"
    : a
    ? "ie"
    : s
    ? "edge"
    : n
    ? "chrome"
    : o
    ? "blink"
    : void 0;
}
function detectmob() {
  return navigator.userAgent.match(/Android/i)
    ? "android"
    : navigator.userAgent.match(/webOS/i)
    ? "webOS"
    : navigator.userAgent.match(/iPhone/i)
    ? "iPhone"
    : navigator.userAgent.match(/iPad/i)
    ? "iPad"
    : navigator.userAgent.match(/iPod/i)
    ? "iPod"
    : navigator.userAgent.match(/BlackBerry/i)
    ? "blackBerry"
    : !!navigator.userAgent.match(/BlackBerry/i) && "windowsPhone";
}
function setCookie(t, e, i) {
  if (i) {
    var a = new Date();
    a.setTime(a.getTime() + 24 * i * 60 * 60 * 1e3);
    var s = "; expires=" + a.toGMTString();
  } else s = "";
  document.cookie = t + "=" + e + s + "; path=/";
}
function getCookie(t) {
  for (
    var e = t + "=", i = document.cookie.split(";"), a = 0;
    a < i.length;
    a++
  ) {
    for (var s = i[a]; " " == s.charAt(0); ) s = s.substring(1, s.length);
    if (0 == s.indexOf(e)) return s.substring(e.length, s.length);
  }
  return !1;
}
function deleteCookie(t) {
  setCookie(t, "", -1);
}
function showScrollTop() {
  100 < $(this).scrollTop()
    ? $("#to_top").addClass("active")
    : $("#to_top").removeClass("active");
}
function fixedSidebar(t) {
  1 && $("#sidebar, aside .sidebar_wrap").attr("style", "");
  var i = $("#sidebar"),
    a = $("aside .sidebar_wrap"),
    s = $(".flex_parent"),
    e = $("header"),
    n = s.height() + "px",
    o = "(max-width: 1024px)",
    r = a.height(),
    l = r + "px",
    h = a.width() + "px";
  e.height();
  function d() {
    var t = $(this).scrollTop();
    r < s.height()
      ? i.css({ height: n })
      : (i.css({ height: l }), s.css({ height: l })),
      a.css({ height: l, width: h, "max-width": h });
    var e = i.height() - a.height() + i.offset().top;
    window.matchMedia(o).matches
      ? (i.css({ height: "auto" }),
        a.css({
          position: "relative",
          top: "auto",
          bottom: "auto",
          height: "auto",
          width: "100%",
        }))
      : t < i.offset().top
      ? a.css({ position: "absolute", top: "0", bottom: "auto" })
      : e < t
      ? a.css({ position: "absolute", top: "auto", bottom: "0" })
      : a.css({ position: "fixed", top: "20px", bottom: "auto" });
  }
  function c() {
    $(window).scroll(function () {
      d();
    });
  }
  d(), c(), $(window).resize(c);
}
function formLabel() {
  $(".order_form input").each(function () {
    var t = $(this),
      e = t.siblings("label");
    t.blur(),
      "" == t.val()
        ? e.css({
            "font-size": "14px",
            left: "10px",
            top: "10px",
            transition: "0.3s ease-out",
          })
        : e.css({
            "font-size": "12px",
            left: "0",
            top: "-20px",
            transition: "0.3s ease-out",
          }),
      e.click(function () {
        e.css({
          "font-size": "12px",
          left: "0",
          top: "-20px",
          transition: "0.3s ease-out",
        }),
          t.focus();
      }),
      t.focus(function () {
        "" == t.val() &&
          e.css({
            "font-size": "12px",
            left: "0",
            top: "-20px",
            transition: "0.3s ease-out",
          });
      }),
      t.blur(function () {
        "" == t.val() &&
          e.css({
            "font-size": "14px",
            left: "10px",
            top: "10px",
            transition: "0.3s ease-out",
          });
      });
  });
}
function scrollToElement(t) {
  if (!$("div, ul").is("." + t)) return !1;
  var e = $("." + t).offset().top,
    i = $("." + t).outerHeight(!0);
  e + i - $(window).height() - i < $(this).scrollTop() &&
    $("." + t).addClass("active");
}
void 0 === jQuery.migrateMute && (jQuery.migrateMute = !0),
  (function (h, i, o) {
    function d(t) {
      var e = i.console;
      a[t] ||
        ((a[t] = !0),
        h.migrateWarnings.push(t),
        e &&
          e.warn &&
          !h.migrateMute &&
          (e.warn("JQMIGRATE: " + t), h.migrateTrace && e.trace && e.trace()));
    }
    function t(t, e, i, a) {
      if (Object.defineProperty)
        try {
          return void Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !0,
            get: function () {
              return d(a), i;
            },
            set: function (t) {
              d(a), (i = t);
            },
          });
        } catch (t) {}
      (h._definePropertyBroken = !0), (t[e] = i);
    }
    h.migrateVersion = "1.4.1";
    var a = {};
    (h.migrateWarnings = []),
      i.console &&
        i.console.log &&
        i.console.log(
          "JQMIGRATE: Migrate is installed" +
            (h.migrateMute ? "" : " with logging active") +
            ", version " +
            h.migrateVersion
        ),
      h.migrateTrace === o && (h.migrateTrace = !0),
      (h.migrateReset = function () {
        (a = {}), (h.migrateWarnings.length = 0);
      }),
      "BackCompat" === document.compatMode &&
        d("jQuery is not compatible with Quirks Mode");
    var r = h("<input/>", { size: 1 }).attr("size") && h.attrFn,
      l = h.attr,
      s =
        (h.attrHooks.value && h.attrHooks.value.get) ||
        function () {
          return null;
        },
      n =
        (h.attrHooks.value && h.attrHooks.value.set) ||
        function () {
          return o;
        },
      c = /^(?:input|button)$/i,
      p = /^[238]$/,
      u =
        /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
      x = /^(?:checked|selected)$/i;
    t(h, "attrFn", r || {}, "jQuery.attrFn is deprecated"),
      (h.attr = function (t, e, i, a) {
        var s = e.toLowerCase(),
          n = t && t.nodeType;
        return a &&
          (l.length < 4 && d("jQuery.fn.attr( props, pass ) is deprecated"),
          t && !p.test(n) && (r ? e in r : h.isFunction(h.fn[e])))
          ? h(t)[e](i)
          : ("type" === e &&
              i !== o &&
              c.test(t.nodeName) &&
              t.parentNode &&
              d("Can't change the 'type' of an input or button in IE 6/7/8"),
            !h.attrHooks[s] &&
              u.test(s) &&
              ((h.attrHooks[s] = {
                get: function (t, e) {
                  var i,
                    a = h.prop(t, e);
                  return !0 === a ||
                    ("boolean" != typeof a &&
                      (i = t.getAttributeNode(e)) &&
                      !1 !== i.nodeValue)
                    ? e.toLowerCase()
                    : o;
                },
                set: function (t, e, i) {
                  var a;
                  return (
                    !1 === e
                      ? h.removeAttr(t, i)
                      : ((a = h.propFix[i] || i) in t && (t[a] = !0),
                        t.setAttribute(i, i.toLowerCase())),
                    i
                  );
                },
              }),
              x.test(s) &&
                d(
                  "jQuery.fn.attr('" +
                    s +
                    "') might use property instead of attribute"
                )),
            l.call(h, t, e, i));
      }),
      (h.attrHooks.value = {
        get: function (t, e) {
          var i = (t.nodeName || "").toLowerCase();
          return "button" === i
            ? s.apply(this, arguments)
            : ("input" !== i &&
                "option" !== i &&
                d("jQuery.fn.attr('value') no longer gets properties"),
              e in t ? t.value : null);
        },
        set: function (t, e) {
          var i = (t.nodeName || "").toLowerCase();
          return "button" === i
            ? n.apply(this, arguments)
            : ("input" !== i &&
                "option" !== i &&
                d("jQuery.fn.attr('value', val) no longer sets properties"),
              void (t.value = e));
        },
      });
    var e,
      m,
      g,
      b = h.fn.init,
      v = h.find,
      f = h.parseJSON,
      y = /^\s*</,
      M = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/,
      k = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/g,
      w = /^([^<]*)(<[\w\W]+>)([^>]*)$/;
    for (g in ((h.fn.init = function (t, e, i) {
      var a, s;
      return t &&
        "string" == typeof t &&
        !h.isPlainObject(e) &&
        (a = w.exec(h.trim(t))) &&
        a[0] &&
        (y.test(t) || d("$(html) HTML strings must start with '<' character"),
        a[3] && d("$(html) HTML text after last tag is ignored"),
        "#" === a[0].charAt(0) &&
          (d("HTML string cannot start with a '#' character"),
          h.error("JQMIGRATE: Invalid selector string (XSS)")),
        e && e.context && e.context.nodeType && (e = e.context),
        h.parseHTML)
        ? b.call(
            this,
            h.parseHTML(a[2], (e && e.ownerDocument) || e || document, !0),
            e,
            i
          )
        : ((s = b.apply(this, arguments)),
          t && t.selector !== o
            ? ((s.selector = t.selector), (s.context = t.context))
            : ((s.selector = "string" == typeof t ? t : ""),
              t && (s.context = t.nodeType ? t : e || document)),
          s);
    }),
    (h.fn.init.prototype = h.fn),
    (h.find = function (e) {
      var i = Array.prototype.slice.call(arguments);
      if ("string" == typeof e && M.test(e))
        try {
          document.querySelector(e);
        } catch (t) {
          e = e.replace(k, function (t, e, i, a) {
            return "[" + e + i + '"' + a + '"]';
          });
          try {
            document.querySelector(e),
              d("Attribute selector with '#' must be quoted: " + i[0]),
              (i[0] = e);
          } catch (t) {
            d("Attribute selector with '#' was not fixed: " + i[0]);
          }
        }
      return v.apply(this, i);
    }),
    v))
      Object.prototype.hasOwnProperty.call(v, g) && (h.find[g] = v[g]);
    (h.parseJSON = function (t) {
      return t
        ? f.apply(this, arguments)
        : (d("jQuery.parseJSON requires a valid JSON string"), null);
    }),
      (h.uaMatch = function (t) {
        t = t.toLowerCase();
        var e =
          /(chrome)[ \/]([\w.]+)/.exec(t) ||
          /(webkit)[ \/]([\w.]+)/.exec(t) ||
          /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(t) ||
          /(msie) ([\w.]+)/.exec(t) ||
          (t.indexOf("compatible") < 0 &&
            /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(t)) ||
          [];
        return { browser: e[1] || "", version: e[2] || "0" };
      }),
      h.browser ||
        ((m = {}),
        (e = h.uaMatch(navigator.userAgent)).browser &&
          ((m[e.browser] = !0), (m.version = e.version)),
        m.chrome ? (m.webkit = !0) : m.webkit && (m.safari = !0),
        (h.browser = m)),
      t(h, "browser", h.browser, "jQuery.browser is deprecated"),
      (h.boxModel = h.support.boxModel = "CSS1Compat" === document.compatMode),
      t(h, "boxModel", h.boxModel, "jQuery.boxModel is deprecated"),
      t(
        h.support,
        "boxModel",
        h.support.boxModel,
        "jQuery.support.boxModel is deprecated"
      ),
      (h.sub = function () {
        function a(t, e) {
          return new a.fn.init(t, e);
        }
        h.extend(!0, a, this),
          (a.superclass = this),
          (((a.fn = a.prototype = this()).constructor = a).sub = this.sub),
          (a.fn.init = function (t, e) {
            var i = h.fn.init.call(this, t, e, s);
            return i instanceof a ? i : a(i);
          }),
          (a.fn.init.prototype = a.fn);
        var s = a(document);
        return d("jQuery.sub() is deprecated"), a;
      });
    var T = !(h.fn.size = function () {
      return (
        d("jQuery.fn.size() is deprecated; use the .length property"),
        this.length
      );
    });
    h.swap &&
      h.each(["height", "width", "reliableMarginRight"], function (t, e) {
        var i = h.cssHooks[e] && h.cssHooks[e].get;
        i &&
          (h.cssHooks[e].get = function () {
            var t;
            return (T = !0), (t = i.apply(this, arguments)), (T = !1), t;
          });
      }),
      (h.swap = function (t, e, i, a) {
        var s,
          n,
          o = {};
        for (n in (T || d("jQuery.swap() is undocumented and deprecated"), e))
          (o[n] = t.style[n]), (t.style[n] = e[n]);
        for (n in ((s = i.apply(t, a || [])), e)) t.style[n] = o[n];
        return s;
      }),
      h.ajaxSetup({ converters: { "text json": h.parseJSON } });
    var C = h.fn.data;
    h.fn.data = function (t) {
      var e,
        i,
        a = this[0];
      return !a ||
        "events" !== t ||
        1 !== arguments.length ||
        ((e = h.data(a, t)),
        (i = h._data(a, t)),
        (e !== o && e !== i) || i === o)
        ? C.apply(this, arguments)
        : (d("Use of jQuery.fn.data('events') is deprecated"), i);
    };
    var P = /\/(java|ecma)script/i;
    h.clean ||
      (h.clean = function (t, e, i, a) {
        (e =
          (e = (!(e = e || document).nodeType && e[0]) || e).ownerDocument ||
          e),
          d("jQuery.clean() is deprecated");
        var s,
          n,
          o,
          r,
          l = [];
        if ((h.merge(l, h.buildFragment(t, e).childNodes), i))
          for (
            o = function (t) {
              return !t.type || P.test(t.type)
                ? a
                  ? a.push(t.parentNode ? t.parentNode.removeChild(t) : t)
                  : i.appendChild(t)
                : void 0;
            },
              s = 0;
            null != (n = l[s]);
            s++
          )
            (h.nodeName(n, "script") && o(n)) ||
              (i.appendChild(n),
              void 0 !== n.getElementsByTagName &&
                ((r = h.grep(h.merge([], n.getElementsByTagName("script")), o)),
                l.splice.apply(l, [s + 1, 0].concat(r)),
                (s += r.length)));
        return l;
      });
    var S = h.event.add,
      A = h.event.remove,
      _ = h.event.trigger,
      B = h.fn.toggle,
      F = h.fn.live,
      L = h.fn.die,
      I = h.fn.load,
      E = "ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess",
      D = new RegExp("\\b(?:" + E + ")\\b"),
      V = /(?:^|\s)hover(\.\S+|)\b/,
      z = function (t) {
        return "string" != typeof t || h.event.special.hover
          ? t
          : (V.test(t) &&
              d(
                "'hover' pseudo-event is deprecated, use 'mouseenter mouseleave'"
              ),
            t && t.replace(V, "mouseenter$1 mouseleave$1"));
      };
    h.event.props &&
      "attrChange" !== h.event.props[0] &&
      h.event.props.unshift(
        "attrChange",
        "attrName",
        "relatedNode",
        "srcElement"
      ),
      h.event.dispatch &&
        t(
          h.event,
          "handle",
          h.event.dispatch,
          "jQuery.event.handle is undocumented and deprecated"
        ),
      (h.event.add = function (t, e, i, a, s) {
        t !== document &&
          D.test(e) &&
          d("AJAX events should be attached to document: " + e),
          S.call(this, t, z(e || ""), i, a, s);
      }),
      (h.event.remove = function (t, e, i, a, s) {
        A.call(this, t, z(e) || "", i, a, s);
      }),
      h.each(["load", "unload", "error"], function (t, e) {
        h.fn[e] = function () {
          var t = Array.prototype.slice.call(arguments, 0);
          return "load" === e && "string" == typeof t[0]
            ? I.apply(this, t)
            : (d("jQuery.fn." + e + "() is deprecated"),
              t.splice(0, 0, e),
              arguments.length
                ? this.bind.apply(this, t)
                : (this.triggerHandler.apply(this, t), this));
        };
      }),
      (h.fn.toggle = function (i, t) {
        if (!h.isFunction(i) || !h.isFunction(t))
          return B.apply(this, arguments);
        d("jQuery.fn.toggle(handler, handler...) is deprecated");
        var a = arguments,
          e = i.guid || h.guid++,
          s = 0,
          n = function (t) {
            var e = (h._data(this, "lastToggle" + i.guid) || 0) % s;
            return (
              h._data(this, "lastToggle" + i.guid, e + 1),
              t.preventDefault(),
              a[e].apply(this, arguments) || !1
            );
          };
        for (n.guid = e; s < a.length; ) a[s++].guid = e;
        return this.click(n);
      }),
      (h.fn.live = function (t, e, i) {
        return (
          d("jQuery.fn.live() is deprecated"),
          F
            ? F.apply(this, arguments)
            : (h(this.context).on(t, this.selector, e, i), this)
        );
      }),
      (h.fn.die = function (t, e) {
        return (
          d("jQuery.fn.die() is deprecated"),
          L
            ? L.apply(this, arguments)
            : (h(this.context).off(t, this.selector || "**", e), this)
        );
      }),
      (h.event.trigger = function (t, e, i, a) {
        return (
          i || D.test(t) || d("Global events are undocumented and deprecated"),
          _.call(this, t, e, i || document, a)
        );
      }),
      h.each(E.split("|"), function (t, e) {
        h.event.special[e] = {
          setup: function () {
            var t = this;
            return (
              t !== document &&
                (h.event.add(document, e + "." + h.guid, function () {
                  h.event.trigger(
                    e,
                    Array.prototype.slice.call(arguments, 1),
                    t,
                    !0
                  );
                }),
                h._data(this, e, h.guid++)),
              !1
            );
          },
          teardown: function () {
            return (
              this !== document &&
                h.event.remove(document, e + "." + h._data(this, e)),
              !1
            );
          },
        };
      }),
      (h.event.special.ready = {
        setup: function () {
          this === document && d("'ready' event is deprecated");
        },
      });
    var W = h.fn.andSelf || h.fn.addBack,
      X = h.fn.find;
    if (
      ((h.fn.andSelf = function () {
        return (
          d("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()"),
          W.apply(this, arguments)
        );
      }),
      (h.fn.find = function (t) {
        var e = X.apply(this, arguments);
        return (
          (e.context = this.context),
          (e.selector = this.selector ? this.selector + " " + t : t),
          e
        );
      }),
      h.Callbacks)
    ) {
      var Y = h.Deferred,
        O = [
          [
            "resolve",
            "done",
            h.Callbacks("once memory"),
            h.Callbacks("once memory"),
            "resolved",
          ],
          [
            "reject",
            "fail",
            h.Callbacks("once memory"),
            h.Callbacks("once memory"),
            "rejected",
          ],
          ["notify", "progress", h.Callbacks("memory"), h.Callbacks("memory")],
        ];
      h.Deferred = function (t) {
        var n = Y(),
          o = n.promise();
        return (
          (n.pipe = o.pipe =
            function () {
              var s = arguments;
              return (
                d("deferred.pipe() is deprecated"),
                h
                  .Deferred(function (a) {
                    h.each(O, function (t, e) {
                      var i = h.isFunction(s[t]) && s[t];
                      n[e[1]](function () {
                        var t = i && i.apply(this, arguments);
                        t && h.isFunction(t.promise)
                          ? t
                              .promise()
                              .done(a.resolve)
                              .fail(a.reject)
                              .progress(a.notify)
                          : a[e[0] + "With"](
                              this === o ? a.promise() : this,
                              i ? [t] : arguments
                            );
                      });
                    }),
                      (s = null);
                  })
                  .promise()
              );
            }),
          (n.isResolved = function () {
            return (
              d("deferred.isResolved is deprecated"), "resolved" === n.state()
            );
          }),
          (n.isRejected = function () {
            return (
              d("deferred.isRejected is deprecated"), "rejected" === n.state()
            );
          }),
          t && t.call(n, n),
          n
        );
      };
    }
  })(jQuery, window),
  ($ = jQuery),
  $("img.img_svg").each(function () {
    var i = jQuery(this),
      a = i.attr("id"),
      s = i.attr("class"),
      t = i.attr("src");
    $.get(
      t,
      function (t) {
        var e = jQuery(t).find("svg");
        void 0 !== a && (e = e.attr("id", a)),
          void 0 !== s && (e = e.attr("class", s + " replaced-svg")),
          !(e = e.removeAttr("xmlns:a")).attr("viewBox") &&
            e.attr("height") &&
            e.attr("width") &&
            e.attr(
              "viewBox",
              "0 0 " + e.attr("height") + " " + e.attr("width")
            ),
          i.replaceWith(e);
      },
      "xml"
    );
  }),
  $("select").each(function () {
    var e = $(this),
      t = $(this).children("option").length;
    e.addClass("select-hidden"),
      e.wrap('<div class="select"></div>'),
      e.after('<div class="select-styled"></div>');
    var i = e.next("div.select-styled");
    i.text(e.children("option").eq(0).text());
    for (
      var a = $("<ul />", { class: "select-options" }).insertAfter(i), s = 0;
      s < t;
      s++
    )
      $("<li />", {
        text: e.children("option").eq(s).text(),
        rel: e.children("option").eq(s).val(),
      }).appendTo(a);
    var n = a.children("li");
    i.click(function (t) {
      t.stopPropagation(),
        $("div.select-styled.active")
          .not(this)
          .each(function () {
            $(this).removeClass("active").next("ul.select-options").hide();
          }),
        $(this).toggleClass("active").next("ul.select-options").toggle();
    }),
      n.click(function (t) {
        t.stopPropagation(),
          i.text($(this).text()).removeClass("active"),
          e
            .val($(this).attr("rel"))
            .attr("data-select-id", $(this).attr("rel")),
          a.hide();
      }),
      $(document).click(function () {
        i.removeClass("active"), a.hide();
      });
  }),
  (function (t, e) {
    "object" == typeof exports && "undefined" != typeof module
      ? (module.exports = e())
      : "function" == typeof define && define.amd
      ? define(e)
      : (t.Swiper = e());
  })(this, function () {
    "use strict";
    var m =
        "undefined" == typeof document
          ? {
              body: {},
              addEventListener: function () {},
              removeEventListener: function () {},
              activeElement: { blur: function () {}, nodeName: "" },
              querySelector: function () {
                return null;
              },
              querySelectorAll: function () {
                return [];
              },
              getElementById: function () {
                return null;
              },
              createEvent: function () {
                return { initEvent: function () {} };
              },
              createElement: function () {
                return {
                  children: [],
                  childNodes: [],
                  style: {},
                  setAttribute: function () {},
                  getElementsByTagName: function () {
                    return [];
                  },
                };
              },
              location: { hash: "" },
            }
          : document,
      O =
        "undefined" == typeof window
          ? {
              document: m,
              navigator: { userAgent: "" },
              location: {},
              history: {},
              CustomEvent: function () {
                return this;
              },
              addEventListener: function () {},
              removeEventListener: function () {},
              getComputedStyle: function () {
                return {
                  getPropertyValue: function () {
                    return "";
                  },
                };
              },
              Image: function () {},
              Date: function () {},
              screen: {},
              setTimeout: function () {},
              clearTimeout: function () {},
            }
          : window,
      l = function (t) {
        for (var e = 0; e < t.length; e += 1) this[e] = t[e];
        return (this.length = t.length), this;
      };
    function F(t, e) {
      var i = [],
        a = 0;
      if (t && !e && t instanceof l) return t;
      if (t)
        if ("string" == typeof t) {
          var s,
            n,
            o = t.trim();
          if (0 <= o.indexOf("<") && 0 <= o.indexOf(">")) {
            var r = "div";
            for (
              0 === o.indexOf("<li") && (r = "ul"),
                0 === o.indexOf("<tr") && (r = "tbody"),
                (0 !== o.indexOf("<td") && 0 !== o.indexOf("<th")) ||
                  (r = "tr"),
                0 === o.indexOf("<tbody") && (r = "table"),
                0 === o.indexOf("<option") && (r = "select"),
                (n = m.createElement(r)).innerHTML = o,
                a = 0;
              a < n.childNodes.length;
              a += 1
            )
              i.push(n.childNodes[a]);
          } else
            for (
              s =
                e || "#" !== t[0] || t.match(/[ .<>:~]/)
                  ? (e || m).querySelectorAll(t.trim())
                  : [m.getElementById(t.trim().split("#")[1])],
                a = 0;
              a < s.length;
              a += 1
            )
              s[a] && i.push(s[a]);
        } else if (t.nodeType || t === O || t === m) i.push(t);
        else if (0 < t.length && t[0].nodeType)
          for (a = 0; a < t.length; a += 1) i.push(t[a]);
      return new l(i);
    }
    function n(t) {
      for (var e = [], i = 0; i < t.length; i += 1)
        -1 === e.indexOf(t[i]) && e.push(t[i]);
      return e;
    }
    (F.fn = l.prototype), (F.Class = l), (F.Dom7 = l);
    var e = {
      addClass: function (t) {
        if (void 0 === t) return this;
        for (var e = t.split(" "), i = 0; i < e.length; i += 1)
          for (var a = 0; a < this.length; a += 1)
            void 0 !== this[a] &&
              void 0 !== this[a].classList &&
              this[a].classList.add(e[i]);
        return this;
      },
      removeClass: function (t) {
        for (var e = t.split(" "), i = 0; i < e.length; i += 1)
          for (var a = 0; a < this.length; a += 1)
            void 0 !== this[a] &&
              void 0 !== this[a].classList &&
              this[a].classList.remove(e[i]);
        return this;
      },
      hasClass: function (t) {
        return !!this[0] && this[0].classList.contains(t);
      },
      toggleClass: function (t) {
        for (var e = t.split(" "), i = 0; i < e.length; i += 1)
          for (var a = 0; a < this.length; a += 1)
            void 0 !== this[a] &&
              void 0 !== this[a].classList &&
              this[a].classList.toggle(e[i]);
        return this;
      },
      attr: function (t, e) {
        var i = arguments;
        if (1 === arguments.length && "string" == typeof t)
          return this[0] ? this[0].getAttribute(t) : void 0;
        for (var a = 0; a < this.length; a += 1)
          if (2 === i.length) this[a].setAttribute(t, e);
          else
            for (var s in t) (this[a][s] = t[s]), this[a].setAttribute(s, t[s]);
        return this;
      },
      removeAttr: function (t) {
        for (var e = 0; e < this.length; e += 1) this[e].removeAttribute(t);
        return this;
      },
      data: function (t, e) {
        var i;
        if (void 0 !== e) {
          for (var a = 0; a < this.length; a += 1)
            (i = this[a]).dom7ElementDataStorage ||
              (i.dom7ElementDataStorage = {}),
              (i.dom7ElementDataStorage[t] = e);
          return this;
        }
        if ((i = this[0]))
          return i.dom7ElementDataStorage && t in i.dom7ElementDataStorage
            ? i.dom7ElementDataStorage[t]
            : i.getAttribute("data-" + t) || void 0;
      },
      transform: function (t) {
        for (var e = 0; e < this.length; e += 1) {
          var i = this[e].style;
          (i.webkitTransform = t), (i.transform = t);
        }
        return this;
      },
      transition: function (t) {
        "string" != typeof t && (t += "ms");
        for (var e = 0; e < this.length; e += 1) {
          var i = this[e].style;
          (i.webkitTransitionDuration = t), (i.transitionDuration = t);
        }
        return this;
      },
      on: function () {
        for (var t, e = [], i = arguments.length; i--; ) e[i] = arguments[i];
        var a = e[0],
          n = e[1],
          o = e[2],
          s = e[3];
        function r(t) {
          var e = t.target;
          if (e) {
            var i = t.target.dom7EventData || [];
            if ((i.indexOf(t) < 0 && i.unshift(t), F(e).is(n))) o.apply(e, i);
            else
              for (var a = F(e).parents(), s = 0; s < a.length; s += 1)
                F(a[s]).is(n) && o.apply(a[s], i);
          }
        }
        function l(t) {
          var e = (t && t.target && t.target.dom7EventData) || [];
          e.indexOf(t) < 0 && e.unshift(t), o.apply(this, e);
        }
        "function" == typeof e[1] &&
          ((a = (t = e)[0]), (o = t[1]), (s = t[2]), (n = void 0)),
          s || (s = !1);
        for (var h, d = a.split(" "), c = 0; c < this.length; c += 1) {
          var p = this[c];
          if (n)
            for (h = 0; h < d.length; h += 1) {
              var u = d[h];
              p.dom7LiveListeners || (p.dom7LiveListeners = {}),
                p.dom7LiveListeners[u] || (p.dom7LiveListeners[u] = []),
                p.dom7LiveListeners[u].push({ listener: o, proxyListener: r }),
                p.addEventListener(u, r, s);
            }
          else
            for (h = 0; h < d.length; h += 1) {
              var x = d[h];
              p.dom7Listeners || (p.dom7Listeners = {}),
                p.dom7Listeners[x] || (p.dom7Listeners[x] = []),
                p.dom7Listeners[x].push({ listener: o, proxyListener: l }),
                p.addEventListener(x, l, s);
            }
        }
        return this;
      },
      off: function () {
        for (var t, e = [], i = arguments.length; i--; ) e[i] = arguments[i];
        var a = e[0],
          s = e[1],
          n = e[2],
          o = e[3];
        "function" == typeof e[1] &&
          ((a = (t = e)[0]), (n = t[1]), (o = t[2]), (s = void 0)),
          o || (o = !1);
        for (var r = a.split(" "), l = 0; l < r.length; l += 1)
          for (var h = r[l], d = 0; d < this.length; d += 1) {
            var c = this[d],
              p = void 0;
            if (
              (!s && c.dom7Listeners
                ? (p = c.dom7Listeners[h])
                : s && c.dom7LiveListeners && (p = c.dom7LiveListeners[h]),
              p && p.length)
            )
              for (var u = p.length - 1; 0 <= u; u -= 1) {
                var x = p[u];
                n && x.listener === n
                  ? (c.removeEventListener(h, x.proxyListener, o),
                    p.splice(u, 1))
                  : n ||
                    (c.removeEventListener(h, x.proxyListener, o),
                    p.splice(u, 1));
              }
          }
        return this;
      },
      trigger: function () {
        for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];
        for (var i = t[0].split(" "), a = t[1], s = 0; s < i.length; s += 1)
          for (var n = i[s], o = 0; o < this.length; o += 1) {
            var r = this[o],
              l = void 0;
            try {
              l = new O.CustomEvent(n, {
                detail: a,
                bubbles: !0,
                cancelable: !0,
              });
            } catch (t) {
              (l = m.createEvent("Event")).initEvent(n, !0, !0), (l.detail = a);
            }
            (r.dom7EventData = t.filter(function (t, e) {
              return 0 < e;
            })),
              r.dispatchEvent(l),
              (r.dom7EventData = []),
              delete r.dom7EventData;
          }
        return this;
      },
      transitionEnd: function (e) {
        var i,
          a = ["webkitTransitionEnd", "transitionend"],
          s = this;
        function n(t) {
          if (t.target === this)
            for (e.call(this, t), i = 0; i < a.length; i += 1) s.off(a[i], n);
        }
        if (e) for (i = 0; i < a.length; i += 1) s.on(a[i], n);
        return this;
      },
      outerWidth: function (t) {
        if (0 < this.length) {
          if (t) {
            var e = this.styles();
            return (
              this[0].offsetWidth +
              parseFloat(e.getPropertyValue("margin-right")) +
              parseFloat(e.getPropertyValue("margin-left"))
            );
          }
          return this[0].offsetWidth;
        }
        return null;
      },
      outerHeight: function (t) {
        if (0 < this.length) {
          if (t) {
            var e = this.styles();
            return (
              this[0].offsetHeight +
              parseFloat(e.getPropertyValue("margin-top")) +
              parseFloat(e.getPropertyValue("margin-bottom"))
            );
          }
          return this[0].offsetHeight;
        }
        return null;
      },
      offset: function () {
        if (0 < this.length) {
          var t = this[0],
            e = t.getBoundingClientRect(),
            i = m.body,
            a = t.clientTop || i.clientTop || 0,
            s = t.clientLeft || i.clientLeft || 0,
            n = t === O ? O.scrollY : t.scrollTop,
            o = t === O ? O.scrollX : t.scrollLeft;
          return { top: e.top + n - a, left: e.left + o - s };
        }
        return null;
      },
      css: function (t, e) {
        var i;
        if (1 === arguments.length) {
          if ("string" != typeof t) {
            for (i = 0; i < this.length; i += 1)
              for (var a in t) this[i].style[a] = t[a];
            return this;
          }
          if (this[0])
            return O.getComputedStyle(this[0], null).getPropertyValue(t);
        }
        if (2 !== arguments.length || "string" != typeof t) return this;
        for (i = 0; i < this.length; i += 1) this[i].style[t] = e;
        return this;
      },
      each: function (t) {
        if (!t) return this;
        for (var e = 0; e < this.length; e += 1)
          if (!1 === t.call(this[e], e, this[e])) return this;
        return this;
      },
      html: function (t) {
        if (void 0 === t) return this[0] ? this[0].innerHTML : void 0;
        for (var e = 0; e < this.length; e += 1) this[e].innerHTML = t;
        return this;
      },
      text: function (t) {
        if (void 0 === t) return this[0] ? this[0].textContent.trim() : null;
        for (var e = 0; e < this.length; e += 1) this[e].textContent = t;
        return this;
      },
      is: function (t) {
        var e,
          i,
          a = this[0];
        if (!a || void 0 === t) return !1;
        if ("string" == typeof t) {
          if (a.matches) return a.matches(t);
          if (a.webkitMatchesSelector) return a.webkitMatchesSelector(t);
          if (a.msMatchesSelector) return a.msMatchesSelector(t);
          for (e = F(t), i = 0; i < e.length; i += 1) if (e[i] === a) return !0;
          return !1;
        }
        if (t === m) return a === m;
        if (t === O) return a === O;
        if (t.nodeType || t instanceof l) {
          for (e = t.nodeType ? [t] : t, i = 0; i < e.length; i += 1)
            if (e[i] === a) return !0;
          return !1;
        }
        return !1;
      },
      index: function () {
        var t,
          e = this[0];
        if (e) {
          for (t = 0; null !== (e = e.previousSibling); )
            1 === e.nodeType && (t += 1);
          return t;
        }
      },
      eq: function (t) {
        if (void 0 === t) return this;
        var e,
          i = this.length;
        return new l(
          i - 1 < t
            ? []
            : t < 0
            ? (e = i + t) < 0
              ? []
              : [this[e]]
            : [this[t]]
        );
      },
      append: function () {
        for (var t, e = [], i = arguments.length; i--; ) e[i] = arguments[i];
        for (var a = 0; a < e.length; a += 1) {
          t = e[a];
          for (var s = 0; s < this.length; s += 1)
            if ("string" == typeof t) {
              var n = m.createElement("div");
              for (n.innerHTML = t; n.firstChild; )
                this[s].appendChild(n.firstChild);
            } else if (t instanceof l)
              for (var o = 0; o < t.length; o += 1) this[s].appendChild(t[o]);
            else this[s].appendChild(t);
        }
        return this;
      },
      prepend: function (t) {
        var e,
          i,
          a = this;
        for (e = 0; e < this.length; e += 1)
          if ("string" == typeof t) {
            var s = m.createElement("div");
            for (s.innerHTML = t, i = s.childNodes.length - 1; 0 <= i; i -= 1)
              a[e].insertBefore(s.childNodes[i], a[e].childNodes[0]);
          } else if (t instanceof l)
            for (i = 0; i < t.length; i += 1)
              a[e].insertBefore(t[i], a[e].childNodes[0]);
          else a[e].insertBefore(t, a[e].childNodes[0]);
        return this;
      },
      next: function (t) {
        return 0 < this.length
          ? t
            ? this[0].nextElementSibling && F(this[0].nextElementSibling).is(t)
              ? new l([this[0].nextElementSibling])
              : new l([])
            : this[0].nextElementSibling
            ? new l([this[0].nextElementSibling])
            : new l([])
          : new l([]);
      },
      nextAll: function (t) {
        var e = [],
          i = this[0];
        if (!i) return new l([]);
        for (; i.nextElementSibling; ) {
          var a = i.nextElementSibling;
          t ? F(a).is(t) && e.push(a) : e.push(a), (i = a);
        }
        return new l(e);
      },
      prev: function (t) {
        if (0 < this.length) {
          var e = this[0];
          return t
            ? e.previousElementSibling && F(e.previousElementSibling).is(t)
              ? new l([e.previousElementSibling])
              : new l([])
            : e.previousElementSibling
            ? new l([e.previousElementSibling])
            : new l([]);
        }
        return new l([]);
      },
      prevAll: function (t) {
        var e = [],
          i = this[0];
        if (!i) return new l([]);
        for (; i.previousElementSibling; ) {
          var a = i.previousElementSibling;
          t ? F(a).is(t) && e.push(a) : e.push(a), (i = a);
        }
        return new l(e);
      },
      parent: function (t) {
        for (var e = [], i = 0; i < this.length; i += 1)
          null !== this[i].parentNode &&
            (t
              ? F(this[i].parentNode).is(t) && e.push(this[i].parentNode)
              : e.push(this[i].parentNode));
        return F(n(e));
      },
      parents: function (t) {
        for (var e = [], i = 0; i < this.length; i += 1)
          for (var a = this[i].parentNode; a; )
            t ? F(a).is(t) && e.push(a) : e.push(a), (a = a.parentNode);
        return F(n(e));
      },
      closest: function (t) {
        var e = this;
        return void 0 === t
          ? new l([])
          : (e.is(t) || (e = e.parents(t).eq(0)), e);
      },
      find: function (t) {
        for (var e = [], i = 0; i < this.length; i += 1)
          for (var a = this[i].querySelectorAll(t), s = 0; s < a.length; s += 1)
            e.push(a[s]);
        return new l(e);
      },
      children: function (t) {
        for (var e = [], i = 0; i < this.length; i += 1)
          for (var a = this[i].childNodes, s = 0; s < a.length; s += 1)
            t
              ? 1 === a[s].nodeType && F(a[s]).is(t) && e.push(a[s])
              : 1 === a[s].nodeType && e.push(a[s]);
        return new l(n(e));
      },
      remove: function () {
        for (var t = 0; t < this.length; t += 1)
          this[t].parentNode && this[t].parentNode.removeChild(this[t]);
        return this;
      },
      add: function () {
        for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];
        var i, a;
        for (i = 0; i < t.length; i += 1) {
          var s = F(t[i]);
          for (a = 0; a < s.length; a += 1)
            (this[this.length] = s[a]), (this.length += 1);
        }
        return this;
      },
      styles: function () {
        return this[0] ? O.getComputedStyle(this[0], null) : {};
      },
    };
    Object.keys(e).forEach(function (t) {
      F.fn[t] = e[t];
    });
    var t,
      i,
      a,
      R = {
        deleteProps: function (t) {
          var e = t;
          Object.keys(e).forEach(function (t) {
            try {
              e[t] = null;
            } catch (t) {}
            try {
              delete e[t];
            } catch (t) {}
          });
        },
        nextTick: function (t, e) {
          return void 0 === e && (e = 0), setTimeout(t, e);
        },
        now: function () {
          return Date.now();
        },
        getTranslate: function (t, e) {
          var i, a, s;
          void 0 === e && (e = "x");
          var n = O.getComputedStyle(t, null);
          return (
            O.WebKitCSSMatrix
              ? (6 < (a = n.transform || n.webkitTransform).split(",").length &&
                  (a = a
                    .split(", ")
                    .map(function (t) {
                      return t.replace(",", ".");
                    })
                    .join(", ")),
                (s = new O.WebKitCSSMatrix("none" === a ? "" : a)))
              : (i = (s =
                  n.MozTransform ||
                  n.OTransform ||
                  n.MsTransform ||
                  n.msTransform ||
                  n.transform ||
                  n
                    .getPropertyValue("transform")
                    .replace("translate(", "matrix(1, 0, 0, 1,"))
                  .toString()
                  .split(",")),
            "x" === e &&
              (a = O.WebKitCSSMatrix
                ? s.m41
                : 16 === i.length
                ? parseFloat(i[12])
                : parseFloat(i[4])),
            "y" === e &&
              (a = O.WebKitCSSMatrix
                ? s.m42
                : 16 === i.length
                ? parseFloat(i[13])
                : parseFloat(i[5])),
            a || 0
          );
        },
        parseUrlQuery: function (t) {
          var e,
            i,
            a,
            s,
            n = {},
            o = t || O.location.href;
          if ("string" == typeof o && o.length)
            for (
              s = (i = (o = -1 < o.indexOf("?") ? o.replace(/\S*\?/, "") : "")
                .split("&")
                .filter(function (t) {
                  return "" !== t;
                })).length,
                e = 0;
              e < s;
              e += 1
            )
              (a = i[e].replace(/#\S+/g, "").split("=")),
                (n[decodeURIComponent(a[0])] =
                  void 0 === a[1] ? void 0 : decodeURIComponent(a[1]) || "");
          return n;
        },
        isObject: function (t) {
          return (
            "object" == typeof t &&
            null !== t &&
            t.constructor &&
            t.constructor === Object
          );
        },
        extend: function () {
          for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];
          for (var i = Object(t[0]), a = 1; a < t.length; a += 1) {
            var s = t[a];
            if (null != s)
              for (
                var n = Object.keys(Object(s)), o = 0, r = n.length;
                o < r;
                o += 1
              ) {
                var l = n[o],
                  h = Object.getOwnPropertyDescriptor(s, l);
                void 0 !== h &&
                  h.enumerable &&
                  (R.isObject(i[l]) && R.isObject(s[l])
                    ? R.extend(i[l], s[l])
                    : !R.isObject(i[l]) && R.isObject(s[l])
                    ? ((i[l] = {}), R.extend(i[l], s[l]))
                    : (i[l] = s[l]));
              }
          }
          return i;
        },
      },
      N =
        ((a = m.createElement("div")),
        {
          touch:
            (O.Modernizr && !0 === O.Modernizr.touch) ||
            !!(
              "ontouchstart" in O ||
              (O.DocumentTouch && m instanceof O.DocumentTouch)
            ),
          pointerEvents: !(!O.navigator.pointerEnabled && !O.PointerEvent),
          prefixedPointerEvents: !!O.navigator.msPointerEnabled,
          transition:
            ((i = a.style),
            "transition" in i ||
              "webkitTransition" in i ||
              "MozTransition" in i),
          transforms3d:
            (O.Modernizr && !0 === O.Modernizr.csstransforms3d) ||
            ((t = a.style),
            "webkitPerspective" in t ||
              "MozPerspective" in t ||
              "OPerspective" in t ||
              "MsPerspective" in t ||
              "perspective" in t),
          flexbox: (function () {
            for (
              var t = a.style,
                e =
                  "alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(
                    " "
                  ),
                i = 0;
              i < e.length;
              i += 1
            )
              if (e[i] in t) return !0;
            return !1;
          })(),
          observer: "MutationObserver" in O || "WebkitMutationObserver" in O,
          passiveListener: (function () {
            var t = !1;
            try {
              var e = Object.defineProperty({}, "passive", {
                get: function () {
                  t = !0;
                },
              });
              O.addEventListener("testPassiveListener", null, e);
            } catch (t) {}
            return t;
          })(),
          gestures: "ongesturestart" in O,
        }),
      s = function (t) {
        void 0 === t && (t = {});
        var e = this;
        (e.params = t),
          (e.eventsListeners = {}),
          e.params &&
            e.params.on &&
            Object.keys(e.params.on).forEach(function (t) {
              e.on(t, e.params.on[t]);
            });
      },
      o = { components: { configurable: !0 } };
    (s.prototype.on = function (t, e, i) {
      var a = this;
      if ("function" != typeof e) return a;
      var s = i ? "unshift" : "push";
      return (
        t.split(" ").forEach(function (t) {
          a.eventsListeners[t] || (a.eventsListeners[t] = []),
            a.eventsListeners[t][s](e);
        }),
        a
      );
    }),
      (s.prototype.once = function (a, s, t) {
        var n = this;
        return "function" != typeof s
          ? n
          : n.on(
              a,
              function t() {
                for (var e = [], i = arguments.length; i--; )
                  e[i] = arguments[i];
                s.apply(n, e), n.off(a, t);
              },
              t
            );
      }),
      (s.prototype.off = function (t, a) {
        var s = this;
        return (
          s.eventsListeners &&
            t.split(" ").forEach(function (i) {
              void 0 === a
                ? (s.eventsListeners[i] = [])
                : s.eventsListeners[i] &&
                  s.eventsListeners[i].length &&
                  s.eventsListeners[i].forEach(function (t, e) {
                    t === a && s.eventsListeners[i].splice(e, 1);
                  });
            }),
          s
        );
      }),
      (s.prototype.emit = function () {
        for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];
        var i,
          a,
          s,
          n = this;
        return (
          n.eventsListeners &&
            ((s =
              "string" == typeof t[0] || Array.isArray(t[0])
                ? ((i = t[0]), (a = t.slice(1, t.length)), n)
                : ((i = t[0].events), (a = t[0].data), t[0].context || n)),
            (Array.isArray(i) ? i : i.split(" ")).forEach(function (t) {
              if (n.eventsListeners && n.eventsListeners[t]) {
                var e = [];
                n.eventsListeners[t].forEach(function (t) {
                  e.push(t);
                }),
                  e.forEach(function (t) {
                    t.apply(s, a);
                  });
              }
            })),
          n
        );
      }),
      (s.prototype.useModulesParams = function (i) {
        var a = this;
        a.modules &&
          Object.keys(a.modules).forEach(function (t) {
            var e = a.modules[t];
            e.params && R.extend(i, e.params);
          });
      }),
      (s.prototype.useModules = function (a) {
        void 0 === a && (a = {});
        var s = this;
        s.modules &&
          Object.keys(s.modules).forEach(function (t) {
            var i = s.modules[t],
              e = a[t] || {};
            i.instance &&
              Object.keys(i.instance).forEach(function (t) {
                var e = i.instance[t];
                s[t] = "function" == typeof e ? e.bind(s) : e;
              }),
              i.on &&
                s.on &&
                Object.keys(i.on).forEach(function (t) {
                  s.on(t, i.on[t]);
                }),
              i.create && i.create.bind(s)(e);
          });
      }),
      (o.components.set = function (t) {
        this.use && this.use(t);
      }),
      (s.installModule = function (e) {
        for (var t = [], i = arguments.length - 1; 0 < i--; )
          t[i] = arguments[i + 1];
        var a = this;
        a.prototype.modules || (a.prototype.modules = {});
        var s =
          e.name || Object.keys(a.prototype.modules).length + "_" + R.now();
        return (
          (a.prototype.modules[s] = e).proto &&
            Object.keys(e.proto).forEach(function (t) {
              a.prototype[t] = e.proto[t];
            }),
          e.static &&
            Object.keys(e.static).forEach(function (t) {
              a[t] = e.static[t];
            }),
          e.install && e.install.apply(a, t),
          a
        );
      }),
      (s.use = function (t) {
        for (var e = [], i = arguments.length - 1; 0 < i--; )
          e[i] = arguments[i + 1];
        var a = this;
        return Array.isArray(t)
          ? (t.forEach(function (t) {
              return a.installModule(t);
            }),
            a)
          : a.installModule.apply(a, [t].concat(e));
      }),
      Object.defineProperties(s, o);
    var r = {
        updateSize: function () {
          var t,
            e,
            i = this,
            a = i.$el;
          (t = void 0 !== i.params.width ? i.params.width : a[0].clientWidth),
            (e =
              void 0 !== i.params.height ? i.params.height : a[0].clientHeight),
            (0 === t && i.isHorizontal()) ||
              (0 === e && i.isVertical()) ||
              ((t =
                t -
                parseInt(a.css("padding-left"), 10) -
                parseInt(a.css("padding-right"), 10)),
              (e =
                e -
                parseInt(a.css("padding-top"), 10) -
                parseInt(a.css("padding-bottom"), 10)),
              R.extend(i, {
                width: t,
                height: e,
                size: i.isHorizontal() ? t : e,
              }));
        },
        updateSlides: function () {
          var t = this,
            e = t.params,
            i = t.$wrapperEl,
            a = t.size,
            s = t.rtlTranslate,
            n = t.wrongRTL,
            o = t.virtual && e.virtual.enabled,
            r = o ? t.virtual.slides.length : t.slides.length,
            l = i.children("." + t.params.slideClass),
            h = o ? t.virtual.slides.length : l.length,
            d = [],
            c = [],
            p = [],
            u = e.slidesOffsetBefore;
          "function" == typeof u && (u = e.slidesOffsetBefore.call(t));
          var x = e.slidesOffsetAfter;
          "function" == typeof x && (x = e.slidesOffsetAfter.call(t));
          var m = t.snapGrid.length,
            g = t.snapGrid.length,
            b = e.spaceBetween,
            v = -u,
            f = 0,
            y = 0;
          if (void 0 !== a) {
            var M, k;
            "string" == typeof b &&
              0 <= b.indexOf("%") &&
              (b = (parseFloat(b.replace("%", "")) / 100) * a),
              (t.virtualSize = -b),
              s
                ? l.css({ marginLeft: "", marginTop: "" })
                : l.css({ marginRight: "", marginBottom: "" }),
              1 < e.slidesPerColumn &&
                ((M =
                  Math.floor(h / e.slidesPerColumn) ===
                  h / t.params.slidesPerColumn
                    ? h
                    : Math.ceil(h / e.slidesPerColumn) * e.slidesPerColumn),
                "auto" !== e.slidesPerView &&
                  "row" === e.slidesPerColumnFill &&
                  (M = Math.max(M, e.slidesPerView * e.slidesPerColumn)));
            for (
              var w,
                T = e.slidesPerColumn,
                C = M / T,
                P = C - (e.slidesPerColumn * C - h),
                S = 0;
              S < h;
              S += 1
            ) {
              k = 0;
              var A = l.eq(S);
              if (1 < e.slidesPerColumn) {
                var _ = void 0,
                  B = void 0,
                  F = void 0;
                "column" === e.slidesPerColumnFill
                  ? ((F = S - (B = Math.floor(S / T)) * T),
                    (P < B || (B === P && F === T - 1)) &&
                      T <= (F += 1) &&
                      ((F = 0), (B += 1)),
                    (_ = B + (F * M) / T),
                    A.css({
                      "-webkit-box-ordinal-group": _,
                      "-moz-box-ordinal-group": _,
                      "-ms-flex-order": _,
                      "-webkit-order": _,
                      order: _,
                    }))
                  : (B = S - (F = Math.floor(S / C)) * C),
                  A.css(
                    "margin-" + (t.isHorizontal() ? "top" : "left"),
                    0 !== F && e.spaceBetween && e.spaceBetween + "px"
                  )
                    .attr("data-swiper-column", B)
                    .attr("data-swiper-row", F);
              }
              if ("none" !== A.css("display")) {
                if ("auto" === e.slidesPerView) {
                  var L = O.getComputedStyle(A[0], null),
                    I = A[0].style.transform,
                    E = A[0].style.webkitTransform;
                  I && (A[0].style.transform = "none"),
                    E && (A[0].style.webkitTransform = "none"),
                    (k = e.roundLengths
                      ? t.isHorizontal()
                        ? A.outerWidth(!0)
                        : A.outerHeight(!0)
                      : t.isHorizontal()
                      ? A[0].getBoundingClientRect().width +
                        parseFloat(L.getPropertyValue("margin-left")) +
                        parseFloat(L.getPropertyValue("margin-right"))
                      : A[0].getBoundingClientRect().height +
                        parseFloat(L.getPropertyValue("margin-top")) +
                        parseFloat(L.getPropertyValue("margin-bottom"))),
                    I && (A[0].style.transform = I),
                    E && (A[0].style.webkitTransform = E),
                    e.roundLengths && (k = Math.floor(k));
                } else
                  (k = (a - (e.slidesPerView - 1) * b) / e.slidesPerView),
                    e.roundLengths && (k = Math.floor(k)),
                    l[S] &&
                      (t.isHorizontal()
                        ? (l[S].style.width = k + "px")
                        : (l[S].style.height = k + "px"));
                l[S] && (l[S].swiperSlideSize = k),
                  p.push(k),
                  e.centeredSlides
                    ? ((v = v + k / 2 + f / 2 + b),
                      0 === f && 0 !== S && (v = v - a / 2 - b),
                      0 === S && (v = v - a / 2 - b),
                      Math.abs(v) < 0.001 && (v = 0),
                      e.roundLengths && (v = Math.floor(v)),
                      y % e.slidesPerGroup == 0 && d.push(v),
                      c.push(v))
                    : (e.roundLengths && (v = Math.floor(v)),
                      y % e.slidesPerGroup == 0 && d.push(v),
                      c.push(v),
                      (v = v + k + b)),
                  (t.virtualSize += k + b),
                  (f = k),
                  (y += 1);
              }
            }
            if (
              ((t.virtualSize = Math.max(t.virtualSize, a) + x),
              s &&
                n &&
                ("slide" === e.effect || "coverflow" === e.effect) &&
                i.css({ width: t.virtualSize + e.spaceBetween + "px" }),
              (N.flexbox && !e.setWrapperSize) ||
                (t.isHorizontal()
                  ? i.css({ width: t.virtualSize + e.spaceBetween + "px" })
                  : i.css({ height: t.virtualSize + e.spaceBetween + "px" })),
              1 < e.slidesPerColumn &&
                ((t.virtualSize = (k + e.spaceBetween) * M),
                (t.virtualSize =
                  Math.ceil(t.virtualSize / e.slidesPerColumn) -
                  e.spaceBetween),
                t.isHorizontal()
                  ? i.css({ width: t.virtualSize + e.spaceBetween + "px" })
                  : i.css({ height: t.virtualSize + e.spaceBetween + "px" }),
                e.centeredSlides))
            ) {
              w = [];
              for (var D = 0; D < d.length; D += 1) {
                var V = d[D];
                e.roundLengths && (V = Math.floor(V)),
                  d[D] < t.virtualSize + d[0] && w.push(V);
              }
              d = w;
            }
            if (!e.centeredSlides) {
              w = [];
              for (var z = 0; z < d.length; z += 1) {
                var W = d[z];
                e.roundLengths && (W = Math.floor(W)),
                  d[z] <= t.virtualSize - a && w.push(W);
              }
              (d = w),
                1 <
                  Math.floor(t.virtualSize - a) - Math.floor(d[d.length - 1]) &&
                  d.push(t.virtualSize - a);
            }
            if (
              (0 === d.length && (d = [0]),
              0 !== e.spaceBetween &&
                (t.isHorizontal()
                  ? s
                    ? l.css({ marginLeft: b + "px" })
                    : l.css({ marginRight: b + "px" })
                  : l.css({ marginBottom: b + "px" })),
              e.centerInsufficientSlides)
            ) {
              var X = 0;
              if (
                (p.forEach(function (t) {
                  X += t + (e.spaceBetween ? e.spaceBetween : 0);
                }),
                (X -= e.spaceBetween) < a)
              ) {
                var Y = (a - X) / 2;
                d.forEach(function (t, e) {
                  d[e] = t - Y;
                }),
                  c.forEach(function (t, e) {
                    c[e] = t + Y;
                  });
              }
            }
            R.extend(t, {
              slides: l,
              snapGrid: d,
              slidesGrid: c,
              slidesSizesGrid: p,
            }),
              h !== r && t.emit("slidesLengthChange"),
              d.length !== m &&
                (t.params.watchOverflow && t.checkOverflow(),
                t.emit("snapGridLengthChange")),
              c.length !== g && t.emit("slidesGridLengthChange"),
              (e.watchSlidesProgress || e.watchSlidesVisibility) &&
                t.updateSlidesOffset();
          }
        },
        updateAutoHeight: function (t) {
          var e,
            i = this,
            a = [],
            s = 0;
          if (
            ("number" == typeof t
              ? i.setTransition(t)
              : !0 === t && i.setTransition(i.params.speed),
            "auto" !== i.params.slidesPerView && 1 < i.params.slidesPerView)
          )
            for (e = 0; e < Math.ceil(i.params.slidesPerView); e += 1) {
              var n = i.activeIndex + e;
              if (n > i.slides.length) break;
              a.push(i.slides.eq(n)[0]);
            }
          else a.push(i.slides.eq(i.activeIndex)[0]);
          for (e = 0; e < a.length; e += 1)
            if (void 0 !== a[e]) {
              var o = a[e].offsetHeight;
              s = s < o ? o : s;
            }
          s && i.$wrapperEl.css("height", s + "px");
        },
        updateSlidesOffset: function () {
          for (var t = this.slides, e = 0; e < t.length; e += 1)
            t[e].swiperSlideOffset = this.isHorizontal()
              ? t[e].offsetLeft
              : t[e].offsetTop;
        },
        updateSlidesProgress: function (t) {
          void 0 === t && (t = (this && this.translate) || 0);
          var e = this,
            i = e.params,
            a = e.slides,
            s = e.rtlTranslate;
          if (0 !== a.length) {
            void 0 === a[0].swiperSlideOffset && e.updateSlidesOffset();
            var n = -t;
            s && (n = t),
              a.removeClass(i.slideVisibleClass),
              (e.visibleSlidesIndexes = []),
              (e.visibleSlides = []);
            for (var o = 0; o < a.length; o += 1) {
              var r = a[o],
                l =
                  (n +
                    (i.centeredSlides ? e.minTranslate() : 0) -
                    r.swiperSlideOffset) /
                  (r.swiperSlideSize + i.spaceBetween);
              if (i.watchSlidesVisibility) {
                var h = -(n - r.swiperSlideOffset),
                  d = h + e.slidesSizesGrid[o];
                ((0 <= h && h < e.size) ||
                  (0 < d && d <= e.size) ||
                  (h <= 0 && d >= e.size)) &&
                  (e.visibleSlides.push(r),
                  e.visibleSlidesIndexes.push(o),
                  a.eq(o).addClass(i.slideVisibleClass));
              }
              r.progress = s ? -l : l;
            }
            e.visibleSlides = F(e.visibleSlides);
          }
        },
        updateProgress: function (t) {
          void 0 === t && (t = (this && this.translate) || 0);
          var e = this,
            i = e.params,
            a = e.maxTranslate() - e.minTranslate(),
            s = e.progress,
            n = e.isBeginning,
            o = e.isEnd,
            r = n,
            l = o;
          (o =
            0 === a
              ? (n = !(s = 0))
              : ((n = (s = (t - e.minTranslate()) / a) <= 0), 1 <= s)),
            R.extend(e, { progress: s, isBeginning: n, isEnd: o }),
            (i.watchSlidesProgress || i.watchSlidesVisibility) &&
              e.updateSlidesProgress(t),
            n && !r && e.emit("reachBeginning toEdge"),
            o && !l && e.emit("reachEnd toEdge"),
            ((r && !n) || (l && !o)) && e.emit("fromEdge"),
            e.emit("progress", s);
        },
        updateSlidesClasses: function () {
          var t,
            e = this,
            i = e.slides,
            a = e.params,
            s = e.$wrapperEl,
            n = e.activeIndex,
            o = e.realIndex,
            r = e.virtual && a.virtual.enabled;
          i.removeClass(
            a.slideActiveClass +
              " " +
              a.slideNextClass +
              " " +
              a.slidePrevClass +
              " " +
              a.slideDuplicateActiveClass +
              " " +
              a.slideDuplicateNextClass +
              " " +
              a.slideDuplicatePrevClass
          ),
            (t = r
              ? e.$wrapperEl.find(
                  "." + a.slideClass + '[data-swiper-slide-index="' + n + '"]'
                )
              : i.eq(n)).addClass(a.slideActiveClass),
            a.loop &&
              (t.hasClass(a.slideDuplicateClass)
                ? s
                    .children(
                      "." +
                        a.slideClass +
                        ":not(." +
                        a.slideDuplicateClass +
                        ')[data-swiper-slide-index="' +
                        o +
                        '"]'
                    )
                    .addClass(a.slideDuplicateActiveClass)
                : s
                    .children(
                      "." +
                        a.slideClass +
                        "." +
                        a.slideDuplicateClass +
                        '[data-swiper-slide-index="' +
                        o +
                        '"]'
                    )
                    .addClass(a.slideDuplicateActiveClass));
          var l = t
            .nextAll("." + a.slideClass)
            .eq(0)
            .addClass(a.slideNextClass);
          a.loop && 0 === l.length && (l = i.eq(0)).addClass(a.slideNextClass);
          var h = t
            .prevAll("." + a.slideClass)
            .eq(0)
            .addClass(a.slidePrevClass);
          a.loop && 0 === h.length && (h = i.eq(-1)).addClass(a.slidePrevClass),
            a.loop &&
              (l.hasClass(a.slideDuplicateClass)
                ? s
                    .children(
                      "." +
                        a.slideClass +
                        ":not(." +
                        a.slideDuplicateClass +
                        ')[data-swiper-slide-index="' +
                        l.attr("data-swiper-slide-index") +
                        '"]'
                    )
                    .addClass(a.slideDuplicateNextClass)
                : s
                    .children(
                      "." +
                        a.slideClass +
                        "." +
                        a.slideDuplicateClass +
                        '[data-swiper-slide-index="' +
                        l.attr("data-swiper-slide-index") +
                        '"]'
                    )
                    .addClass(a.slideDuplicateNextClass),
              h.hasClass(a.slideDuplicateClass)
                ? s
                    .children(
                      "." +
                        a.slideClass +
                        ":not(." +
                        a.slideDuplicateClass +
                        ')[data-swiper-slide-index="' +
                        h.attr("data-swiper-slide-index") +
                        '"]'
                    )
                    .addClass(a.slideDuplicatePrevClass)
                : s
                    .children(
                      "." +
                        a.slideClass +
                        "." +
                        a.slideDuplicateClass +
                        '[data-swiper-slide-index="' +
                        h.attr("data-swiper-slide-index") +
                        '"]'
                    )
                    .addClass(a.slideDuplicatePrevClass));
        },
        updateActiveIndex: function (t) {
          var e,
            i = this,
            a = i.rtlTranslate ? i.translate : -i.translate,
            s = i.slidesGrid,
            n = i.snapGrid,
            o = i.params,
            r = i.activeIndex,
            l = i.realIndex,
            h = i.snapIndex,
            d = t;
          if (void 0 === d) {
            for (var c = 0; c < s.length; c += 1)
              void 0 !== s[c + 1]
                ? a >= s[c] && a < s[c + 1] - (s[c + 1] - s[c]) / 2
                  ? (d = c)
                  : a >= s[c] && a < s[c + 1] && (d = c + 1)
                : a >= s[c] && (d = c);
            o.normalizeSlideIndex && (d < 0 || void 0 === d) && (d = 0);
          }
          if (
            ((e =
              0 <= n.indexOf(a)
                ? n.indexOf(a)
                : Math.floor(d / o.slidesPerGroup)) >= n.length &&
              (e = n.length - 1),
            d !== r)
          ) {
            var p = parseInt(
              i.slides.eq(d).attr("data-swiper-slide-index") || d,
              10
            );
            R.extend(i, {
              snapIndex: e,
              realIndex: p,
              previousIndex: r,
              activeIndex: d,
            }),
              i.emit("activeIndexChange"),
              i.emit("snapIndexChange"),
              l !== p && i.emit("realIndexChange"),
              i.emit("slideChange");
          } else e !== h && ((i.snapIndex = e), i.emit("snapIndexChange"));
        },
        updateClickedSlide: function (t) {
          var e = this,
            i = e.params,
            a = F(t.target).closest("." + i.slideClass)[0],
            s = !1;
          if (a)
            for (var n = 0; n < e.slides.length; n += 1)
              e.slides[n] === a && (s = !0);
          if (!a || !s)
            return (e.clickedSlide = void 0), void (e.clickedIndex = void 0);
          (e.clickedSlide = a),
            e.virtual && e.params.virtual.enabled
              ? (e.clickedIndex = parseInt(
                  F(a).attr("data-swiper-slide-index"),
                  10
                ))
              : (e.clickedIndex = F(a).index()),
            i.slideToClickedSlide &&
              void 0 !== e.clickedIndex &&
              e.clickedIndex !== e.activeIndex &&
              e.slideToClickedSlide();
        },
      },
      h = {
        getTranslate: function (t) {
          void 0 === t && (t = this.isHorizontal() ? "x" : "y");
          var e = this.params,
            i = this.rtlTranslate,
            a = this.translate,
            s = this.$wrapperEl;
          if (e.virtualTranslate) return i ? -a : a;
          var n = R.getTranslate(s[0], t);
          return i && (n = -n), n || 0;
        },
        setTranslate: function (t, e) {
          var i = this,
            a = i.rtlTranslate,
            s = i.params,
            n = i.$wrapperEl,
            o = i.progress,
            r = 0,
            l = 0;
          i.isHorizontal() ? (r = a ? -t : t) : (l = t),
            s.roundLengths && ((r = Math.floor(r)), (l = Math.floor(l))),
            s.virtualTranslate ||
              (N.transforms3d
                ? n.transform("translate3d(" + r + "px, " + l + "px, 0px)")
                : n.transform("translate(" + r + "px, " + l + "px)")),
            (i.previousTranslate = i.translate),
            (i.translate = i.isHorizontal() ? r : l);
          var h = i.maxTranslate() - i.minTranslate();
          (0 === h ? 0 : (t - i.minTranslate()) / h) !== o &&
            i.updateProgress(t),
            i.emit("setTranslate", i.translate, e);
        },
        minTranslate: function () {
          return -this.snapGrid[0];
        },
        maxTranslate: function () {
          return -this.snapGrid[this.snapGrid.length - 1];
        },
      },
      d = {
        slideTo: function (t, e, i, a) {
          void 0 === t && (t = 0),
            void 0 === e && (e = this.params.speed),
            void 0 === i && (i = !0);
          var s = this,
            n = t;
          n < 0 && (n = 0);
          var o = s.params,
            r = s.snapGrid,
            l = s.slidesGrid,
            h = s.previousIndex,
            d = s.activeIndex,
            c = s.rtlTranslate;
          if (s.animating && o.preventInteractionOnTransition) return !1;
          var p = Math.floor(n / o.slidesPerGroup);
          p >= r.length && (p = r.length - 1),
            (d || o.initialSlide || 0) === (h || 0) &&
              i &&
              s.emit("beforeSlideChangeStart");
          var u,
            x = -r[p];
          if ((s.updateProgress(x), o.normalizeSlideIndex))
            for (var m = 0; m < l.length; m += 1)
              -Math.floor(100 * x) >= Math.floor(100 * l[m]) && (n = m);
          if (s.initialized && n !== d) {
            if (!s.allowSlideNext && x < s.translate && x < s.minTranslate())
              return !1;
            if (
              !s.allowSlidePrev &&
              x > s.translate &&
              x > s.maxTranslate() &&
              (d || 0) !== n
            )
              return !1;
          }
          return (
            (u = d < n ? "next" : n < d ? "prev" : "reset"),
            (c && -x === s.translate) || (!c && x === s.translate)
              ? (s.updateActiveIndex(n),
                o.autoHeight && s.updateAutoHeight(),
                s.updateSlidesClasses(),
                "slide" !== o.effect && s.setTranslate(x),
                "reset" !== u &&
                  (s.transitionStart(i, u), s.transitionEnd(i, u)),
                !1)
              : (0 !== e && N.transition
                  ? (s.setTransition(e),
                    s.setTranslate(x),
                    s.updateActiveIndex(n),
                    s.updateSlidesClasses(),
                    s.emit("beforeTransitionStart", e, a),
                    s.transitionStart(i, u),
                    s.animating ||
                      ((s.animating = !0),
                      s.onSlideToWrapperTransitionEnd ||
                        (s.onSlideToWrapperTransitionEnd = function (t) {
                          s &&
                            !s.destroyed &&
                            t.target === this &&
                            (s.$wrapperEl[0].removeEventListener(
                              "transitionend",
                              s.onSlideToWrapperTransitionEnd
                            ),
                            s.$wrapperEl[0].removeEventListener(
                              "webkitTransitionEnd",
                              s.onSlideToWrapperTransitionEnd
                            ),
                            (s.onSlideToWrapperTransitionEnd = null),
                            delete s.onSlideToWrapperTransitionEnd,
                            s.transitionEnd(i, u));
                        }),
                      s.$wrapperEl[0].addEventListener(
                        "transitionend",
                        s.onSlideToWrapperTransitionEnd
                      ),
                      s.$wrapperEl[0].addEventListener(
                        "webkitTransitionEnd",
                        s.onSlideToWrapperTransitionEnd
                      )))
                  : (s.setTransition(0),
                    s.setTranslate(x),
                    s.updateActiveIndex(n),
                    s.updateSlidesClasses(),
                    s.emit("beforeTransitionStart", e, a),
                    s.transitionStart(i, u),
                    s.transitionEnd(i, u)),
                !0)
          );
        },
        slideToLoop: function (t, e, i, a) {
          void 0 === t && (t = 0),
            void 0 === e && (e = this.params.speed),
            void 0 === i && (i = !0);
          var s = t;
          return (
            this.params.loop && (s += this.loopedSlides),
            this.slideTo(s, e, i, a)
          );
        },
        slideNext: function (t, e, i) {
          void 0 === t && (t = this.params.speed), void 0 === e && (e = !0);
          var a = this,
            s = a.params,
            n = a.animating;
          return s.loop
            ? !n &&
                (a.loopFix(),
                (a._clientLeft = a.$wrapperEl[0].clientLeft),
                a.slideTo(a.activeIndex + s.slidesPerGroup, t, e, i))
            : a.slideTo(a.activeIndex + s.slidesPerGroup, t, e, i);
        },
        slidePrev: function (t, e, i) {
          void 0 === t && (t = this.params.speed), void 0 === e && (e = !0);
          var a = this,
            s = a.params,
            n = a.animating,
            o = a.snapGrid,
            r = a.slidesGrid,
            l = a.rtlTranslate;
          if (s.loop) {
            if (n) return !1;
            a.loopFix(), (a._clientLeft = a.$wrapperEl[0].clientLeft);
          }
          function h(t) {
            return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t);
          }
          var d,
            c = h(l ? a.translate : -a.translate),
            p = o.map(function (t) {
              return h(t);
            }),
            u =
              (r.map(function (t) {
                return h(t);
              }),
              o[p.indexOf(c)],
              o[p.indexOf(c) - 1]);
          return (
            void 0 !== u && (d = r.indexOf(u)) < 0 && (d = a.activeIndex - 1),
            a.slideTo(d, t, e, i)
          );
        },
        slideReset: function (t, e, i) {
          return (
            void 0 === t && (t = this.params.speed),
            void 0 === e && (e = !0),
            this.slideTo(this.activeIndex, t, e, i)
          );
        },
        slideToClosest: function (t, e, i) {
          void 0 === t && (t = this.params.speed), void 0 === e && (e = !0);
          var a = this,
            s = a.activeIndex,
            n = Math.floor(s / a.params.slidesPerGroup);
          if (n < a.snapGrid.length - 1) {
            var o = a.rtlTranslate ? a.translate : -a.translate,
              r = a.snapGrid[n];
            (a.snapGrid[n + 1] - r) / 2 < o - r &&
              (s = a.params.slidesPerGroup);
          }
          return a.slideTo(s, t, e, i);
        },
        slideToClickedSlide: function () {
          var t,
            e = this,
            i = e.params,
            a = e.$wrapperEl,
            s =
              "auto" === i.slidesPerView
                ? e.slidesPerViewDynamic()
                : i.slidesPerView,
            n = e.clickedIndex;
          if (i.loop) {
            if (e.animating) return;
            (t = parseInt(
              F(e.clickedSlide).attr("data-swiper-slide-index"),
              10
            )),
              i.centeredSlides
                ? n < e.loopedSlides - s / 2 ||
                  n > e.slides.length - e.loopedSlides + s / 2
                  ? (e.loopFix(),
                    (n = a
                      .children(
                        "." +
                          i.slideClass +
                          '[data-swiper-slide-index="' +
                          t +
                          '"]:not(.' +
                          i.slideDuplicateClass +
                          ")"
                      )
                      .eq(0)
                      .index()),
                    R.nextTick(function () {
                      e.slideTo(n);
                    }))
                  : e.slideTo(n)
                : n > e.slides.length - s
                ? (e.loopFix(),
                  (n = a
                    .children(
                      "." +
                        i.slideClass +
                        '[data-swiper-slide-index="' +
                        t +
                        '"]:not(.' +
                        i.slideDuplicateClass +
                        ")"
                    )
                    .eq(0)
                    .index()),
                  R.nextTick(function () {
                    e.slideTo(n);
                  }))
                : e.slideTo(n);
          } else e.slideTo(n);
        },
      },
      c = {
        loopCreate: function () {
          var a = this,
            t = a.params,
            e = a.$wrapperEl;
          e.children("." + t.slideClass + "." + t.slideDuplicateClass).remove();
          var s = e.children("." + t.slideClass);
          if (t.loopFillGroupWithBlank) {
            var i = t.slidesPerGroup - (s.length % t.slidesPerGroup);
            if (i !== t.slidesPerGroup) {
              for (var n = 0; n < i; n += 1) {
                var o = F(m.createElement("div")).addClass(
                  t.slideClass + " " + t.slideBlankClass
                );
                e.append(o);
              }
              s = e.children("." + t.slideClass);
            }
          }
          "auto" !== t.slidesPerView ||
            t.loopedSlides ||
            (t.loopedSlides = s.length),
            (a.loopedSlides = parseInt(t.loopedSlides || t.slidesPerView, 10)),
            (a.loopedSlides += t.loopAdditionalSlides),
            a.loopedSlides > s.length && (a.loopedSlides = s.length);
          var r = [],
            l = [];
          s.each(function (t, e) {
            var i = F(e);
            t < a.loopedSlides && l.push(e),
              t < s.length && t >= s.length - a.loopedSlides && r.push(e),
              i.attr("data-swiper-slide-index", t);
          });
          for (var h = 0; h < l.length; h += 1)
            e.append(F(l[h].cloneNode(!0)).addClass(t.slideDuplicateClass));
          for (var d = r.length - 1; 0 <= d; d -= 1)
            e.prepend(F(r[d].cloneNode(!0)).addClass(t.slideDuplicateClass));
        },
        loopFix: function () {
          var t,
            e = this,
            i = e.params,
            a = e.activeIndex,
            s = e.slides,
            n = e.loopedSlides,
            o = e.allowSlidePrev,
            r = e.allowSlideNext,
            l = e.snapGrid,
            h = e.rtlTranslate;
          (e.allowSlidePrev = !0), (e.allowSlideNext = !0);
          var d = -l[a] - e.getTranslate();
          a < n
            ? ((t = s.length - 3 * n + a),
              (t += n),
              e.slideTo(t, 0, !1, !0) &&
                0 !== d &&
                e.setTranslate((h ? -e.translate : e.translate) - d))
            : (("auto" === i.slidesPerView && 2 * n <= a) ||
                a >= s.length - n) &&
              ((t = -s.length + a + n),
              (t += n),
              e.slideTo(t, 0, !1, !0) &&
                0 !== d &&
                e.setTranslate((h ? -e.translate : e.translate) - d)),
            (e.allowSlidePrev = o),
            (e.allowSlideNext = r);
        },
        loopDestroy: function () {
          var t = this.$wrapperEl,
            e = this.params,
            i = this.slides;
          t.children("." + e.slideClass + "." + e.slideDuplicateClass).remove(),
            i.removeAttr("data-swiper-slide-index");
        },
      },
      p = {
        setGrabCursor: function (t) {
          if (
            !(
              N.touch ||
              !this.params.simulateTouch ||
              (this.params.watchOverflow && this.isLocked)
            )
          ) {
            var e = this.el;
            (e.style.cursor = "move"),
              (e.style.cursor = t ? "-webkit-grabbing" : "-webkit-grab"),
              (e.style.cursor = t ? "-moz-grabbin" : "-moz-grab"),
              (e.style.cursor = t ? "grabbing" : "grab");
          }
        },
        unsetGrabCursor: function () {
          N.touch ||
            (this.params.watchOverflow && this.isLocked) ||
            (this.el.style.cursor = "");
        },
      },
      u = {
        appendSlide: function (t) {
          var e = this,
            i = e.$wrapperEl,
            a = e.params;
          if (
            (a.loop && e.loopDestroy(), "object" == typeof t && "length" in t)
          )
            for (var s = 0; s < t.length; s += 1) t[s] && i.append(t[s]);
          else i.append(t);
          a.loop && e.loopCreate(), (a.observer && N.observer) || e.update();
        },
        prependSlide: function (t) {
          var e = this,
            i = e.params,
            a = e.$wrapperEl,
            s = e.activeIndex;
          i.loop && e.loopDestroy();
          var n = s + 1;
          if ("object" == typeof t && "length" in t) {
            for (var o = 0; o < t.length; o += 1) t[o] && a.prepend(t[o]);
            n = s + t.length;
          } else a.prepend(t);
          i.loop && e.loopCreate(),
            (i.observer && N.observer) || e.update(),
            e.slideTo(n, 0, !1);
        },
        addSlide: function (t, e) {
          var i = this,
            a = i.$wrapperEl,
            s = i.params,
            n = i.activeIndex;
          s.loop &&
            ((n -= i.loopedSlides),
            i.loopDestroy(),
            (i.slides = a.children("." + s.slideClass)));
          var o = i.slides.length;
          if (t <= 0) i.prependSlide(e);
          else if (o <= t) i.appendSlide(e);
          else {
            for (var r = t < n ? n + 1 : n, l = [], h = o - 1; t <= h; h -= 1) {
              var d = i.slides.eq(h);
              d.remove(), l.unshift(d);
            }
            if ("object" == typeof e && "length" in e) {
              for (var c = 0; c < e.length; c += 1) e[c] && a.append(e[c]);
              r = t < n ? n + e.length : n;
            } else a.append(e);
            for (var p = 0; p < l.length; p += 1) a.append(l[p]);
            s.loop && i.loopCreate(),
              (s.observer && N.observer) || i.update(),
              s.loop
                ? i.slideTo(r + i.loopedSlides, 0, !1)
                : i.slideTo(r, 0, !1);
          }
        },
        removeSlide: function (t) {
          var e = this,
            i = e.params,
            a = e.$wrapperEl,
            s = e.activeIndex;
          i.loop &&
            ((s -= e.loopedSlides),
            e.loopDestroy(),
            (e.slides = a.children("." + i.slideClass)));
          var n,
            o = s;
          if ("object" == typeof t && "length" in t) {
            for (var r = 0; r < t.length; r += 1)
              (n = t[r]),
                e.slides[n] && e.slides.eq(n).remove(),
                n < o && (o -= 1);
            o = Math.max(o, 0);
          } else
            (n = t),
              e.slides[n] && e.slides.eq(n).remove(),
              n < o && (o -= 1),
              (o = Math.max(o, 0));
          i.loop && e.loopCreate(),
            (i.observer && N.observer) || e.update(),
            i.loop ? e.slideTo(o + e.loopedSlides, 0, !1) : e.slideTo(o, 0, !1);
        },
        removeAllSlides: function () {
          for (var t = [], e = 0; e < this.slides.length; e += 1) t.push(e);
          this.removeSlide(t);
        },
      },
      x = (function () {
        var t = O.navigator.userAgent,
          e = {
            ios: !1,
            android: !1,
            androidChrome: !1,
            desktop: !1,
            windows: !1,
            iphone: !1,
            ipod: !1,
            ipad: !1,
            cordova: O.cordova || O.phonegap,
            phonegap: O.cordova || O.phonegap,
          },
          i = t.match(/(Windows Phone);?[\s\/]+([\d.]+)?/),
          a = t.match(/(Android);?[\s\/]+([\d.]+)?/),
          s = t.match(/(iPad).*OS\s([\d_]+)/),
          n = t.match(/(iPod)(.*OS\s([\d_]+))?/),
          o = !s && t.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        if (
          (i && ((e.os = "windows"), (e.osVersion = i[2]), (e.windows = !0)),
          a &&
            !i &&
            ((e.os = "android"),
            (e.osVersion = a[2]),
            (e.android = !0),
            (e.androidChrome = 0 <= t.toLowerCase().indexOf("chrome"))),
          (s || o || n) && ((e.os = "ios"), (e.ios = !0)),
          o && !n && ((e.osVersion = o[2].replace(/_/g, ".")), (e.iphone = !0)),
          s && ((e.osVersion = s[2].replace(/_/g, ".")), (e.ipad = !0)),
          n &&
            ((e.osVersion = n[3] ? n[3].replace(/_/g, ".") : null),
            (e.iphone = !0)),
          e.ios &&
            e.osVersion &&
            0 <= t.indexOf("Version/") &&
            "10" === e.osVersion.split(".")[0] &&
            (e.osVersion = t.toLowerCase().split("version/")[1].split(" ")[0]),
          (e.desktop = !(e.os || e.android || e.webView)),
          (e.webView = (o || s || n) && t.match(/.*AppleWebKit(?!.*Safari)/i)),
          e.os && "ios" === e.os)
        ) {
          var r = e.osVersion.split("."),
            l = m.querySelector('meta[name="viewport"]');
          e.minimalUi =
            !e.webView &&
            (n || o) &&
            (1 * r[0] == 7 ? 1 <= 1 * r[1] : 7 < 1 * r[0]) &&
            l &&
            0 <= l.getAttribute("content").indexOf("minimal-ui");
        }
        return (e.pixelRatio = O.devicePixelRatio || 1), e;
      })();
    function g() {
      var t = this,
        e = t.params,
        i = t.el;
      if (!i || 0 !== i.offsetWidth) {
        e.breakpoints && t.setBreakpoint();
        var a = t.allowSlideNext,
          s = t.allowSlidePrev,
          n = t.snapGrid;
        if (
          ((t.allowSlideNext = !0),
          (t.allowSlidePrev = !0),
          t.updateSize(),
          t.updateSlides(),
          e.freeMode)
        ) {
          var o = Math.min(
            Math.max(t.translate, t.maxTranslate()),
            t.minTranslate()
          );
          t.setTranslate(o),
            t.updateActiveIndex(),
            t.updateSlidesClasses(),
            e.autoHeight && t.updateAutoHeight();
        } else
          t.updateSlidesClasses(),
            ("auto" === e.slidesPerView || 1 < e.slidesPerView) &&
            t.isEnd &&
            !t.params.centeredSlides
              ? t.slideTo(t.slides.length - 1, 0, !1, !0)
              : t.slideTo(t.activeIndex, 0, !1, !0);
        (t.allowSlidePrev = s),
          (t.allowSlideNext = a),
          t.params.watchOverflow && n !== t.snapGrid && t.checkOverflow();
      }
    }
    var b,
      v = {
        attachEvents: function () {
          var t = this,
            e = t.params,
            i = t.touchEvents,
            a = t.el,
            s = t.wrapperEl;
          (t.onTouchStart = function (t) {
            var e = this,
              i = e.touchEventsData,
              a = e.params,
              s = e.touches;
            if (!e.animating || !a.preventInteractionOnTransition) {
              var n = t;
              if (
                (n.originalEvent && (n = n.originalEvent),
                (i.isTouchEvent = "touchstart" === n.type),
                (i.isTouchEvent || !("which" in n) || 3 !== n.which) &&
                  !(
                    (!i.isTouchEvent && "button" in n && 0 < n.button) ||
                    (i.isTouched && i.isMoved)
                  ))
              )
                if (
                  a.noSwiping &&
                  F(n.target).closest(
                    a.noSwipingSelector
                      ? a.noSwipingSelector
                      : "." + a.noSwipingClass
                  )[0]
                )
                  e.allowClick = !0;
                else if (!a.swipeHandler || F(n).closest(a.swipeHandler)[0]) {
                  (s.currentX =
                    "touchstart" === n.type
                      ? n.targetTouches[0].pageX
                      : n.pageX),
                    (s.currentY =
                      "touchstart" === n.type
                        ? n.targetTouches[0].pageY
                        : n.pageY);
                  var o = s.currentX,
                    r = s.currentY,
                    l = a.edgeSwipeDetection || a.iOSEdgeSwipeDetection,
                    h = a.edgeSwipeThreshold || a.iOSEdgeSwipeThreshold;
                  if (!l || !(o <= h || o >= O.screen.width - h)) {
                    if (
                      (R.extend(i, {
                        isTouched: !0,
                        isMoved: !1,
                        allowTouchCallbacks: !0,
                        isScrolling: void 0,
                        startMoving: void 0,
                      }),
                      (s.startX = o),
                      (s.startY = r),
                      (i.touchStartTime = R.now()),
                      (e.allowClick = !0),
                      e.updateSize(),
                      (e.swipeDirection = void 0),
                      0 < a.threshold && (i.allowThresholdMove = !1),
                      "touchstart" !== n.type)
                    ) {
                      var d = !0;
                      F(n.target).is(i.formElements) && (d = !1),
                        m.activeElement &&
                          F(m.activeElement).is(i.formElements) &&
                          m.activeElement !== n.target &&
                          m.activeElement.blur(),
                        d &&
                          e.allowTouchMove &&
                          a.touchStartPreventDefault &&
                          n.preventDefault();
                    }
                    e.emit("touchStart", n);
                  }
                }
            }
          }.bind(t)),
            (t.onTouchMove = function (t) {
              var e = this,
                i = e.touchEventsData,
                a = e.params,
                s = e.touches,
                n = e.rtlTranslate,
                o = t;
              if ((o.originalEvent && (o = o.originalEvent), i.isTouched)) {
                if (!i.isTouchEvent || "mousemove" !== o.type) {
                  var r =
                      "touchmove" === o.type
                        ? o.targetTouches[0].pageX
                        : o.pageX,
                    l =
                      "touchmove" === o.type
                        ? o.targetTouches[0].pageY
                        : o.pageY;
                  if (o.preventedByNestedSwiper)
                    return (s.startX = r), void (s.startY = l);
                  if (!e.allowTouchMove)
                    return (
                      (e.allowClick = !1),
                      void (
                        i.isTouched &&
                        (R.extend(s, {
                          startX: r,
                          startY: l,
                          currentX: r,
                          currentY: l,
                        }),
                        (i.touchStartTime = R.now()))
                      )
                    );
                  if (i.isTouchEvent && a.touchReleaseOnEdges && !a.loop)
                    if (e.isVertical()) {
                      if (
                        (l < s.startY && e.translate <= e.maxTranslate()) ||
                        (l > s.startY && e.translate >= e.minTranslate())
                      )
                        return (i.isTouched = !1), void (i.isMoved = !1);
                    } else if (
                      (r < s.startX && e.translate <= e.maxTranslate()) ||
                      (r > s.startX && e.translate >= e.minTranslate())
                    )
                      return;
                  if (
                    i.isTouchEvent &&
                    m.activeElement &&
                    o.target === m.activeElement &&
                    F(o.target).is(i.formElements)
                  )
                    return (i.isMoved = !0), void (e.allowClick = !1);
                  if (
                    (i.allowTouchCallbacks && e.emit("touchMove", o),
                    !(o.targetTouches && 1 < o.targetTouches.length))
                  ) {
                    (s.currentX = r), (s.currentY = l);
                    var h,
                      d = s.currentX - s.startX,
                      c = s.currentY - s.startY;
                    if (
                      !(
                        e.params.threshold &&
                        Math.sqrt(Math.pow(d, 2) + Math.pow(c, 2)) <
                          e.params.threshold
                      )
                    )
                      if (
                        (void 0 === i.isScrolling &&
                          ((e.isHorizontal() && s.currentY === s.startY) ||
                          (e.isVertical() && s.currentX === s.startX)
                            ? (i.isScrolling = !1)
                            : 25 <= d * d + c * c &&
                              ((h =
                                (180 * Math.atan2(Math.abs(c), Math.abs(d))) /
                                Math.PI),
                              (i.isScrolling = e.isHorizontal()
                                ? h > a.touchAngle
                                : 90 - h > a.touchAngle))),
                        i.isScrolling && e.emit("touchMoveOpposite", o),
                        void 0 === i.startMoving &&
                          ((s.currentX === s.startX &&
                            s.currentY === s.startY) ||
                            (i.startMoving = !0)),
                        i.isScrolling)
                      )
                        i.isTouched = !1;
                      else if (i.startMoving) {
                        (e.allowClick = !1),
                          o.preventDefault(),
                          a.touchMoveStopPropagation &&
                            !a.nested &&
                            o.stopPropagation(),
                          i.isMoved ||
                            (a.loop && e.loopFix(),
                            (i.startTranslate = e.getTranslate()),
                            e.setTransition(0),
                            e.animating &&
                              e.$wrapperEl.trigger(
                                "webkitTransitionEnd transitionend"
                              ),
                            (i.allowMomentumBounce = !1),
                            !a.grabCursor ||
                              (!0 !== e.allowSlideNext &&
                                !0 !== e.allowSlidePrev) ||
                              e.setGrabCursor(!0),
                            e.emit("sliderFirstMove", o)),
                          e.emit("sliderMove", o),
                          (i.isMoved = !0);
                        var p = e.isHorizontal() ? d : c;
                        (s.diff = p),
                          (p *= a.touchRatio),
                          n && (p = -p),
                          (e.swipeDirection = 0 < p ? "prev" : "next"),
                          (i.currentTranslate = p + i.startTranslate);
                        var u = !0,
                          x = a.resistanceRatio;
                        if (
                          (a.touchReleaseOnEdges && (x = 0),
                          0 < p && i.currentTranslate > e.minTranslate()
                            ? ((u = !1),
                              a.resistance &&
                                (i.currentTranslate =
                                  e.minTranslate() -
                                  1 +
                                  Math.pow(
                                    -e.minTranslate() + i.startTranslate + p,
                                    x
                                  )))
                            : p < 0 &&
                              i.currentTranslate < e.maxTranslate() &&
                              ((u = !1),
                              a.resistance &&
                                (i.currentTranslate =
                                  e.maxTranslate() +
                                  1 -
                                  Math.pow(
                                    e.maxTranslate() - i.startTranslate - p,
                                    x
                                  ))),
                          u && (o.preventedByNestedSwiper = !0),
                          !e.allowSlideNext &&
                            "next" === e.swipeDirection &&
                            i.currentTranslate < i.startTranslate &&
                            (i.currentTranslate = i.startTranslate),
                          !e.allowSlidePrev &&
                            "prev" === e.swipeDirection &&
                            i.currentTranslate > i.startTranslate &&
                            (i.currentTranslate = i.startTranslate),
                          0 < a.threshold)
                        ) {
                          if (
                            !(Math.abs(p) > a.threshold || i.allowThresholdMove)
                          )
                            return void (i.currentTranslate = i.startTranslate);
                          if (!i.allowThresholdMove)
                            return (
                              (i.allowThresholdMove = !0),
                              (s.startX = s.currentX),
                              (s.startY = s.currentY),
                              (i.currentTranslate = i.startTranslate),
                              void (s.diff = e.isHorizontal()
                                ? s.currentX - s.startX
                                : s.currentY - s.startY)
                            );
                        }
                        a.followFinger &&
                          ((a.freeMode ||
                            a.watchSlidesProgress ||
                            a.watchSlidesVisibility) &&
                            (e.updateActiveIndex(), e.updateSlidesClasses()),
                          a.freeMode &&
                            (0 === i.velocities.length &&
                              i.velocities.push({
                                position:
                                  s[e.isHorizontal() ? "startX" : "startY"],
                                time: i.touchStartTime,
                              }),
                            i.velocities.push({
                              position:
                                s[e.isHorizontal() ? "currentX" : "currentY"],
                              time: R.now(),
                            })),
                          e.updateProgress(i.currentTranslate),
                          e.setTranslate(i.currentTranslate));
                      }
                  }
                }
              } else
                i.startMoving &&
                  i.isScrolling &&
                  e.emit("touchMoveOpposite", o);
            }.bind(t)),
            (t.onTouchEnd = function (t) {
              var e = this,
                i = e.touchEventsData,
                a = e.params,
                s = e.touches,
                n = e.rtlTranslate,
                o = e.$wrapperEl,
                r = e.slidesGrid,
                l = e.snapGrid,
                h = t;
              if (
                (h.originalEvent && (h = h.originalEvent),
                i.allowTouchCallbacks && e.emit("touchEnd", h),
                (i.allowTouchCallbacks = !1),
                !i.isTouched)
              )
                return (
                  i.isMoved && a.grabCursor && e.setGrabCursor(!1),
                  (i.isMoved = !1),
                  void (i.startMoving = !1)
                );
              a.grabCursor &&
                i.isMoved &&
                i.isTouched &&
                (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) &&
                e.setGrabCursor(!1);
              var d,
                c = R.now(),
                p = c - i.touchStartTime;
              if (
                (e.allowClick &&
                  (e.updateClickedSlide(h),
                  e.emit("tap", h),
                  p < 300 &&
                    300 < c - i.lastClickTime &&
                    (i.clickTimeout && clearTimeout(i.clickTimeout),
                    (i.clickTimeout = R.nextTick(function () {
                      e && !e.destroyed && e.emit("click", h);
                    }, 300))),
                  p < 300 &&
                    c - i.lastClickTime < 300 &&
                    (i.clickTimeout && clearTimeout(i.clickTimeout),
                    e.emit("doubleTap", h))),
                (i.lastClickTime = R.now()),
                R.nextTick(function () {
                  e.destroyed || (e.allowClick = !0);
                }),
                !i.isTouched ||
                  !i.isMoved ||
                  !e.swipeDirection ||
                  0 === s.diff ||
                  i.currentTranslate === i.startTranslate)
              )
                return (
                  (i.isTouched = !1),
                  (i.isMoved = !1),
                  void (i.startMoving = !1)
                );
              if (
                ((i.isTouched = !1),
                (i.isMoved = !1),
                (i.startMoving = !1),
                (d = a.followFinger
                  ? n
                    ? e.translate
                    : -e.translate
                  : -i.currentTranslate),
                a.freeMode)
              ) {
                if (d < -e.minTranslate()) return void e.slideTo(e.activeIndex);
                if (d > -e.maxTranslate())
                  return void (e.slides.length < l.length
                    ? e.slideTo(l.length - 1)
                    : e.slideTo(e.slides.length - 1));
                if (a.freeModeMomentum) {
                  if (1 < i.velocities.length) {
                    var u = i.velocities.pop(),
                      x = i.velocities.pop(),
                      m = u.position - x.position,
                      g = u.time - x.time;
                    (e.velocity = m / g),
                      (e.velocity /= 2),
                      Math.abs(e.velocity) < a.freeModeMinimumVelocity &&
                        (e.velocity = 0),
                      (150 < g || 300 < R.now() - u.time) && (e.velocity = 0);
                  } else e.velocity = 0;
                  (e.velocity *= a.freeModeMomentumVelocityRatio),
                    (i.velocities.length = 0);
                  var b = 1e3 * a.freeModeMomentumRatio,
                    v = e.velocity * b,
                    f = e.translate + v;
                  n && (f = -f);
                  var y,
                    M,
                    k = !1,
                    w =
                      20 * Math.abs(e.velocity) * a.freeModeMomentumBounceRatio;
                  if (f < e.maxTranslate())
                    a.freeModeMomentumBounce
                      ? (f + e.maxTranslate() < -w &&
                          (f = e.maxTranslate() - w),
                        (y = e.maxTranslate()),
                        (k = !0),
                        (i.allowMomentumBounce = !0))
                      : (f = e.maxTranslate()),
                      a.loop && a.centeredSlides && (M = !0);
                  else if (f > e.minTranslate())
                    a.freeModeMomentumBounce
                      ? (f - e.minTranslate() > w && (f = e.minTranslate() + w),
                        (y = e.minTranslate()),
                        (k = !0),
                        (i.allowMomentumBounce = !0))
                      : (f = e.minTranslate()),
                      a.loop && a.centeredSlides && (M = !0);
                  else if (a.freeModeSticky) {
                    for (var T, C = 0; C < l.length; C += 1)
                      if (l[C] > -f) {
                        T = C;
                        break;
                      }
                    f = -(f =
                      Math.abs(l[T] - f) < Math.abs(l[T - 1] - f) ||
                      "next" === e.swipeDirection
                        ? l[T]
                        : l[T - 1]);
                  }
                  if (
                    (M &&
                      e.once("transitionEnd", function () {
                        e.loopFix();
                      }),
                    0 !== e.velocity)
                  )
                    b = n
                      ? Math.abs((-f - e.translate) / e.velocity)
                      : Math.abs((f - e.translate) / e.velocity);
                  else if (a.freeModeSticky) return void e.slideToClosest();
                  a.freeModeMomentumBounce && k
                    ? (e.updateProgress(y),
                      e.setTransition(b),
                      e.setTranslate(f),
                      e.transitionStart(!0, e.swipeDirection),
                      (e.animating = !0),
                      o.transitionEnd(function () {
                        e &&
                          !e.destroyed &&
                          i.allowMomentumBounce &&
                          (e.emit("momentumBounce"),
                          e.setTransition(a.speed),
                          e.setTranslate(y),
                          o.transitionEnd(function () {
                            e && !e.destroyed && e.transitionEnd();
                          }));
                      }))
                    : e.velocity
                    ? (e.updateProgress(f),
                      e.setTransition(b),
                      e.setTranslate(f),
                      e.transitionStart(!0, e.swipeDirection),
                      e.animating ||
                        ((e.animating = !0),
                        o.transitionEnd(function () {
                          e && !e.destroyed && e.transitionEnd();
                        })))
                    : e.updateProgress(f),
                    e.updateActiveIndex(),
                    e.updateSlidesClasses();
                } else if (a.freeModeSticky) return void e.slideToClosest();
                (!a.freeModeMomentum || p >= a.longSwipesMs) &&
                  (e.updateProgress(),
                  e.updateActiveIndex(),
                  e.updateSlidesClasses());
              } else {
                for (
                  var P = 0, S = e.slidesSizesGrid[0], A = 0;
                  A < r.length;
                  A += a.slidesPerGroup
                )
                  void 0 !== r[A + a.slidesPerGroup]
                    ? d >= r[A] &&
                      d < r[A + a.slidesPerGroup] &&
                      (S = r[(P = A) + a.slidesPerGroup] - r[A])
                    : d >= r[A] &&
                      ((P = A), (S = r[r.length - 1] - r[r.length - 2]));
                var _ = (d - r[P]) / S;
                if (p > a.longSwipesMs) {
                  if (!a.longSwipes) return void e.slideTo(e.activeIndex);
                  "next" === e.swipeDirection &&
                    (_ >= a.longSwipesRatio
                      ? e.slideTo(P + a.slidesPerGroup)
                      : e.slideTo(P)),
                    "prev" === e.swipeDirection &&
                      (_ > 1 - a.longSwipesRatio
                        ? e.slideTo(P + a.slidesPerGroup)
                        : e.slideTo(P));
                } else {
                  if (!a.shortSwipes) return void e.slideTo(e.activeIndex);
                  "next" === e.swipeDirection &&
                    e.slideTo(P + a.slidesPerGroup),
                    "prev" === e.swipeDirection && e.slideTo(P);
                }
              }
            }.bind(t)),
            (t.onClick = function (t) {
              this.allowClick ||
                (this.params.preventClicks && t.preventDefault(),
                this.params.preventClicksPropagation &&
                  this.animating &&
                  (t.stopPropagation(), t.stopImmediatePropagation()));
            }.bind(t));
          var n = "container" === e.touchEventsTarget ? a : s,
            o = !!e.nested;
          if (N.touch || (!N.pointerEvents && !N.prefixedPointerEvents)) {
            if (N.touch) {
              var r = !(
                "touchstart" !== i.start ||
                !N.passiveListener ||
                !e.passiveListeners
              ) && { passive: !0, capture: !1 };
              n.addEventListener(i.start, t.onTouchStart, r),
                n.addEventListener(
                  i.move,
                  t.onTouchMove,
                  N.passiveListener ? { passive: !1, capture: o } : o
                ),
                n.addEventListener(i.end, t.onTouchEnd, r);
            }
            ((e.simulateTouch && !x.ios && !x.android) ||
              (e.simulateTouch && !N.touch && x.ios)) &&
              (n.addEventListener("mousedown", t.onTouchStart, !1),
              m.addEventListener("mousemove", t.onTouchMove, o),
              m.addEventListener("mouseup", t.onTouchEnd, !1));
          } else
            n.addEventListener(i.start, t.onTouchStart, !1),
              m.addEventListener(i.move, t.onTouchMove, o),
              m.addEventListener(i.end, t.onTouchEnd, !1);
          (e.preventClicks || e.preventClicksPropagation) &&
            n.addEventListener("click", t.onClick, !0),
            t.on(
              x.ios || x.android
                ? "resize orientationchange observerUpdate"
                : "resize observerUpdate",
              g,
              !0
            );
        },
        detachEvents: function () {
          var t = this,
            e = t.params,
            i = t.touchEvents,
            a = t.el,
            s = t.wrapperEl,
            n = "container" === e.touchEventsTarget ? a : s,
            o = !!e.nested;
          if (N.touch || (!N.pointerEvents && !N.prefixedPointerEvents)) {
            if (N.touch) {
              var r = !(
                "onTouchStart" !== i.start ||
                !N.passiveListener ||
                !e.passiveListeners
              ) && { passive: !0, capture: !1 };
              n.removeEventListener(i.start, t.onTouchStart, r),
                n.removeEventListener(i.move, t.onTouchMove, o),
                n.removeEventListener(i.end, t.onTouchEnd, r);
            }
            ((e.simulateTouch && !x.ios && !x.android) ||
              (e.simulateTouch && !N.touch && x.ios)) &&
              (n.removeEventListener("mousedown", t.onTouchStart, !1),
              m.removeEventListener("mousemove", t.onTouchMove, o),
              m.removeEventListener("mouseup", t.onTouchEnd, !1));
          } else
            n.removeEventListener(i.start, t.onTouchStart, !1),
              m.removeEventListener(i.move, t.onTouchMove, o),
              m.removeEventListener(i.end, t.onTouchEnd, !1);
          (e.preventClicks || e.preventClicksPropagation) &&
            n.removeEventListener("click", t.onClick, !0),
            t.off(
              x.ios || x.android
                ? "resize orientationchange observerUpdate"
                : "resize observerUpdate",
              g
            );
        },
      },
      f = {
        setBreakpoint: function () {
          var t = this,
            e = t.activeIndex,
            i = t.initialized,
            a = t.loopedSlides;
          void 0 === a && (a = 0);
          var s = t.params,
            n = s.breakpoints;
          if (n && (!n || 0 !== Object.keys(n).length)) {
            var o = t.getBreakpoint(n);
            if (o && t.currentBreakpoint !== o) {
              var r = o in n ? n[o] : t.originalParams,
                l = s.loop && r.slidesPerView !== s.slidesPerView;
              R.extend(t.params, r),
                R.extend(t, {
                  allowTouchMove: t.params.allowTouchMove,
                  allowSlideNext: t.params.allowSlideNext,
                  allowSlidePrev: t.params.allowSlidePrev,
                }),
                (t.currentBreakpoint = o),
                l &&
                  i &&
                  (t.loopDestroy(),
                  t.loopCreate(),
                  t.updateSlides(),
                  t.slideTo(e - a + t.loopedSlides, 0, !1)),
                t.emit("breakpoint", r);
            }
          }
        },
        getBreakpoint: function (t) {
          if (t) {
            var e = !1,
              i = [];
            Object.keys(t).forEach(function (t) {
              i.push(t);
            }),
              i.sort(function (t, e) {
                return parseInt(t, 10) - parseInt(e, 10);
              });
            for (var a = 0; a < i.length; a += 1) {
              var s = i[a];
              this.params.breakpointsInverse
                ? s <= O.innerWidth && (e = s)
                : s >= O.innerWidth && !e && (e = s);
            }
            return e || "max";
          }
        },
      },
      L = {
        isIE:
          !!O.navigator.userAgent.match(/Trident/g) ||
          !!O.navigator.userAgent.match(/MSIE/g),
        isEdge: !!O.navigator.userAgent.match(/Edge/g),
        isSafari:
          ((b = O.navigator.userAgent.toLowerCase()),
          0 <= b.indexOf("safari") &&
            b.indexOf("chrome") < 0 &&
            b.indexOf("android") < 0),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
          O.navigator.userAgent
        ),
      },
      y = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "container",
        initialSlide: 0,
        speed: 300,
        preventInteractionOnTransition: !1,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        freeMode: !1,
        freeModeMomentum: !0,
        freeModeMomentumRatio: 1,
        freeModeMomentumBounce: !0,
        freeModeMomentumBounceRatio: 1,
        freeModeMomentumVelocityRatio: 1,
        freeModeSticky: !1,
        freeModeMinimumVelocity: 0.02,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsInverse: !1,
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerColumnFill: "column",
        slidesPerGroup: 1,
        centeredSlides: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !1,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !0,
        touchStartPreventDefault: !0,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: 0.85,
        watchSlidesProgress: !1,
        watchSlidesVisibility: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        containerModifierClass: "swiper-container-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
      },
      M = {
        update: r,
        translate: h,
        transition: {
          setTransition: function (t, e) {
            this.$wrapperEl.transition(t), this.emit("setTransition", t, e);
          },
          transitionStart: function (t, e) {
            void 0 === t && (t = !0);
            var i = this,
              a = i.activeIndex,
              s = i.params,
              n = i.previousIndex;
            s.autoHeight && i.updateAutoHeight();
            var o = e;
            if (
              (o || (o = n < a ? "next" : a < n ? "prev" : "reset"),
              i.emit("transitionStart"),
              t && a !== n)
            ) {
              if ("reset" === o)
                return void i.emit("slideResetTransitionStart");
              i.emit("slideChangeTransitionStart"),
                "next" === o
                  ? i.emit("slideNextTransitionStart")
                  : i.emit("slidePrevTransitionStart");
            }
          },
          transitionEnd: function (t, e) {
            void 0 === t && (t = !0);
            var i = this,
              a = i.activeIndex,
              s = i.previousIndex;
            (i.animating = !1), i.setTransition(0);
            var n = e;
            if (
              (n || (n = s < a ? "next" : a < s ? "prev" : "reset"),
              i.emit("transitionEnd"),
              t && a !== s)
            ) {
              if ("reset" === n) return void i.emit("slideResetTransitionEnd");
              i.emit("slideChangeTransitionEnd"),
                "next" === n
                  ? i.emit("slideNextTransitionEnd")
                  : i.emit("slidePrevTransitionEnd");
            }
          },
        },
        slide: d,
        loop: c,
        grabCursor: p,
        manipulation: u,
        events: v,
        breakpoints: f,
        checkOverflow: {
          checkOverflow: function () {
            var t = this,
              e = t.isLocked;
            (t.isLocked = 1 === t.snapGrid.length),
              (t.allowSlideNext = !t.isLocked),
              (t.allowSlidePrev = !t.isLocked),
              e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock"),
              e && e !== t.isLocked && ((t.isEnd = !1), t.navigation.update());
          },
        },
        classes: {
          addClasses: function () {
            var e = this.classNames,
              i = this.params,
              t = this.rtl,
              a = this.$el,
              s = [];
            s.push(i.direction),
              i.freeMode && s.push("free-mode"),
              N.flexbox || s.push("no-flexbox"),
              i.autoHeight && s.push("autoheight"),
              t && s.push("rtl"),
              1 < i.slidesPerColumn && s.push("multirow"),
              x.android && s.push("android"),
              x.ios && s.push("ios"),
              (L.isIE || L.isEdge) &&
                (N.pointerEvents || N.prefixedPointerEvents) &&
                s.push("wp8-" + i.direction),
              s.forEach(function (t) {
                e.push(i.containerModifierClass + t);
              }),
              a.addClass(e.join(" "));
          },
          removeClasses: function () {
            var t = this.$el,
              e = this.classNames;
            t.removeClass(e.join(" "));
          },
        },
        images: {
          loadImage: function (t, e, i, a, s, n) {
            var o;
            function r() {
              n && n();
            }
            t.complete && s
              ? r()
              : e
              ? (((o = new O.Image()).onload = r),
                (o.onerror = r),
                a && (o.sizes = a),
                i && (o.srcset = i),
                e && (o.src = e))
              : r();
          },
          preloadImages: function () {
            var t = this;
            function e() {
              null != t &&
                t &&
                !t.destroyed &&
                (void 0 !== t.imagesLoaded && (t.imagesLoaded += 1),
                t.imagesLoaded === t.imagesToLoad.length &&
                  (t.params.updateOnImagesReady && t.update(),
                  t.emit("imagesReady")));
            }
            t.imagesToLoad = t.$el.find("img");
            for (var i = 0; i < t.imagesToLoad.length; i += 1) {
              var a = t.imagesToLoad[i];
              t.loadImage(
                a,
                a.currentSrc || a.getAttribute("src"),
                a.srcset || a.getAttribute("srcset"),
                a.sizes || a.getAttribute("sizes"),
                !0,
                e
              );
            }
          },
        },
      },
      k = {},
      w = (function (p) {
        function u() {
          for (var t, e, s, i = [], a = arguments.length; a--; )
            i[a] = arguments[a];
          (s =
            1 === i.length && i[0].constructor && i[0].constructor === Object
              ? i[0]
              : ((e = (t = i)[0]), t[1])) || (s = {}),
            (s = R.extend({}, s)),
            e && !s.el && (s.el = e),
            p.call(this, s),
            Object.keys(M).forEach(function (e) {
              Object.keys(M[e]).forEach(function (t) {
                u.prototype[t] || (u.prototype[t] = M[e][t]);
              });
            });
          var n = this;
          void 0 === n.modules && (n.modules = {}),
            Object.keys(n.modules).forEach(function (t) {
              var e = n.modules[t];
              if (e.params) {
                var i = Object.keys(e.params)[0],
                  a = e.params[i];
                if ("object" != typeof a || null === a) return;
                if (!(i in s && "enabled" in a)) return;
                !0 === s[i] && (s[i] = { enabled: !0 }),
                  "object" != typeof s[i] ||
                    "enabled" in s[i] ||
                    (s[i].enabled = !0),
                  s[i] || (s[i] = { enabled: !1 });
              }
            });
          var o = R.extend({}, y);
          n.useModulesParams(o),
            (n.params = R.extend({}, o, k, s)),
            (n.originalParams = R.extend({}, n.params)),
            (n.passedParams = R.extend({}, s));
          var r = (n.$ = F)(n.params.el);
          if ((e = r[0])) {
            if (1 < r.length) {
              var l = [];
              return (
                r.each(function (t, e) {
                  var i = R.extend({}, s, { el: e });
                  l.push(new u(i));
                }),
                l
              );
            }
            (e.swiper = n), r.data("swiper", n);
            var h,
              d,
              c = r.children("." + n.params.wrapperClass);
            return (
              R.extend(n, {
                $el: r,
                el: e,
                $wrapperEl: c,
                wrapperEl: c[0],
                classNames: [],
                slides: F(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: function () {
                  return "horizontal" === n.params.direction;
                },
                isVertical: function () {
                  return "vertical" === n.params.direction;
                },
                rtl:
                  "rtl" === e.dir.toLowerCase() || "rtl" === r.css("direction"),
                rtlTranslate:
                  "horizontal" === n.params.direction &&
                  ("rtl" === e.dir.toLowerCase() ||
                    "rtl" === r.css("direction")),
                wrongRTL: "-webkit-box" === c.css("display"),
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                allowSlideNext: n.params.allowSlideNext,
                allowSlidePrev: n.params.allowSlidePrev,
                touchEvents:
                  ((h = ["touchstart", "touchmove", "touchend"]),
                  (d = ["mousedown", "mousemove", "mouseup"]),
                  N.pointerEvents
                    ? (d = ["pointerdown", "pointermove", "pointerup"])
                    : N.prefixedPointerEvents &&
                      (d = ["MSPointerDown", "MSPointerMove", "MSPointerUp"]),
                  (n.touchEventsTouch = { start: h[0], move: h[1], end: h[2] }),
                  (n.touchEventsDesktop = {
                    start: d[0],
                    move: d[1],
                    end: d[2],
                  }),
                  N.touch || !n.params.simulateTouch
                    ? n.touchEventsTouch
                    : n.touchEventsDesktop),
                touchEventsData: {
                  isTouched: void 0,
                  isMoved: void 0,
                  allowTouchCallbacks: void 0,
                  touchStartTime: void 0,
                  isScrolling: void 0,
                  currentTranslate: void 0,
                  startTranslate: void 0,
                  allowThresholdMove: void 0,
                  formElements:
                    "input, select, option, textarea, button, video",
                  lastClickTime: R.now(),
                  clickTimeout: void 0,
                  velocities: [],
                  allowMomentumBounce: void 0,
                  isTouchEvent: void 0,
                  startMoving: void 0,
                },
                allowClick: !0,
                allowTouchMove: n.params.allowTouchMove,
                touches: {
                  startX: 0,
                  startY: 0,
                  currentX: 0,
                  currentY: 0,
                  diff: 0,
                },
                imagesToLoad: [],
                imagesLoaded: 0,
              }),
              n.useModules(),
              n.params.init && n.init(),
              n
            );
          }
        }
        p && (u.__proto__ = p);
        var t = {
          extendedDefaults: { configurable: !0 },
          defaults: { configurable: !0 },
          Class: { configurable: !0 },
          $: { configurable: !0 },
        };
        return (
          (((u.prototype = Object.create(p && p.prototype)).constructor =
            u).prototype.slidesPerViewDynamic = function () {
            var t = this,
              e = t.params,
              i = t.slides,
              a = t.slidesGrid,
              s = t.size,
              n = t.activeIndex,
              o = 1;
            if (e.centeredSlides) {
              for (
                var r, l = i[n].swiperSlideSize, h = n + 1;
                h < i.length;
                h += 1
              )
                i[h] &&
                  !r &&
                  ((o += 1), s < (l += i[h].swiperSlideSize) && (r = !0));
              for (var d = n - 1; 0 <= d; d -= 1)
                i[d] &&
                  !r &&
                  ((o += 1), s < (l += i[d].swiperSlideSize) && (r = !0));
            } else
              for (var c = n + 1; c < i.length; c += 1)
                a[c] - a[n] < s && (o += 1);
            return o;
          }),
          (u.prototype.update = function () {
            var i = this;
            if (i && !i.destroyed) {
              var t = i.snapGrid,
                e = i.params;
              e.breakpoints && i.setBreakpoint(),
                i.updateSize(),
                i.updateSlides(),
                i.updateProgress(),
                i.updateSlidesClasses(),
                i.params.freeMode
                  ? (a(), i.params.autoHeight && i.updateAutoHeight())
                  : (("auto" === i.params.slidesPerView ||
                      1 < i.params.slidesPerView) &&
                    i.isEnd &&
                    !i.params.centeredSlides
                      ? i.slideTo(i.slides.length - 1, 0, !1, !0)
                      : i.slideTo(i.activeIndex, 0, !1, !0)) || a(),
                e.watchOverflow && t !== i.snapGrid && i.checkOverflow(),
                i.emit("update");
            }
            function a() {
              var t = i.rtlTranslate ? -1 * i.translate : i.translate,
                e = Math.min(Math.max(t, i.maxTranslate()), i.minTranslate());
              i.setTranslate(e), i.updateActiveIndex(), i.updateSlidesClasses();
            }
          }),
          (u.prototype.init = function () {
            var t = this;
            t.initialized ||
              (t.emit("beforeInit"),
              t.params.breakpoints && t.setBreakpoint(),
              t.addClasses(),
              t.params.loop && t.loopCreate(),
              t.updateSize(),
              t.updateSlides(),
              t.params.watchOverflow && t.checkOverflow(),
              t.params.grabCursor && t.setGrabCursor(),
              t.params.preloadImages && t.preloadImages(),
              t.params.loop
                ? t.slideTo(
                    t.params.initialSlide + t.loopedSlides,
                    0,
                    t.params.runCallbacksOnInit
                  )
                : t.slideTo(
                    t.params.initialSlide,
                    0,
                    t.params.runCallbacksOnInit
                  ),
              t.attachEvents(),
              (t.initialized = !0),
              t.emit("init"));
          }),
          (u.prototype.destroy = function (t, e) {
            void 0 === t && (t = !0), void 0 === e && (e = !0);
            var i = this,
              a = i.params,
              s = i.$el,
              n = i.$wrapperEl,
              o = i.slides;
            return (
              void 0 === i.params ||
                i.destroyed ||
                (i.emit("beforeDestroy"),
                (i.initialized = !1),
                i.detachEvents(),
                a.loop && i.loopDestroy(),
                e &&
                  (i.removeClasses(),
                  s.removeAttr("style"),
                  n.removeAttr("style"),
                  o &&
                    o.length &&
                    o
                      .removeClass(
                        [
                          a.slideVisibleClass,
                          a.slideActiveClass,
                          a.slideNextClass,
                          a.slidePrevClass,
                        ].join(" ")
                      )
                      .removeAttr("style")
                      .removeAttr("data-swiper-slide-index")
                      .removeAttr("data-swiper-column")
                      .removeAttr("data-swiper-row")),
                i.emit("destroy"),
                Object.keys(i.eventsListeners).forEach(function (t) {
                  i.off(t);
                }),
                !1 !== t &&
                  ((i.$el[0].swiper = null),
                  i.$el.data("swiper", null),
                  R.deleteProps(i)),
                (i.destroyed = !0)),
              null
            );
          }),
          (u.extendDefaults = function (t) {
            R.extend(k, t);
          }),
          (t.extendedDefaults.get = function () {
            return k;
          }),
          (t.defaults.get = function () {
            return y;
          }),
          (t.Class.get = function () {
            return p;
          }),
          (t.$.get = function () {
            return F;
          }),
          Object.defineProperties(u, t),
          u
        );
      })(s),
      T = { name: "device", proto: { device: x }, static: { device: x } },
      C = { name: "support", proto: { support: N }, static: { support: N } },
      P = { name: "browser", proto: { browser: L }, static: { browser: L } },
      S = {
        name: "resize",
        create: function () {
          var t = this;
          R.extend(t, {
            resize: {
              resizeHandler: function () {
                t &&
                  !t.destroyed &&
                  t.initialized &&
                  (t.emit("beforeResize"), t.emit("resize"));
              },
              orientationChangeHandler: function () {
                t &&
                  !t.destroyed &&
                  t.initialized &&
                  t.emit("orientationchange");
              },
            },
          });
        },
        on: {
          init: function () {
            O.addEventListener("resize", this.resize.resizeHandler),
              O.addEventListener(
                "orientationchange",
                this.resize.orientationChangeHandler
              );
          },
          destroy: function () {
            O.removeEventListener("resize", this.resize.resizeHandler),
              O.removeEventListener(
                "orientationchange",
                this.resize.orientationChangeHandler
              );
          },
        },
      },
      A = {
        func: O.MutationObserver || O.WebkitMutationObserver,
        attach: function (t, e) {
          void 0 === e && (e = {});
          var i = this,
            a = new A.func(function (t) {
              if (1 !== t.length) {
                var e = function () {
                  i.emit("observerUpdate", t[0]);
                };
                O.requestAnimationFrame
                  ? O.requestAnimationFrame(e)
                  : O.setTimeout(e, 0);
              } else i.emit("observerUpdate", t[0]);
            });
          a.observe(t, {
            attributes: void 0 === e.attributes || e.attributes,
            childList: void 0 === e.childList || e.childList,
            characterData: void 0 === e.characterData || e.characterData,
          }),
            i.observer.observers.push(a);
        },
        init: function () {
          var t = this;
          if (N.observer && t.params.observer) {
            if (t.params.observeParents)
              for (var e = t.$el.parents(), i = 0; i < e.length; i += 1)
                t.observer.attach(e[i]);
            t.observer.attach(t.$el[0], { childList: !1 }),
              t.observer.attach(t.$wrapperEl[0], { attributes: !1 });
          }
        },
        destroy: function () {
          this.observer.observers.forEach(function (t) {
            t.disconnect();
          }),
            (this.observer.observers = []);
        },
      },
      _ = {
        name: "observer",
        params: { observer: !1, observeParents: !1 },
        create: function () {
          R.extend(this, {
            observer: {
              init: A.init.bind(this),
              attach: A.attach.bind(this),
              destroy: A.destroy.bind(this),
              observers: [],
            },
          });
        },
        on: {
          init: function () {
            this.observer.init();
          },
          destroy: function () {
            this.observer.destroy();
          },
        },
      },
      B = {
        update: function (t) {
          var e = this,
            i = e.params,
            a = i.slidesPerView,
            s = i.slidesPerGroup,
            n = i.centeredSlides,
            o = e.params.virtual,
            r = o.addSlidesBefore,
            l = o.addSlidesAfter,
            h = e.virtual,
            d = h.from,
            c = h.to,
            p = h.slides,
            u = h.slidesGrid,
            x = h.renderSlide,
            m = h.offset;
          e.updateActiveIndex();
          var g,
            b,
            v,
            f = e.activeIndex || 0;
          (g = e.rtlTranslate ? "right" : e.isHorizontal() ? "left" : "top"),
            (v = n
              ? ((b = Math.floor(a / 2) + s + r), Math.floor(a / 2) + s + l)
              : ((b = a + (s - 1) + r), s + l));
          var y = Math.max((f || 0) - v, 0),
            M = Math.min((f || 0) + b, p.length - 1),
            k = (e.slidesGrid[y] || 0) - (e.slidesGrid[0] || 0);
          function w() {
            e.updateSlides(),
              e.updateProgress(),
              e.updateSlidesClasses(),
              e.lazy && e.params.lazy.enabled && e.lazy.load();
          }
          if (
            (R.extend(e.virtual, {
              from: y,
              to: M,
              offset: k,
              slidesGrid: e.slidesGrid,
            }),
            d === y && c === M && !t)
          )
            return (
              e.slidesGrid !== u && k !== m && e.slides.css(g, k + "px"),
              void e.updateProgress()
            );
          if (e.params.virtual.renderExternal)
            return (
              e.params.virtual.renderExternal.call(e, {
                offset: k,
                from: y,
                to: M,
                slides: (function () {
                  for (var t = [], e = y; e <= M; e += 1) t.push(p[e]);
                  return t;
                })(),
              }),
              void w()
            );
          var T = [],
            C = [];
          if (t) e.$wrapperEl.find("." + e.params.slideClass).remove();
          else
            for (var P = d; P <= c; P += 1)
              (P < y || M < P) &&
                e.$wrapperEl
                  .find(
                    "." +
                      e.params.slideClass +
                      '[data-swiper-slide-index="' +
                      P +
                      '"]'
                  )
                  .remove();
          for (var S = 0; S < p.length; S += 1)
            y <= S &&
              S <= M &&
              (void 0 === c || t
                ? C.push(S)
                : (c < S && C.push(S), S < d && T.push(S)));
          C.forEach(function (t) {
            e.$wrapperEl.append(x(p[t], t));
          }),
            T.sort(function (t, e) {
              return t < e;
            }).forEach(function (t) {
              e.$wrapperEl.prepend(x(p[t], t));
            }),
            e.$wrapperEl.children(".swiper-slide").css(g, k + "px"),
            w();
        },
        renderSlide: function (t, e) {
          var i = this,
            a = i.params.virtual;
          if (a.cache && i.virtual.cache[e]) return i.virtual.cache[e];
          var s = a.renderSlide
            ? F(a.renderSlide.call(i, t, e))
            : F(
                '<div class="' +
                  i.params.slideClass +
                  '" data-swiper-slide-index="' +
                  e +
                  '">' +
                  t +
                  "</div>"
              );
          return (
            s.attr("data-swiper-slide-index") ||
              s.attr("data-swiper-slide-index", e),
            a.cache && (i.virtual.cache[e] = s),
            s
          );
        },
        appendSlide: function (t) {
          this.virtual.slides.push(t), this.virtual.update(!0);
        },
        prependSlide: function (t) {
          var e = this;
          if ((e.virtual.slides.unshift(t), e.params.virtual.cache)) {
            var i = e.virtual.cache,
              a = {};
            Object.keys(i).forEach(function (t) {
              a[t + 1] = i[t];
            }),
              (e.virtual.cache = a);
          }
          e.virtual.update(!0), e.slideNext(0);
        },
      },
      I = {
        name: "virtual",
        params: {
          virtual: {
            enabled: !1,
            slides: [],
            cache: !0,
            renderSlide: null,
            renderExternal: null,
            addSlidesBefore: 0,
            addSlidesAfter: 0,
          },
        },
        create: function () {
          var t = this;
          R.extend(t, {
            virtual: {
              update: B.update.bind(t),
              appendSlide: B.appendSlide.bind(t),
              prependSlide: B.prependSlide.bind(t),
              renderSlide: B.renderSlide.bind(t),
              slides: t.params.virtual.slides,
              cache: {},
            },
          });
        },
        on: {
          beforeInit: function () {
            var t = this;
            if (t.params.virtual.enabled) {
              t.classNames.push(t.params.containerModifierClass + "virtual");
              var e = { watchSlidesProgress: !0 };
              R.extend(t.params, e),
                R.extend(t.originalParams, e),
                t.virtual.update();
            }
          },
          setTranslate: function () {
            this.params.virtual.enabled && this.virtual.update();
          },
        },
      },
      E = {
        handle: function (t) {
          var e = this,
            i = e.rtlTranslate,
            a = t;
          a.originalEvent && (a = a.originalEvent);
          var s = a.keyCode || a.charCode;
          if (
            !e.allowSlideNext &&
            ((e.isHorizontal() && 39 === s) || (e.isVertical() && 40 === s))
          )
            return !1;
          if (
            !e.allowSlidePrev &&
            ((e.isHorizontal() && 37 === s) || (e.isVertical() && 38 === s))
          )
            return !1;
          if (
            !(
              a.shiftKey ||
              a.altKey ||
              a.ctrlKey ||
              a.metaKey ||
              (m.activeElement &&
                m.activeElement.nodeName &&
                ("input" === m.activeElement.nodeName.toLowerCase() ||
                  "textarea" === m.activeElement.nodeName.toLowerCase()))
            )
          ) {
            if (
              e.params.keyboard.onlyInViewport &&
              (37 === s || 39 === s || 38 === s || 40 === s)
            ) {
              var n = !1;
              if (
                0 < e.$el.parents("." + e.params.slideClass).length &&
                0 === e.$el.parents("." + e.params.slideActiveClass).length
              )
                return;
              var o = O.innerWidth,
                r = O.innerHeight,
                l = e.$el.offset();
              i && (l.left -= e.$el[0].scrollLeft);
              for (
                var h = [
                    [l.left, l.top],
                    [l.left + e.width, l.top],
                    [l.left, l.top + e.height],
                    [l.left + e.width, l.top + e.height],
                  ],
                  d = 0;
                d < h.length;
                d += 1
              ) {
                var c = h[d];
                0 <= c[0] && c[0] <= o && 0 <= c[1] && c[1] <= r && (n = !0);
              }
              if (!n) return;
            }
            e.isHorizontal()
              ? ((37 !== s && 39 !== s) ||
                  (a.preventDefault
                    ? a.preventDefault()
                    : (a.returnValue = !1)),
                ((39 === s && !i) || (37 === s && i)) && e.slideNext(),
                ((37 === s && !i) || (39 === s && i)) && e.slidePrev())
              : ((38 !== s && 40 !== s) ||
                  (a.preventDefault
                    ? a.preventDefault()
                    : (a.returnValue = !1)),
                40 === s && e.slideNext(),
                38 === s && e.slidePrev()),
              e.emit("keyPress", s);
          }
        },
        enable: function () {
          this.keyboard.enabled ||
            (F(m).on("keydown", this.keyboard.handle),
            (this.keyboard.enabled = !0));
        },
        disable: function () {
          this.keyboard.enabled &&
            (F(m).off("keydown", this.keyboard.handle),
            (this.keyboard.enabled = !1));
        },
      },
      D = {
        name: "keyboard",
        params: { keyboard: { enabled: !1, onlyInViewport: !0 } },
        create: function () {
          R.extend(this, {
            keyboard: {
              enabled: !1,
              enable: E.enable.bind(this),
              disable: E.disable.bind(this),
              handle: E.handle.bind(this),
            },
          });
        },
        on: {
          init: function () {
            this.params.keyboard.enabled && this.keyboard.enable();
          },
          destroy: function () {
            this.keyboard.enabled && this.keyboard.disable();
          },
        },
      },
      V = {
        lastScrollTime: R.now(),
        event:
          -1 < O.navigator.userAgent.indexOf("firefox")
            ? "DOMMouseScroll"
            : (function () {
                var t = "onwheel",
                  e = t in m;
                if (!e) {
                  var i = m.createElement("div");
                  i.setAttribute(t, "return;"), (e = "function" == typeof i[t]);
                }
                return (
                  !e &&
                    m.implementation &&
                    m.implementation.hasFeature &&
                    !0 !== m.implementation.hasFeature("", "") &&
                    (e = m.implementation.hasFeature("Events.wheel", "3.0")),
                  e
                );
              })()
            ? "wheel"
            : "mousewheel",
        normalize: function (t) {
          var e = 0,
            i = 0,
            a = 0,
            s = 0;
          return (
            "detail" in t && (i = t.detail),
            "wheelDelta" in t && (i = -t.wheelDelta / 120),
            "wheelDeltaY" in t && (i = -t.wheelDeltaY / 120),
            "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120),
            "axis" in t && t.axis === t.HORIZONTAL_AXIS && ((e = i), (i = 0)),
            (a = 10 * e),
            (s = 10 * i),
            "deltaY" in t && (s = t.deltaY),
            "deltaX" in t && (a = t.deltaX),
            (a || s) &&
              t.deltaMode &&
              (1 === t.deltaMode
                ? ((a *= 40), (s *= 40))
                : ((a *= 800), (s *= 800))),
            a && !e && (e = a < 1 ? -1 : 1),
            s && !i && (i = s < 1 ? -1 : 1),
            { spinX: e, spinY: i, pixelX: a, pixelY: s }
          );
        },
        handleMouseEnter: function () {
          this.mouseEntered = !0;
        },
        handleMouseLeave: function () {
          this.mouseEntered = !1;
        },
        handle: function (t) {
          var e = t,
            i = this,
            a = i.params.mousewheel;
          if (!i.mouseEntered && !a.releaseOnEdges) return !0;
          e.originalEvent && (e = e.originalEvent);
          var s = 0,
            n = i.rtlTranslate ? -1 : 1,
            o = V.normalize(e);
          if (a.forceToAxis)
            if (i.isHorizontal()) {
              if (!(Math.abs(o.pixelX) > Math.abs(o.pixelY))) return !0;
              s = o.pixelX * n;
            } else {
              if (!(Math.abs(o.pixelY) > Math.abs(o.pixelX))) return !0;
              s = o.pixelY;
            }
          else
            s =
              Math.abs(o.pixelX) > Math.abs(o.pixelY)
                ? -o.pixelX * n
                : -o.pixelY;
          if (0 === s) return !0;
          if ((a.invert && (s = -s), i.params.freeMode)) {
            i.params.loop && i.loopFix();
            var r = i.getTranslate() + s * a.sensitivity,
              l = i.isBeginning,
              h = i.isEnd;
            if (
              (r >= i.minTranslate() && (r = i.minTranslate()),
              r <= i.maxTranslate() && (r = i.maxTranslate()),
              i.setTransition(0),
              i.setTranslate(r),
              i.updateProgress(),
              i.updateActiveIndex(),
              i.updateSlidesClasses(),
              ((!l && i.isBeginning) || (!h && i.isEnd)) &&
                i.updateSlidesClasses(),
              i.params.freeModeSticky &&
                (clearTimeout(i.mousewheel.timeout),
                (i.mousewheel.timeout = R.nextTick(function () {
                  i.slideToClosest();
                }, 300))),
              i.emit("scroll", e),
              i.params.autoplay &&
                i.params.autoplayDisableOnInteraction &&
                i.autoplay.stop(),
              r === i.minTranslate() || r === i.maxTranslate())
            )
              return !0;
          } else {
            if (60 < R.now() - i.mousewheel.lastScrollTime)
              if (s < 0)
                if ((i.isEnd && !i.params.loop) || i.animating) {
                  if (a.releaseOnEdges) return !0;
                } else i.slideNext(), i.emit("scroll", e);
              else if ((i.isBeginning && !i.params.loop) || i.animating) {
                if (a.releaseOnEdges) return !0;
              } else i.slidePrev(), i.emit("scroll", e);
            i.mousewheel.lastScrollTime = new O.Date().getTime();
          }
          return (
            e.preventDefault ? e.preventDefault() : (e.returnValue = !1), !1
          );
        },
        enable: function () {
          var t = this;
          if (!V.event) return !1;
          if (t.mousewheel.enabled) return !1;
          var e = t.$el;
          return (
            "container" !== t.params.mousewheel.eventsTarged &&
              (e = F(t.params.mousewheel.eventsTarged)),
            e.on("mouseenter", t.mousewheel.handleMouseEnter),
            e.on("mouseleave", t.mousewheel.handleMouseLeave),
            e.on(V.event, t.mousewheel.handle),
            (t.mousewheel.enabled = !0)
          );
        },
        disable: function () {
          var t = this;
          if (!V.event) return !1;
          if (!t.mousewheel.enabled) return !1;
          var e = t.$el;
          return (
            "container" !== t.params.mousewheel.eventsTarged &&
              (e = F(t.params.mousewheel.eventsTarged)),
            e.off(V.event, t.mousewheel.handle),
            !(t.mousewheel.enabled = !1)
          );
        },
      },
      z = {
        update: function () {
          var t = this,
            e = t.params.navigation;
          if (!t.params.loop) {
            var i = t.navigation,
              a = i.$nextEl,
              s = i.$prevEl;
            s &&
              0 < s.length &&
              (t.isBeginning
                ? s.addClass(e.disabledClass)
                : s.removeClass(e.disabledClass),
              s[
                t.params.watchOverflow && t.isLocked
                  ? "addClass"
                  : "removeClass"
              ](e.lockClass)),
              a &&
                0 < a.length &&
                (t.isEnd
                  ? a.addClass(e.disabledClass)
                  : a.removeClass(e.disabledClass),
                a[
                  t.params.watchOverflow && t.isLocked
                    ? "addClass"
                    : "removeClass"
                ](e.lockClass));
          }
        },
        init: function () {
          var t,
            e,
            i = this,
            a = i.params.navigation;
          (a.nextEl || a.prevEl) &&
            (a.nextEl &&
              ((t = F(a.nextEl)),
              i.params.uniqueNavElements &&
                "string" == typeof a.nextEl &&
                1 < t.length &&
                1 === i.$el.find(a.nextEl).length &&
                (t = i.$el.find(a.nextEl))),
            a.prevEl &&
              ((e = F(a.prevEl)),
              i.params.uniqueNavElements &&
                "string" == typeof a.prevEl &&
                1 < e.length &&
                1 === i.$el.find(a.prevEl).length &&
                (e = i.$el.find(a.prevEl))),
            t &&
              0 < t.length &&
              t.on("click", function (t) {
                t.preventDefault(),
                  (i.isEnd && !i.params.loop) || i.slideNext();
              }),
            e &&
              0 < e.length &&
              e.on("click", function (t) {
                t.preventDefault(),
                  (i.isBeginning && !i.params.loop) || i.slidePrev();
              }),
            R.extend(i.navigation, {
              $nextEl: t,
              nextEl: t && t[0],
              $prevEl: e,
              prevEl: e && e[0],
            }));
        },
        destroy: function () {
          var t = this.navigation,
            e = t.$nextEl,
            i = t.$prevEl;
          e &&
            e.length &&
            (e.off("click"),
            e.removeClass(this.params.navigation.disabledClass)),
            i &&
              i.length &&
              (i.off("click"),
              i.removeClass(this.params.navigation.disabledClass));
        },
      },
      W = {
        update: function () {
          var t = this,
            e = t.rtl,
            s = t.params.pagination;
          if (
            s.el &&
            t.pagination.el &&
            t.pagination.$el &&
            0 !== t.pagination.$el.length
          ) {
            var n,
              i =
                t.virtual && t.params.virtual.enabled
                  ? t.virtual.slides.length
                  : t.slides.length,
              a = t.pagination.$el,
              o = t.params.loop
                ? Math.ceil((i - 2 * t.loopedSlides) / t.params.slidesPerGroup)
                : t.snapGrid.length;
            if (
              (t.params.loop
                ? ((n = Math.ceil(
                    (t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup
                  )) >
                    i - 1 - 2 * t.loopedSlides && (n -= i - 2 * t.loopedSlides),
                  o - 1 < n && (n -= o),
                  n < 0 && "bullets" !== t.params.paginationType && (n = o + n))
                : (n =
                    void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0),
              "bullets" === s.type &&
                t.pagination.bullets &&
                0 < t.pagination.bullets.length)
            ) {
              var r,
                l,
                h,
                d = t.pagination.bullets;
              if (
                (s.dynamicBullets &&
                  ((t.pagination.bulletSize = d
                    .eq(0)
                    [t.isHorizontal() ? "outerWidth" : "outerHeight"](!0)),
                  a.css(
                    t.isHorizontal() ? "width" : "height",
                    t.pagination.bulletSize * (s.dynamicMainBullets + 4) + "px"
                  ),
                  1 < s.dynamicMainBullets &&
                    void 0 !== t.previousIndex &&
                    ((t.pagination.dynamicBulletIndex += n - t.previousIndex),
                    t.pagination.dynamicBulletIndex > s.dynamicMainBullets - 1
                      ? (t.pagination.dynamicBulletIndex =
                          s.dynamicMainBullets - 1)
                      : t.pagination.dynamicBulletIndex < 0 &&
                        (t.pagination.dynamicBulletIndex = 0)),
                  (r = n - t.pagination.dynamicBulletIndex),
                  (h =
                    ((l = r + (Math.min(d.length, s.dynamicMainBullets) - 1)) +
                      r) /
                    2)),
                d.removeClass(
                  s.bulletActiveClass +
                    " " +
                    s.bulletActiveClass +
                    "-next " +
                    s.bulletActiveClass +
                    "-next-next " +
                    s.bulletActiveClass +
                    "-prev " +
                    s.bulletActiveClass +
                    "-prev-prev " +
                    s.bulletActiveClass +
                    "-main"
                ),
                1 < a.length)
              )
                d.each(function (t, e) {
                  var i = F(e),
                    a = i.index();
                  a === n && i.addClass(s.bulletActiveClass),
                    s.dynamicBullets &&
                      (r <= a &&
                        a <= l &&
                        i.addClass(s.bulletActiveClass + "-main"),
                      a === r &&
                        i
                          .prev()
                          .addClass(s.bulletActiveClass + "-prev")
                          .prev()
                          .addClass(s.bulletActiveClass + "-prev-prev"),
                      a === l &&
                        i
                          .next()
                          .addClass(s.bulletActiveClass + "-next")
                          .next()
                          .addClass(s.bulletActiveClass + "-next-next"));
                });
              else if (
                (d.eq(n).addClass(s.bulletActiveClass), s.dynamicBullets)
              ) {
                for (var c = d.eq(r), p = d.eq(l), u = r; u <= l; u += 1)
                  d.eq(u).addClass(s.bulletActiveClass + "-main");
                c
                  .prev()
                  .addClass(s.bulletActiveClass + "-prev")
                  .prev()
                  .addClass(s.bulletActiveClass + "-prev-prev"),
                  p
                    .next()
                    .addClass(s.bulletActiveClass + "-next")
                    .next()
                    .addClass(s.bulletActiveClass + "-next-next");
              }
              if (s.dynamicBullets) {
                var x = Math.min(d.length, s.dynamicMainBullets + 4),
                  m =
                    (t.pagination.bulletSize * x - t.pagination.bulletSize) /
                      2 -
                    h * t.pagination.bulletSize,
                  g = e ? "right" : "left";
                d.css(t.isHorizontal() ? g : "top", m + "px");
              }
            }
            if (
              ("fraction" === s.type &&
                (a
                  .find("." + s.currentClass)
                  .text(s.formatFractionCurrent(n + 1)),
                a.find("." + s.totalClass).text(s.formatFractionTotal(o))),
              "progressbar" === s.type)
            ) {
              var b;
              b = s.progressbarOpposite
                ? t.isHorizontal()
                  ? "vertical"
                  : "horizontal"
                : t.isHorizontal()
                ? "horizontal"
                : "vertical";
              var v = (n + 1) / o,
                f = 1,
                y = 1;
              "horizontal" === b ? (f = v) : (y = v),
                a
                  .find("." + s.progressbarFillClass)
                  .transform(
                    "translate3d(0,0,0) scaleX(" + f + ") scaleY(" + y + ")"
                  )
                  .transition(t.params.speed);
            }
            "custom" === s.type && s.renderCustom
              ? (a.html(s.renderCustom(t, n + 1, o)),
                t.emit("paginationRender", t, a[0]))
              : t.emit("paginationUpdate", t, a[0]),
              a[
                t.params.watchOverflow && t.isLocked
                  ? "addClass"
                  : "removeClass"
              ](s.lockClass);
          }
        },
        render: function () {
          var t = this,
            e = t.params.pagination;
          if (
            e.el &&
            t.pagination.el &&
            t.pagination.$el &&
            0 !== t.pagination.$el.length
          ) {
            var i =
                t.virtual && t.params.virtual.enabled
                  ? t.virtual.slides.length
                  : t.slides.length,
              a = t.pagination.$el,
              s = "";
            if ("bullets" === e.type) {
              for (
                var n = t.params.loop
                    ? Math.ceil(
                        (i - 2 * t.loopedSlides) / t.params.slidesPerGroup
                      )
                    : t.snapGrid.length,
                  o = 0;
                o < n;
                o += 1
              )
                e.renderBullet
                  ? (s += e.renderBullet.call(t, o, e.bulletClass))
                  : (s +=
                      "<" +
                      e.bulletElement +
                      ' class="' +
                      e.bulletClass +
                      '"></' +
                      e.bulletElement +
                      ">");
              a.html(s), (t.pagination.bullets = a.find("." + e.bulletClass));
            }
            "fraction" === e.type &&
              ((s = e.renderFraction
                ? e.renderFraction.call(t, e.currentClass, e.totalClass)
                : '<span class="' +
                  e.currentClass +
                  '"></span> / <span class="' +
                  e.totalClass +
                  '"></span>'),
              a.html(s)),
              "progressbar" === e.type &&
                ((s = e.renderProgressbar
                  ? e.renderProgressbar.call(t, e.progressbarFillClass)
                  : '<span class="' + e.progressbarFillClass + '"></span>'),
                a.html(s)),
              "custom" !== e.type &&
                t.emit("paginationRender", t.pagination.$el[0]);
          }
        },
        init: function () {
          var i = this,
            t = i.params.pagination;
          if (t.el) {
            var e = F(t.el);
            0 !== e.length &&
              (i.params.uniqueNavElements &&
                "string" == typeof t.el &&
                1 < e.length &&
                1 === i.$el.find(t.el).length &&
                (e = i.$el.find(t.el)),
              "bullets" === t.type &&
                t.clickable &&
                e.addClass(t.clickableClass),
              e.addClass(t.modifierClass + t.type),
              "bullets" === t.type &&
                t.dynamicBullets &&
                (e.addClass("" + t.modifierClass + t.type + "-dynamic"),
                (i.pagination.dynamicBulletIndex = 0),
                t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)),
              "progressbar" === t.type &&
                t.progressbarOpposite &&
                e.addClass(t.progressbarOppositeClass),
              t.clickable &&
                e.on("click", "." + t.bulletClass, function (t) {
                  t.preventDefault();
                  var e = F(this).index() * i.params.slidesPerGroup;
                  i.params.loop && (e += i.loopedSlides), i.slideTo(e);
                }),
              R.extend(i.pagination, { $el: e, el: e[0] }));
          }
        },
        destroy: function () {
          var t = this,
            e = t.params.pagination;
          if (
            e.el &&
            t.pagination.el &&
            t.pagination.$el &&
            0 !== t.pagination.$el.length
          ) {
            var i = t.pagination.$el;
            i.removeClass(e.hiddenClass),
              i.removeClass(e.modifierClass + e.type),
              t.pagination.bullets &&
                t.pagination.bullets.removeClass(e.bulletActiveClass),
              e.clickable && i.off("click", "." + e.bulletClass);
          }
        },
      },
      X = {
        setTranslate: function () {
          var t = this;
          if (t.params.scrollbar.el && t.scrollbar.el) {
            var e = t.scrollbar,
              i = t.rtlTranslate,
              a = t.progress,
              s = e.dragSize,
              n = e.trackSize,
              o = e.$dragEl,
              r = e.$el,
              l = t.params.scrollbar,
              h = s,
              d = (n - s) * a;
            i
              ? 0 < (d = -d)
                ? ((h = s - d), (d = 0))
                : n < -d + s && (h = n + d)
              : d < 0
              ? ((h = s + d), (d = 0))
              : n < d + s && (h = n - d),
              t.isHorizontal()
                ? (N.transforms3d
                    ? o.transform("translate3d(" + d + "px, 0, 0)")
                    : o.transform("translateX(" + d + "px)"),
                  (o[0].style.width = h + "px"))
                : (N.transforms3d
                    ? o.transform("translate3d(0px, " + d + "px, 0)")
                    : o.transform("translateY(" + d + "px)"),
                  (o[0].style.height = h + "px")),
              l.hide &&
                (clearTimeout(t.scrollbar.timeout),
                (r[0].style.opacity = 1),
                (t.scrollbar.timeout = setTimeout(function () {
                  (r[0].style.opacity = 0), r.transition(400);
                }, 1e3)));
          }
        },
        setTransition: function (t) {
          this.params.scrollbar.el &&
            this.scrollbar.el &&
            this.scrollbar.$dragEl.transition(t);
        },
        updateSize: function () {
          var t = this;
          if (t.params.scrollbar.el && t.scrollbar.el) {
            var e = t.scrollbar,
              i = e.$dragEl,
              a = e.$el;
            (i[0].style.width = ""), (i[0].style.height = "");
            var s,
              n = t.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight,
              o = t.size / t.virtualSize,
              r = o * (n / t.size);
            (s =
              "auto" === t.params.scrollbar.dragSize
                ? n * o
                : parseInt(t.params.scrollbar.dragSize, 10)),
              t.isHorizontal()
                ? (i[0].style.width = s + "px")
                : (i[0].style.height = s + "px"),
              (a[0].style.display = 1 <= o ? "none" : ""),
              t.params.scrollbarHide && (a[0].style.opacity = 0),
              R.extend(e, {
                trackSize: n,
                divider: o,
                moveDivider: r,
                dragSize: s,
              }),
              e.$el[
                t.params.watchOverflow && t.isLocked
                  ? "addClass"
                  : "removeClass"
              ](t.params.scrollbar.lockClass);
          }
        },
        setDragPosition: function (t) {
          var e,
            i = this,
            a = i.scrollbar,
            s = i.rtlTranslate,
            n = a.$el,
            o = a.dragSize,
            r = a.trackSize;
          (e =
            ((i.isHorizontal()
              ? "touchstart" === t.type || "touchmove" === t.type
                ? t.targetTouches[0].pageX
                : t.pageX || t.clientX
              : "touchstart" === t.type || "touchmove" === t.type
              ? t.targetTouches[0].pageY
              : t.pageY || t.clientY) -
              n.offset()[i.isHorizontal() ? "left" : "top"] -
              o / 2) /
            (r - o)),
            (e = Math.max(Math.min(e, 1), 0)),
            s && (e = 1 - e);
          var l = i.minTranslate() + (i.maxTranslate() - i.minTranslate()) * e;
          i.updateProgress(l),
            i.setTranslate(l),
            i.updateActiveIndex(),
            i.updateSlidesClasses();
        },
        onDragStart: function (t) {
          var e = this,
            i = e.params.scrollbar,
            a = e.scrollbar,
            s = e.$wrapperEl,
            n = a.$el,
            o = a.$dragEl;
          (e.scrollbar.isTouched = !0),
            t.preventDefault(),
            t.stopPropagation(),
            s.transition(100),
            o.transition(100),
            a.setDragPosition(t),
            clearTimeout(e.scrollbar.dragTimeout),
            n.transition(0),
            i.hide && n.css("opacity", 1),
            e.emit("scrollbarDragStart", t);
        },
        onDragMove: function (t) {
          var e = this.scrollbar,
            i = this.$wrapperEl,
            a = e.$el,
            s = e.$dragEl;
          this.scrollbar.isTouched &&
            (t.preventDefault ? t.preventDefault() : (t.returnValue = !1),
            e.setDragPosition(t),
            i.transition(0),
            a.transition(0),
            s.transition(0),
            this.emit("scrollbarDragMove", t));
        },
        onDragEnd: function (t) {
          var e = this,
            i = e.params.scrollbar,
            a = e.scrollbar.$el;
          e.scrollbar.isTouched &&
            ((e.scrollbar.isTouched = !1),
            i.hide &&
              (clearTimeout(e.scrollbar.dragTimeout),
              (e.scrollbar.dragTimeout = R.nextTick(function () {
                a.css("opacity", 0), a.transition(400);
              }, 1e3))),
            e.emit("scrollbarDragEnd", t),
            i.snapOnRelease && e.slideToClosest());
        },
        enableDraggable: function () {
          var t = this;
          if (t.params.scrollbar.el) {
            var e = t.scrollbar,
              i = t.touchEvents,
              a = t.touchEventsDesktop,
              s = t.params,
              n = e.$el[0],
              o = !(!N.passiveListener || !s.passiveListeners) && {
                passive: !1,
                capture: !1,
              },
              r = !(!N.passiveListener || !s.passiveListeners) && {
                passive: !0,
                capture: !1,
              };
            N.touch || (!N.pointerEvents && !N.prefixedPointerEvents)
              ? (N.touch &&
                  (n.addEventListener(i.start, t.scrollbar.onDragStart, o),
                  n.addEventListener(i.move, t.scrollbar.onDragMove, o),
                  n.addEventListener(i.end, t.scrollbar.onDragEnd, r)),
                ((s.simulateTouch && !x.ios && !x.android) ||
                  (s.simulateTouch && !N.touch && x.ios)) &&
                  (n.addEventListener("mousedown", t.scrollbar.onDragStart, o),
                  m.addEventListener("mousemove", t.scrollbar.onDragMove, o),
                  m.addEventListener("mouseup", t.scrollbar.onDragEnd, r)))
              : (n.addEventListener(a.start, t.scrollbar.onDragStart, o),
                m.addEventListener(a.move, t.scrollbar.onDragMove, o),
                m.addEventListener(a.end, t.scrollbar.onDragEnd, r));
          }
        },
        disableDraggable: function () {
          var t = this;
          if (t.params.scrollbar.el) {
            var e = t.scrollbar,
              i = t.touchEvents,
              a = t.touchEventsDesktop,
              s = t.params,
              n = e.$el[0],
              o = !(!N.passiveListener || !s.passiveListeners) && {
                passive: !1,
                capture: !1,
              },
              r = !(!N.passiveListener || !s.passiveListeners) && {
                passive: !0,
                capture: !1,
              };
            N.touch || (!N.pointerEvents && !N.prefixedPointerEvents)
              ? (N.touch &&
                  (n.removeEventListener(i.start, t.scrollbar.onDragStart, o),
                  n.removeEventListener(i.move, t.scrollbar.onDragMove, o),
                  n.removeEventListener(i.end, t.scrollbar.onDragEnd, r)),
                ((s.simulateTouch && !x.ios && !x.android) ||
                  (s.simulateTouch && !N.touch && x.ios)) &&
                  (n.removeEventListener(
                    "mousedown",
                    t.scrollbar.onDragStart,
                    o
                  ),
                  m.removeEventListener("mousemove", t.scrollbar.onDragMove, o),
                  m.removeEventListener("mouseup", t.scrollbar.onDragEnd, r)))
              : (n.removeEventListener(a.start, t.scrollbar.onDragStart, o),
                m.removeEventListener(a.move, t.scrollbar.onDragMove, o),
                m.removeEventListener(a.end, t.scrollbar.onDragEnd, r));
          }
        },
        init: function () {
          var t = this;
          if (t.params.scrollbar.el) {
            var e = t.scrollbar,
              i = t.$el,
              a = t.params.scrollbar,
              s = F(a.el);
            t.params.uniqueNavElements &&
              "string" == typeof a.el &&
              1 < s.length &&
              1 === i.find(a.el).length &&
              (s = i.find(a.el));
            var n = s.find("." + t.params.scrollbar.dragClass);
            0 === n.length &&
              ((n = F(
                '<div class="' + t.params.scrollbar.dragClass + '"></div>'
              )),
              s.append(n)),
              R.extend(e, { $el: s, el: s[0], $dragEl: n, dragEl: n[0] }),
              a.draggable && e.enableDraggable();
          }
        },
        destroy: function () {
          this.scrollbar.disableDraggable();
        },
      },
      Y = {
        setTransform: function (t, e) {
          var i = this.rtl,
            a = F(t),
            s = i ? -1 : 1,
            n = a.attr("data-swiper-parallax") || "0",
            o = a.attr("data-swiper-parallax-x"),
            r = a.attr("data-swiper-parallax-y"),
            l = a.attr("data-swiper-parallax-scale"),
            h = a.attr("data-swiper-parallax-opacity");
          if (
            (o || r
              ? ((o = o || "0"), (r = r || "0"))
              : this.isHorizontal()
              ? ((o = n), (r = "0"))
              : ((r = n), (o = "0")),
            (o =
              0 <= o.indexOf("%")
                ? parseInt(o, 10) * e * s + "%"
                : o * e * s + "px"),
            (r =
              0 <= r.indexOf("%") ? parseInt(r, 10) * e + "%" : r * e + "px"),
            null != h)
          ) {
            var d = h - (h - 1) * (1 - Math.abs(e));
            a[0].style.opacity = d;
          }
          if (null == l) a.transform("translate3d(" + o + ", " + r + ", 0px)");
          else {
            var c = l - (l - 1) * (1 - Math.abs(e));
            a.transform(
              "translate3d(" + o + ", " + r + ", 0px) scale(" + c + ")"
            );
          }
        },
        setTranslate: function () {
          var a = this,
            t = a.$el,
            e = a.slides,
            s = a.progress,
            n = a.snapGrid;
          t
            .children(
              "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]"
            )
            .each(function (t, e) {
              a.parallax.setTransform(e, s);
            }),
            e.each(function (t, e) {
              var i = e.progress;
              1 < a.params.slidesPerGroup &&
                "auto" !== a.params.slidesPerView &&
                (i += Math.ceil(t / 2) - s * (n.length - 1)),
                (i = Math.min(Math.max(i, -1), 1)),
                F(e)
                  .find(
                    "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]"
                  )
                  .each(function (t, e) {
                    a.parallax.setTransform(e, i);
                  });
            });
        },
        setTransition: function (s) {
          void 0 === s && (s = this.params.speed),
            this.$el
              .find(
                "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]"
              )
              .each(function (t, e) {
                var i = F(e),
                  a =
                    parseInt(i.attr("data-swiper-parallax-duration"), 10) || s;
                0 === s && (a = 0), i.transition(a);
              });
        },
      },
      H = {
        getDistanceBetweenTouches: function (t) {
          if (t.targetTouches.length < 2) return 1;
          var e = t.targetTouches[0].pageX,
            i = t.targetTouches[0].pageY,
            a = t.targetTouches[1].pageX,
            s = t.targetTouches[1].pageY;
          return Math.sqrt(Math.pow(a - e, 2) + Math.pow(s - i, 2));
        },
        onGestureStart: function (t) {
          var e = this,
            i = e.params.zoom,
            a = e.zoom,
            s = a.gesture;
          if (
            ((a.fakeGestureTouched = !1),
            (a.fakeGestureMoved = !1),
            !N.gestures)
          ) {
            if (
              "touchstart" !== t.type ||
              ("touchstart" === t.type && t.targetTouches.length < 2)
            )
              return;
            (a.fakeGestureTouched = !0),
              (s.scaleStart = H.getDistanceBetweenTouches(t));
          }
          (s.$slideEl && s.$slideEl.length) ||
          ((s.$slideEl = F(t.target).closest(".swiper-slide")),
          0 === s.$slideEl.length && (s.$slideEl = e.slides.eq(e.activeIndex)),
          (s.$imageEl = s.$slideEl.find("img, svg, canvas")),
          (s.$imageWrapEl = s.$imageEl.parent("." + i.containerClass)),
          (s.maxRatio = s.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio),
          0 !== s.$imageWrapEl.length)
            ? (s.$imageEl.transition(0), (e.zoom.isScaling = !0))
            : (s.$imageEl = void 0);
        },
        onGestureChange: function (t) {
          var e = this.params.zoom,
            i = this.zoom,
            a = i.gesture;
          if (!N.gestures) {
            if (
              "touchmove" !== t.type ||
              ("touchmove" === t.type && t.targetTouches.length < 2)
            )
              return;
            (i.fakeGestureMoved = !0),
              (a.scaleMove = H.getDistanceBetweenTouches(t));
          }
          a.$imageEl &&
            0 !== a.$imageEl.length &&
            (N.gestures
              ? (this.zoom.scale = t.scale * i.currentScale)
              : (i.scale = (a.scaleMove / a.scaleStart) * i.currentScale),
            i.scale > a.maxRatio &&
              (i.scale =
                a.maxRatio - 1 + Math.pow(i.scale - a.maxRatio + 1, 0.5)),
            i.scale < e.minRatio &&
              (i.scale =
                e.minRatio + 1 - Math.pow(e.minRatio - i.scale + 1, 0.5)),
            a.$imageEl.transform("translate3d(0,0,0) scale(" + i.scale + ")"));
        },
        onGestureEnd: function (t) {
          var e = this.params.zoom,
            i = this.zoom,
            a = i.gesture;
          if (!N.gestures) {
            if (!i.fakeGestureTouched || !i.fakeGestureMoved) return;
            if (
              "touchend" !== t.type ||
              ("touchend" === t.type &&
                t.changedTouches.length < 2 &&
                !x.android)
            )
              return;
            (i.fakeGestureTouched = !1), (i.fakeGestureMoved = !1);
          }
          a.$imageEl &&
            0 !== a.$imageEl.length &&
            ((i.scale = Math.max(Math.min(i.scale, a.maxRatio), e.minRatio)),
            a.$imageEl
              .transition(this.params.speed)
              .transform("translate3d(0,0,0) scale(" + i.scale + ")"),
            (i.currentScale = i.scale),
            (i.isScaling = !1),
            1 === i.scale && (a.$slideEl = void 0));
        },
        onTouchStart: function (t) {
          var e = this.zoom,
            i = e.gesture,
            a = e.image;
          i.$imageEl &&
            0 !== i.$imageEl.length &&
            (a.isTouched ||
              (x.android && t.preventDefault(),
              (a.isTouched = !0),
              (a.touchesStart.x =
                "touchstart" === t.type ? t.targetTouches[0].pageX : t.pageX),
              (a.touchesStart.y =
                "touchstart" === t.type ? t.targetTouches[0].pageY : t.pageY)));
        },
        onTouchMove: function (t) {
          var e = this,
            i = e.zoom,
            a = i.gesture,
            s = i.image,
            n = i.velocity;
          if (
            a.$imageEl &&
            0 !== a.$imageEl.length &&
            ((e.allowClick = !1), s.isTouched && a.$slideEl)
          ) {
            s.isMoved ||
              ((s.width = a.$imageEl[0].offsetWidth),
              (s.height = a.$imageEl[0].offsetHeight),
              (s.startX = R.getTranslate(a.$imageWrapEl[0], "x") || 0),
              (s.startY = R.getTranslate(a.$imageWrapEl[0], "y") || 0),
              (a.slideWidth = a.$slideEl[0].offsetWidth),
              (a.slideHeight = a.$slideEl[0].offsetHeight),
              a.$imageWrapEl.transition(0),
              e.rtl && ((s.startX = -s.startX), (s.startY = -s.startY)));
            var o = s.width * i.scale,
              r = s.height * i.scale;
            if (!(o < a.slideWidth && r < a.slideHeight)) {
              if (
                ((s.minX = Math.min(a.slideWidth / 2 - o / 2, 0)),
                (s.maxX = -s.minX),
                (s.minY = Math.min(a.slideHeight / 2 - r / 2, 0)),
                (s.maxY = -s.minY),
                (s.touchesCurrent.x =
                  "touchmove" === t.type ? t.targetTouches[0].pageX : t.pageX),
                (s.touchesCurrent.y =
                  "touchmove" === t.type ? t.targetTouches[0].pageY : t.pageY),
                !s.isMoved && !i.isScaling)
              ) {
                if (
                  e.isHorizontal() &&
                  ((Math.floor(s.minX) === Math.floor(s.startX) &&
                    s.touchesCurrent.x < s.touchesStart.x) ||
                    (Math.floor(s.maxX) === Math.floor(s.startX) &&
                      s.touchesCurrent.x > s.touchesStart.x))
                )
                  return void (s.isTouched = !1);
                if (
                  !e.isHorizontal() &&
                  ((Math.floor(s.minY) === Math.floor(s.startY) &&
                    s.touchesCurrent.y < s.touchesStart.y) ||
                    (Math.floor(s.maxY) === Math.floor(s.startY) &&
                      s.touchesCurrent.y > s.touchesStart.y))
                )
                  return void (s.isTouched = !1);
              }
              t.preventDefault(),
                t.stopPropagation(),
                (s.isMoved = !0),
                (s.currentX = s.touchesCurrent.x - s.touchesStart.x + s.startX),
                (s.currentY = s.touchesCurrent.y - s.touchesStart.y + s.startY),
                s.currentX < s.minX &&
                  (s.currentX =
                    s.minX + 1 - Math.pow(s.minX - s.currentX + 1, 0.8)),
                s.currentX > s.maxX &&
                  (s.currentX =
                    s.maxX - 1 + Math.pow(s.currentX - s.maxX + 1, 0.8)),
                s.currentY < s.minY &&
                  (s.currentY =
                    s.minY + 1 - Math.pow(s.minY - s.currentY + 1, 0.8)),
                s.currentY > s.maxY &&
                  (s.currentY =
                    s.maxY - 1 + Math.pow(s.currentY - s.maxY + 1, 0.8)),
                n.prevPositionX || (n.prevPositionX = s.touchesCurrent.x),
                n.prevPositionY || (n.prevPositionY = s.touchesCurrent.y),
                n.prevTime || (n.prevTime = Date.now()),
                (n.x =
                  (s.touchesCurrent.x - n.prevPositionX) /
                  (Date.now() - n.prevTime) /
                  2),
                (n.y =
                  (s.touchesCurrent.y - n.prevPositionY) /
                  (Date.now() - n.prevTime) /
                  2),
                Math.abs(s.touchesCurrent.x - n.prevPositionX) < 2 && (n.x = 0),
                Math.abs(s.touchesCurrent.y - n.prevPositionY) < 2 && (n.y = 0),
                (n.prevPositionX = s.touchesCurrent.x),
                (n.prevPositionY = s.touchesCurrent.y),
                (n.prevTime = Date.now()),
                a.$imageWrapEl.transform(
                  "translate3d(" + s.currentX + "px, " + s.currentY + "px,0)"
                );
            }
          }
        },
        onTouchEnd: function () {
          var t = this.zoom,
            e = t.gesture,
            i = t.image,
            a = t.velocity;
          if (e.$imageEl && 0 !== e.$imageEl.length) {
            if (!i.isTouched || !i.isMoved)
              return (i.isTouched = !1), void (i.isMoved = !1);
            (i.isTouched = !1), (i.isMoved = !1);
            var s = 300,
              n = 300,
              o = a.x * s,
              r = i.currentX + o,
              l = a.y * n,
              h = i.currentY + l;
            0 !== a.x && (s = Math.abs((r - i.currentX) / a.x)),
              0 !== a.y && (n = Math.abs((h - i.currentY) / a.y));
            var d = Math.max(s, n);
            (i.currentX = r), (i.currentY = h);
            var c = i.width * t.scale,
              p = i.height * t.scale;
            (i.minX = Math.min(e.slideWidth / 2 - c / 2, 0)),
              (i.maxX = -i.minX),
              (i.minY = Math.min(e.slideHeight / 2 - p / 2, 0)),
              (i.maxY = -i.minY),
              (i.currentX = Math.max(Math.min(i.currentX, i.maxX), i.minX)),
              (i.currentY = Math.max(Math.min(i.currentY, i.maxY), i.minY)),
              e.$imageWrapEl
                .transition(d)
                .transform(
                  "translate3d(" + i.currentX + "px, " + i.currentY + "px,0)"
                );
          }
        },
        onTransitionEnd: function () {
          var t = this.zoom,
            e = t.gesture;
          e.$slideEl &&
            this.previousIndex !== this.activeIndex &&
            (e.$imageEl.transform("translate3d(0,0,0) scale(1)"),
            e.$imageWrapEl.transform("translate3d(0,0,0)"),
            (e.$slideEl = void 0),
            (e.$imageEl = void 0),
            (e.$imageWrapEl = void 0),
            (t.scale = 1),
            (t.currentScale = 1));
        },
        toggle: function (t) {
          var e = this.zoom;
          e.scale && 1 !== e.scale ? e.out() : e.in(t);
        },
        in: function (t) {
          var e,
            i,
            a,
            s,
            n,
            o,
            r,
            l,
            h,
            d,
            c,
            p,
            u,
            x,
            m,
            g,
            b = this,
            v = b.zoom,
            f = b.params.zoom,
            y = v.gesture,
            M = v.image;
          y.$slideEl ||
            ((y.$slideEl = b.clickedSlide
              ? F(b.clickedSlide)
              : b.slides.eq(b.activeIndex)),
            (y.$imageEl = y.$slideEl.find("img, svg, canvas")),
            (y.$imageWrapEl = y.$imageEl.parent("." + f.containerClass))),
            y.$imageEl &&
              0 !== y.$imageEl.length &&
              (y.$slideEl.addClass("" + f.zoomedSlideClass),
              (i =
                void 0 === M.touchesStart.x && t
                  ? ((e =
                      "touchend" === t.type
                        ? t.changedTouches[0].pageX
                        : t.pageX),
                    "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY)
                  : ((e = M.touchesStart.x), M.touchesStart.y)),
              (v.scale = y.$imageWrapEl.attr("data-swiper-zoom") || f.maxRatio),
              (v.currentScale =
                y.$imageWrapEl.attr("data-swiper-zoom") || f.maxRatio),
              t
                ? ((m = y.$slideEl[0].offsetWidth),
                  (g = y.$slideEl[0].offsetHeight),
                  (a = y.$slideEl.offset().left + m / 2 - e),
                  (s = y.$slideEl.offset().top + g / 2 - i),
                  (r = y.$imageEl[0].offsetWidth),
                  (l = y.$imageEl[0].offsetHeight),
                  (h = r * v.scale),
                  (d = l * v.scale),
                  (u = -(c = Math.min(m / 2 - h / 2, 0))),
                  (x = -(p = Math.min(g / 2 - d / 2, 0))),
                  (n = a * v.scale) < c && (n = c),
                  u < n && (n = u),
                  (o = s * v.scale) < p && (o = p),
                  x < o && (o = x))
                : (o = n = 0),
              y.$imageWrapEl
                .transition(300)
                .transform("translate3d(" + n + "px, " + o + "px,0)"),
              y.$imageEl
                .transition(300)
                .transform("translate3d(0,0,0) scale(" + v.scale + ")"));
        },
        out: function () {
          var t = this,
            e = t.zoom,
            i = t.params.zoom,
            a = e.gesture;
          a.$slideEl ||
            ((a.$slideEl = t.clickedSlide
              ? F(t.clickedSlide)
              : t.slides.eq(t.activeIndex)),
            (a.$imageEl = a.$slideEl.find("img, svg, canvas")),
            (a.$imageWrapEl = a.$imageEl.parent("." + i.containerClass))),
            a.$imageEl &&
              0 !== a.$imageEl.length &&
              ((e.scale = 1),
              (e.currentScale = 1),
              a.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"),
              a.$imageEl
                .transition(300)
                .transform("translate3d(0,0,0) scale(1)"),
              a.$slideEl.removeClass("" + i.zoomedSlideClass),
              (a.$slideEl = void 0));
        },
        enable: function () {
          var t = this,
            e = t.zoom;
          if (!e.enabled) {
            e.enabled = !0;
            var i = !(
              "touchstart" !== t.touchEvents.start ||
              !N.passiveListener ||
              !t.params.passiveListeners
            ) && { passive: !0, capture: !1 };
            N.gestures
              ? (t.$wrapperEl.on(
                  "gesturestart",
                  ".swiper-slide",
                  e.onGestureStart,
                  i
                ),
                t.$wrapperEl.on(
                  "gesturechange",
                  ".swiper-slide",
                  e.onGestureChange,
                  i
                ),
                t.$wrapperEl.on(
                  "gestureend",
                  ".swiper-slide",
                  e.onGestureEnd,
                  i
                ))
              : "touchstart" === t.touchEvents.start &&
                (t.$wrapperEl.on(
                  t.touchEvents.start,
                  ".swiper-slide",
                  e.onGestureStart,
                  i
                ),
                t.$wrapperEl.on(
                  t.touchEvents.move,
                  ".swiper-slide",
                  e.onGestureChange,
                  i
                ),
                t.$wrapperEl.on(
                  t.touchEvents.end,
                  ".swiper-slide",
                  e.onGestureEnd,
                  i
                )),
              t.$wrapperEl.on(
                t.touchEvents.move,
                "." + t.params.zoom.containerClass,
                e.onTouchMove
              );
          }
        },
        disable: function () {
          var t = this,
            e = t.zoom;
          if (e.enabled) {
            t.zoom.enabled = !1;
            var i = !(
              "touchstart" !== t.touchEvents.start ||
              !N.passiveListener ||
              !t.params.passiveListeners
            ) && { passive: !0, capture: !1 };
            N.gestures
              ? (t.$wrapperEl.off(
                  "gesturestart",
                  ".swiper-slide",
                  e.onGestureStart,
                  i
                ),
                t.$wrapperEl.off(
                  "gesturechange",
                  ".swiper-slide",
                  e.onGestureChange,
                  i
                ),
                t.$wrapperEl.off(
                  "gestureend",
                  ".swiper-slide",
                  e.onGestureEnd,
                  i
                ))
              : "touchstart" === t.touchEvents.start &&
                (t.$wrapperEl.off(
                  t.touchEvents.start,
                  ".swiper-slide",
                  e.onGestureStart,
                  i
                ),
                t.$wrapperEl.off(
                  t.touchEvents.move,
                  ".swiper-slide",
                  e.onGestureChange,
                  i
                ),
                t.$wrapperEl.off(
                  t.touchEvents.end,
                  ".swiper-slide",
                  e.onGestureEnd,
                  i
                )),
              t.$wrapperEl.off(
                t.touchEvents.move,
                "." + t.params.zoom.containerClass,
                e.onTouchMove
              );
          }
        },
      },
      $ = {
        loadInSlide: function (t, l) {
          void 0 === l && (l = !0);
          var h = this,
            d = h.params.lazy;
          if (void 0 !== t && 0 !== h.slides.length) {
            var c =
                h.virtual && h.params.virtual.enabled
                  ? h.$wrapperEl.children(
                      "." +
                        h.params.slideClass +
                        '[data-swiper-slide-index="' +
                        t +
                        '"]'
                    )
                  : h.slides.eq(t),
              e = c.find(
                "." +
                  d.elementClass +
                  ":not(." +
                  d.loadedClass +
                  "):not(." +
                  d.loadingClass +
                  ")"
              );
            !c.hasClass(d.elementClass) ||
              c.hasClass(d.loadedClass) ||
              c.hasClass(d.loadingClass) ||
              (e = e.add(c[0])),
              0 !== e.length &&
                e.each(function (t, e) {
                  var a = F(e);
                  a.addClass(d.loadingClass);
                  var s = a.attr("data-background"),
                    n = a.attr("data-src"),
                    o = a.attr("data-srcset"),
                    r = a.attr("data-sizes");
                  h.loadImage(a[0], n || s, o, r, !1, function () {
                    if (null != h && h && (!h || h.params) && !h.destroyed) {
                      if (
                        (s
                          ? (a.css("background-image", 'url("' + s + '")'),
                            a.removeAttr("data-background"))
                          : (o &&
                              (a.attr("srcset", o),
                              a.removeAttr("data-srcset")),
                            r &&
                              (a.attr("sizes", r), a.removeAttr("data-sizes")),
                            n && (a.attr("src", n), a.removeAttr("data-src"))),
                        a.addClass(d.loadedClass).removeClass(d.loadingClass),
                        c.find("." + d.preloaderClass).remove(),
                        h.params.loop && l)
                      ) {
                        var t = c.attr("data-swiper-slide-index");
                        if (c.hasClass(h.params.slideDuplicateClass)) {
                          var e = h.$wrapperEl.children(
                            '[data-swiper-slide-index="' +
                              t +
                              '"]:not(.' +
                              h.params.slideDuplicateClass +
                              ")"
                          );
                          h.lazy.loadInSlide(e.index(), !1);
                        } else {
                          var i = h.$wrapperEl.children(
                            "." +
                              h.params.slideDuplicateClass +
                              '[data-swiper-slide-index="' +
                              t +
                              '"]'
                          );
                          h.lazy.loadInSlide(i.index(), !1);
                        }
                      }
                      h.emit("lazyImageReady", c[0], a[0]);
                    }
                  }),
                    h.emit("lazyImageLoad", c[0], a[0]);
                });
          }
        },
        load: function () {
          var a = this,
            e = a.$wrapperEl,
            i = a.params,
            s = a.slides,
            t = a.activeIndex,
            n = a.virtual && i.virtual.enabled,
            o = i.lazy,
            r = i.slidesPerView;
          function l(t) {
            if (n) {
              if (
                e.children(
                  "." + i.slideClass + '[data-swiper-slide-index="' + t + '"]'
                ).length
              )
                return !0;
            } else if (s[t]) return !0;
            return !1;
          }
          function h(t) {
            return n ? F(t).attr("data-swiper-slide-index") : F(t).index();
          }
          if (
            ("auto" === r && (r = 0),
            a.lazy.initialImageLoaded || (a.lazy.initialImageLoaded = !0),
            a.params.watchSlidesVisibility)
          )
            e.children("." + i.slideVisibleClass).each(function (t, e) {
              var i = n ? F(e).attr("data-swiper-slide-index") : F(e).index();
              a.lazy.loadInSlide(i);
            });
          else if (1 < r)
            for (var d = t; d < t + r; d += 1) l(d) && a.lazy.loadInSlide(d);
          else a.lazy.loadInSlide(t);
          if (o.loadPrevNext)
            if (1 < r || (o.loadPrevNextAmount && 1 < o.loadPrevNextAmount)) {
              for (
                var c = o.loadPrevNextAmount,
                  p = r,
                  u = Math.min(t + p + Math.max(c, p), s.length),
                  x = Math.max(t - Math.max(p, c), 0),
                  m = t + r;
                m < u;
                m += 1
              )
                l(m) && a.lazy.loadInSlide(m);
              for (var g = x; g < t; g += 1) l(g) && a.lazy.loadInSlide(g);
            } else {
              var b = e.children("." + i.slideNextClass);
              0 < b.length && a.lazy.loadInSlide(h(b));
              var v = e.children("." + i.slidePrevClass);
              0 < v.length && a.lazy.loadInSlide(h(v));
            }
        },
      },
      j = {
        LinearSpline: function (t, e) {
          var i, a, s, n, o;
          return (
            (this.x = t),
            (this.y = e),
            (this.lastIndex = t.length - 1),
            (this.interpolate = function (t) {
              return t
                ? ((o = (function (t, e) {
                    for (a = -1, i = t.length; 1 < i - a; )
                      t[(s = (i + a) >> 1)] <= e ? (a = s) : (i = s);
                    return i;
                  })(this.x, t)),
                  (n = o - 1),
                  ((t - this.x[n]) * (this.y[o] - this.y[n])) /
                    (this.x[o] - this.x[n]) +
                    this.y[n])
                : 0;
            }),
            this
          );
        },
        getInterpolateFunction: function (t) {
          var e = this;
          e.controller.spline ||
            (e.controller.spline = e.params.loop
              ? new j.LinearSpline(e.slidesGrid, t.slidesGrid)
              : new j.LinearSpline(e.snapGrid, t.snapGrid));
        },
        setTranslate: function (t, e) {
          var i,
            a,
            s = this,
            n = s.controller.control;
          function o(t) {
            var e = s.rtlTranslate ? -s.translate : s.translate;
            "slide" === s.params.controller.by &&
              (s.controller.getInterpolateFunction(t),
              (a = -s.controller.spline.interpolate(-e))),
              (a && "container" !== s.params.controller.by) ||
                ((i =
                  (t.maxTranslate() - t.minTranslate()) /
                  (s.maxTranslate() - s.minTranslate())),
                (a = (e - s.minTranslate()) * i + t.minTranslate())),
              s.params.controller.inverse && (a = t.maxTranslate() - a),
              t.updateProgress(a),
              t.setTranslate(a, s),
              t.updateActiveIndex(),
              t.updateSlidesClasses();
          }
          if (Array.isArray(n))
            for (var r = 0; r < n.length; r += 1)
              n[r] !== e && n[r] instanceof w && o(n[r]);
          else n instanceof w && e !== n && o(n);
        },
        setTransition: function (e, t) {
          var i,
            a = this,
            s = a.controller.control;
          function n(t) {
            t.setTransition(e, a),
              0 !== e &&
                (t.transitionStart(),
                t.params.autoHeight &&
                  R.nextTick(function () {
                    t.updateAutoHeight();
                  }),
                t.$wrapperEl.transitionEnd(function () {
                  s &&
                    (t.params.loop &&
                      "slide" === a.params.controller.by &&
                      t.loopFix(),
                    t.transitionEnd());
                }));
          }
          if (Array.isArray(s))
            for (i = 0; i < s.length; i += 1)
              s[i] !== t && s[i] instanceof w && n(s[i]);
          else s instanceof w && t !== s && n(s);
        },
      },
      G = {
        makeElFocusable: function (t) {
          return t.attr("tabIndex", "0"), t;
        },
        addElRole: function (t, e) {
          return t.attr("role", e), t;
        },
        addElLabel: function (t, e) {
          return t.attr("aria-label", e), t;
        },
        disableEl: function (t) {
          return t.attr("aria-disabled", !0), t;
        },
        enableEl: function (t) {
          return t.attr("aria-disabled", !1), t;
        },
        onEnterKey: function (t) {
          var e = this,
            i = e.params.a11y;
          if (13 === t.keyCode) {
            var a = F(t.target);
            e.navigation &&
              e.navigation.$nextEl &&
              a.is(e.navigation.$nextEl) &&
              ((e.isEnd && !e.params.loop) || e.slideNext(),
              e.isEnd
                ? e.a11y.notify(i.lastSlideMessage)
                : e.a11y.notify(i.nextSlideMessage)),
              e.navigation &&
                e.navigation.$prevEl &&
                a.is(e.navigation.$prevEl) &&
                ((e.isBeginning && !e.params.loop) || e.slidePrev(),
                e.isBeginning
                  ? e.a11y.notify(i.firstSlideMessage)
                  : e.a11y.notify(i.prevSlideMessage)),
              e.pagination &&
                a.is("." + e.params.pagination.bulletClass) &&
                a[0].click();
          }
        },
        notify: function (t) {
          var e = this.a11y.liveRegion;
          0 !== e.length && (e.html(""), e.html(t));
        },
        updateNavigation: function () {
          var t = this;
          if (!t.params.loop) {
            var e = t.navigation,
              i = e.$nextEl,
              a = e.$prevEl;
            a &&
              0 < a.length &&
              (t.isBeginning ? t.a11y.disableEl(a) : t.a11y.enableEl(a)),
              i &&
                0 < i.length &&
                (t.isEnd ? t.a11y.disableEl(i) : t.a11y.enableEl(i));
          }
        },
        updatePagination: function () {
          var a = this,
            s = a.params.a11y;
          a.pagination &&
            a.params.pagination.clickable &&
            a.pagination.bullets &&
            a.pagination.bullets.length &&
            a.pagination.bullets.each(function (t, e) {
              var i = F(e);
              a.a11y.makeElFocusable(i),
                a.a11y.addElRole(i, "button"),
                a.a11y.addElLabel(
                  i,
                  s.paginationBulletMessage.replace(/{{index}}/, i.index() + 1)
                );
            });
        },
        init: function () {
          var t = this;
          t.$el.append(t.a11y.liveRegion);
          var e,
            i,
            a = t.params.a11y;
          t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl),
            t.navigation && t.navigation.$prevEl && (i = t.navigation.$prevEl),
            e &&
              (t.a11y.makeElFocusable(e),
              t.a11y.addElRole(e, "button"),
              t.a11y.addElLabel(e, a.nextSlideMessage),
              e.on("keydown", t.a11y.onEnterKey)),
            i &&
              (t.a11y.makeElFocusable(i),
              t.a11y.addElRole(i, "button"),
              t.a11y.addElLabel(i, a.prevSlideMessage),
              i.on("keydown", t.a11y.onEnterKey)),
            t.pagination &&
              t.params.pagination.clickable &&
              t.pagination.bullets &&
              t.pagination.bullets.length &&
              t.pagination.$el.on(
                "keydown",
                "." + t.params.pagination.bulletClass,
                t.a11y.onEnterKey
              );
        },
        destroy: function () {
          var t,
            e,
            i = this;
          i.a11y.liveRegion &&
            0 < i.a11y.liveRegion.length &&
            i.a11y.liveRegion.remove(),
            i.navigation && i.navigation.$nextEl && (t = i.navigation.$nextEl),
            i.navigation && i.navigation.$prevEl && (e = i.navigation.$prevEl),
            t && t.off("keydown", i.a11y.onEnterKey),
            e && e.off("keydown", i.a11y.onEnterKey),
            i.pagination &&
              i.params.pagination.clickable &&
              i.pagination.bullets &&
              i.pagination.bullets.length &&
              i.pagination.$el.off(
                "keydown",
                "." + i.params.pagination.bulletClass,
                i.a11y.onEnterKey
              );
        },
      },
      U = {
        init: function () {
          var t = this;
          if (t.params.history) {
            if (!O.history || !O.history.pushState)
              return (
                (t.params.history.enabled = !1),
                void (t.params.hashNavigation.enabled = !0)
              );
            var e = t.history;
            (e.initialized = !0),
              (e.paths = U.getPathValues()),
              (e.paths.key || e.paths.value) &&
                (e.scrollToSlide(0, e.paths.value, t.params.runCallbacksOnInit),
                t.params.history.replaceState ||
                  O.addEventListener("popstate", t.history.setHistoryPopState));
          }
        },
        destroy: function () {
          this.params.history.replaceState ||
            O.removeEventListener("popstate", this.history.setHistoryPopState);
        },
        setHistoryPopState: function () {
          (this.history.paths = U.getPathValues()),
            this.history.scrollToSlide(
              this.params.speed,
              this.history.paths.value,
              !1
            );
        },
        getPathValues: function () {
          var t = O.location.pathname
              .slice(1)
              .split("/")
              .filter(function (t) {
                return "" !== t;
              }),
            e = t.length;
          return { key: t[e - 2], value: t[e - 1] };
        },
        setHistory: function (t, e) {
          if (this.history.initialized && this.params.history.enabled) {
            var i = this.slides.eq(e),
              a = U.slugify(i.attr("data-history"));
            O.location.pathname.includes(t) || (a = t + "/" + a);
            var s = O.history.state;
            (s && s.value === a) ||
              (this.params.history.replaceState
                ? O.history.replaceState({ value: a }, null, a)
                : O.history.pushState({ value: a }, null, a));
          }
        },
        slugify: function (t) {
          return t
            .toString()
            .toLowerCase()
            .replace(/\s+/g, "-")
            .replace(/[^\w-]+/g, "")
            .replace(/--+/g, "-")
            .replace(/^-+/, "")
            .replace(/-+$/, "");
        },
        scrollToSlide: function (t, e, i) {
          var a = this;
          if (e)
            for (var s = 0, n = a.slides.length; s < n; s += 1) {
              var o = a.slides.eq(s);
              if (
                U.slugify(o.attr("data-history")) === e &&
                !o.hasClass(a.params.slideDuplicateClass)
              ) {
                var r = o.index();
                a.slideTo(r, t, i);
              }
            }
          else a.slideTo(0, t, i);
        },
      },
      q = {
        onHashCange: function () {
          var t = this,
            e = m.location.hash.replace("#", "");
          if (e !== t.slides.eq(t.activeIndex).attr("data-hash")) {
            var i = t.$wrapperEl
              .children("." + t.params.slideClass + '[data-hash="' + e + '"]')
              .index();
            if (void 0 === i) return;
            t.slideTo(i);
          }
        },
        setHash: function () {
          var t = this;
          if (t.hashNavigation.initialized && t.params.hashNavigation.enabled)
            if (
              t.params.hashNavigation.replaceState &&
              O.history &&
              O.history.replaceState
            )
              O.history.replaceState(
                null,
                null,
                "#" + t.slides.eq(t.activeIndex).attr("data-hash") || ""
              );
            else {
              var e = t.slides.eq(t.activeIndex),
                i = e.attr("data-hash") || e.attr("data-history");
              m.location.hash = i || "";
            }
        },
        init: function () {
          var t = this;
          if (
            !(
              !t.params.hashNavigation.enabled ||
              (t.params.history && t.params.history.enabled)
            )
          ) {
            t.hashNavigation.initialized = !0;
            var e = m.location.hash.replace("#", "");
            if (e)
              for (var i = 0, a = t.slides.length; i < a; i += 1) {
                var s = t.slides.eq(i);
                if (
                  (s.attr("data-hash") || s.attr("data-history")) === e &&
                  !s.hasClass(t.params.slideDuplicateClass)
                ) {
                  var n = s.index();
                  t.slideTo(n, 0, t.params.runCallbacksOnInit, !0);
                }
              }
            t.params.hashNavigation.watchState &&
              F(O).on("hashchange", t.hashNavigation.onHashCange);
          }
        },
        destroy: function () {
          this.params.hashNavigation.watchState &&
            F(O).off("hashchange", this.hashNavigation.onHashCange);
        },
      },
      K = {
        run: function () {
          var t = this,
            e = t.slides.eq(t.activeIndex),
            i = t.params.autoplay.delay;
          e.attr("data-swiper-autoplay") &&
            (i = e.attr("data-swiper-autoplay") || t.params.autoplay.delay),
            (t.autoplay.timeout = R.nextTick(function () {
              t.params.autoplay.reverseDirection
                ? t.params.loop
                  ? (t.loopFix(),
                    t.slidePrev(t.params.speed, !0, !0),
                    t.emit("autoplay"))
                  : t.isBeginning
                  ? t.params.autoplay.stopOnLastSlide
                    ? t.autoplay.stop()
                    : (t.slideTo(t.slides.length - 1, t.params.speed, !0, !0),
                      t.emit("autoplay"))
                  : (t.slidePrev(t.params.speed, !0, !0), t.emit("autoplay"))
                : t.params.loop
                ? (t.loopFix(),
                  t.slideNext(t.params.speed, !0, !0),
                  t.emit("autoplay"))
                : t.isEnd
                ? t.params.autoplay.stopOnLastSlide
                  ? t.autoplay.stop()
                  : (t.slideTo(0, t.params.speed, !0, !0), t.emit("autoplay"))
                : (t.slideNext(t.params.speed, !0, !0), t.emit("autoplay"));
            }, i));
        },
        start: function () {
          var t = this;
          return (
            void 0 === t.autoplay.timeout &&
            !t.autoplay.running &&
            ((t.autoplay.running = !0),
            t.emit("autoplayStart"),
            t.autoplay.run(),
            !0)
          );
        },
        stop: function () {
          var t = this;
          return (
            !!t.autoplay.running &&
            void 0 !== t.autoplay.timeout &&
            (t.autoplay.timeout &&
              (clearTimeout(t.autoplay.timeout), (t.autoplay.timeout = void 0)),
            (t.autoplay.running = !1),
            t.emit("autoplayStop"),
            !0)
          );
        },
        pause: function (t) {
          var e = this;
          e.autoplay.running &&
            (e.autoplay.paused ||
              (e.autoplay.timeout && clearTimeout(e.autoplay.timeout),
              (e.autoplay.paused = !0),
              0 !== t && e.params.autoplay.waitForTransition
                ? (e.$wrapperEl[0].addEventListener(
                    "transitionend",
                    e.autoplay.onTransitionEnd
                  ),
                  e.$wrapperEl[0].addEventListener(
                    "webkitTransitionEnd",
                    e.autoplay.onTransitionEnd
                  ))
                : ((e.autoplay.paused = !1), e.autoplay.run())));
        },
      },
      Q = {
        setTranslate: function () {
          for (var t = this, e = t.slides, i = 0; i < e.length; i += 1) {
            var a = t.slides.eq(i),
              s = -a[0].swiperSlideOffset;
            t.params.virtualTranslate || (s -= t.translate);
            var n = 0;
            t.isHorizontal() || ((n = s), (s = 0));
            var o = t.params.fadeEffect.crossFade
              ? Math.max(1 - Math.abs(a[0].progress), 0)
              : 1 + Math.min(Math.max(a[0].progress, -1), 0);
            a.css({ opacity: o }).transform(
              "translate3d(" + s + "px, " + n + "px, 0px)"
            );
          }
        },
        setTransition: function (t) {
          var i = this,
            e = i.slides,
            a = i.$wrapperEl;
          if ((e.transition(t), i.params.virtualTranslate && 0 !== t)) {
            var s = !1;
            e.transitionEnd(function () {
              if (!s && i && !i.destroyed) {
                (s = !0), (i.animating = !1);
                for (
                  var t = ["webkitTransitionEnd", "transitionend"], e = 0;
                  e < t.length;
                  e += 1
                )
                  a.trigger(t[e]);
              }
            });
          }
        },
      },
      J = {
        setTranslate: function () {
          var t,
            e = this,
            i = e.$el,
            a = e.$wrapperEl,
            s = e.slides,
            n = e.width,
            o = e.height,
            r = e.rtlTranslate,
            l = e.size,
            h = e.params.cubeEffect,
            d = e.isHorizontal(),
            c = e.virtual && e.params.virtual.enabled,
            p = 0;
          h.shadow &&
            (d
              ? (0 === (t = a.find(".swiper-cube-shadow")).length &&
                  ((t = F('<div class="swiper-cube-shadow"></div>')),
                  a.append(t)),
                t.css({ height: n + "px" }))
              : 0 === (t = i.find(".swiper-cube-shadow")).length &&
                ((t = F('<div class="swiper-cube-shadow"></div>')),
                i.append(t)));
          for (var u = 0; u < s.length; u += 1) {
            var x = s.eq(u),
              m = u;
            c && (m = parseInt(x.attr("data-swiper-slide-index"), 10));
            var g = 90 * m,
              b = Math.floor(g / 360);
            r && ((g = -g), (b = Math.floor(-g / 360)));
            var v = Math.max(Math.min(x[0].progress, 1), -1),
              f = 0,
              y = 0,
              M = 0;
            m % 4 == 0
              ? ((f = 4 * -b * l), (M = 0))
              : (m - 1) % 4 == 0
              ? ((f = 0), (M = 4 * -b * l))
              : (m - 2) % 4 == 0
              ? ((f = l + 4 * b * l), (M = l))
              : (m - 3) % 4 == 0 && ((f = -l), (M = 3 * l + 4 * l * b)),
              r && (f = -f),
              d || ((y = f), (f = 0));
            var k =
              "rotateX(" +
              (d ? 0 : -g) +
              "deg) rotateY(" +
              (d ? g : 0) +
              "deg) translate3d(" +
              f +
              "px, " +
              y +
              "px, " +
              M +
              "px)";
            if (
              (v <= 1 &&
                -1 < v &&
                ((p = 90 * m + 90 * v), r && (p = 90 * -m - 90 * v)),
              x.transform(k),
              h.slideShadows)
            ) {
              var w = d
                  ? x.find(".swiper-slide-shadow-left")
                  : x.find(".swiper-slide-shadow-top"),
                T = d
                  ? x.find(".swiper-slide-shadow-right")
                  : x.find(".swiper-slide-shadow-bottom");
              0 === w.length &&
                ((w = F(
                  '<div class="swiper-slide-shadow-' +
                    (d ? "left" : "top") +
                    '"></div>'
                )),
                x.append(w)),
                0 === T.length &&
                  ((T = F(
                    '<div class="swiper-slide-shadow-' +
                      (d ? "right" : "bottom") +
                      '"></div>'
                  )),
                  x.append(T)),
                w.length && (w[0].style.opacity = Math.max(-v, 0)),
                T.length && (T[0].style.opacity = Math.max(v, 0));
            }
          }
          if (
            (a.css({
              "-webkit-transform-origin": "50% 50% -" + l / 2 + "px",
              "-moz-transform-origin": "50% 50% -" + l / 2 + "px",
              "-ms-transform-origin": "50% 50% -" + l / 2 + "px",
              "transform-origin": "50% 50% -" + l / 2 + "px",
            }),
            h.shadow)
          )
            if (d)
              t.transform(
                "translate3d(0px, " +
                  (n / 2 + h.shadowOffset) +
                  "px, " +
                  -n / 2 +
                  "px) rotateX(90deg) rotateZ(0deg) scale(" +
                  h.shadowScale +
                  ")"
              );
            else {
              var C = Math.abs(p) - 90 * Math.floor(Math.abs(p) / 90),
                P =
                  1.5 -
                  (Math.sin((2 * C * Math.PI) / 360) / 2 +
                    Math.cos((2 * C * Math.PI) / 360) / 2),
                S = h.shadowScale,
                A = h.shadowScale / P,
                _ = h.shadowOffset;
              t.transform(
                "scale3d(" +
                  S +
                  ", 1, " +
                  A +
                  ") translate3d(0px, " +
                  (o / 2 + _) +
                  "px, " +
                  -o / 2 / A +
                  "px) rotateX(-90deg)"
              );
            }
          var B = L.isSafari || L.isUiWebView ? -l / 2 : 0;
          a.transform(
            "translate3d(0px,0," +
              B +
              "px) rotateX(" +
              (e.isHorizontal() ? 0 : p) +
              "deg) rotateY(" +
              (e.isHorizontal() ? -p : 0) +
              "deg)"
          );
        },
        setTransition: function (t) {
          var e = this.$el;
          this.slides
            .transition(t)
            .find(
              ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
            )
            .transition(t),
            this.params.cubeEffect.shadow &&
              !this.isHorizontal() &&
              e.find(".swiper-cube-shadow").transition(t);
        },
      },
      Z = {
        setTranslate: function () {
          for (
            var t = this, e = t.slides, i = t.rtlTranslate, a = 0;
            a < e.length;
            a += 1
          ) {
            var s = e.eq(a),
              n = s[0].progress;
            t.params.flipEffect.limitRotation &&
              (n = Math.max(Math.min(s[0].progress, 1), -1));
            var o = -180 * n,
              r = 0,
              l = -s[0].swiperSlideOffset,
              h = 0;
            if (
              (t.isHorizontal()
                ? i && (o = -o)
                : ((h = l), (r = -o), (o = l = 0)),
              (s[0].style.zIndex = -Math.abs(Math.round(n)) + e.length),
              t.params.flipEffect.slideShadows)
            ) {
              var d = t.isHorizontal()
                  ? s.find(".swiper-slide-shadow-left")
                  : s.find(".swiper-slide-shadow-top"),
                c = t.isHorizontal()
                  ? s.find(".swiper-slide-shadow-right")
                  : s.find(".swiper-slide-shadow-bottom");
              0 === d.length &&
                ((d = F(
                  '<div class="swiper-slide-shadow-' +
                    (t.isHorizontal() ? "left" : "top") +
                    '"></div>'
                )),
                s.append(d)),
                0 === c.length &&
                  ((c = F(
                    '<div class="swiper-slide-shadow-' +
                      (t.isHorizontal() ? "right" : "bottom") +
                      '"></div>'
                  )),
                  s.append(c)),
                d.length && (d[0].style.opacity = Math.max(-n, 0)),
                c.length && (c[0].style.opacity = Math.max(n, 0));
            }
            s.transform(
              "translate3d(" +
                l +
                "px, " +
                h +
                "px, 0px) rotateX(" +
                r +
                "deg) rotateY(" +
                o +
                "deg)"
            );
          }
        },
        setTransition: function (t) {
          var i = this,
            e = i.slides,
            a = i.activeIndex,
            s = i.$wrapperEl;
          if (
            (e
              .transition(t)
              .find(
                ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
              )
              .transition(t),
            i.params.virtualTranslate && 0 !== t)
          ) {
            var n = !1;
            e.eq(a).transitionEnd(function () {
              if (!n && i && !i.destroyed) {
                (n = !0), (i.animating = !1);
                for (
                  var t = ["webkitTransitionEnd", "transitionend"], e = 0;
                  e < t.length;
                  e += 1
                )
                  s.trigger(t[e]);
              }
            });
          }
        },
      },
      tt = {
        setTranslate: function () {
          for (
            var t = this,
              e = t.width,
              i = t.height,
              a = t.slides,
              s = t.$wrapperEl,
              n = t.slidesSizesGrid,
              o = t.params.coverflowEffect,
              r = t.isHorizontal(),
              l = t.translate,
              h = r ? e / 2 - l : i / 2 - l,
              d = r ? o.rotate : -o.rotate,
              c = o.depth,
              p = 0,
              u = a.length;
            p < u;
            p += 1
          ) {
            var x = a.eq(p),
              m = n[p],
              g = ((h - x[0].swiperSlideOffset - m / 2) / m) * o.modifier,
              b = r ? d * g : 0,
              v = r ? 0 : d * g,
              f = -c * Math.abs(g),
              y = r ? 0 : o.stretch * g,
              M = r ? o.stretch * g : 0;
            Math.abs(M) < 0.001 && (M = 0),
              Math.abs(y) < 0.001 && (y = 0),
              Math.abs(f) < 0.001 && (f = 0),
              Math.abs(b) < 0.001 && (b = 0),
              Math.abs(v) < 0.001 && (v = 0);
            var k =
              "translate3d(" +
              M +
              "px," +
              y +
              "px," +
              f +
              "px)  rotateX(" +
              v +
              "deg) rotateY(" +
              b +
              "deg)";
            if (
              (x.transform(k),
              (x[0].style.zIndex = 1 - Math.abs(Math.round(g))),
              o.slideShadows)
            ) {
              var w = r
                  ? x.find(".swiper-slide-shadow-left")
                  : x.find(".swiper-slide-shadow-top"),
                T = r
                  ? x.find(".swiper-slide-shadow-right")
                  : x.find(".swiper-slide-shadow-bottom");
              0 === w.length &&
                ((w = F(
                  '<div class="swiper-slide-shadow-' +
                    (r ? "left" : "top") +
                    '"></div>'
                )),
                x.append(w)),
                0 === T.length &&
                  ((T = F(
                    '<div class="swiper-slide-shadow-' +
                      (r ? "right" : "bottom") +
                      '"></div>'
                  )),
                  x.append(T)),
                w.length && (w[0].style.opacity = 0 < g ? g : 0),
                T.length && (T[0].style.opacity = 0 < -g ? -g : 0);
            }
          }
          (N.pointerEvents || N.prefixedPointerEvents) &&
            (s[0].style.perspectiveOrigin = h + "px 50%");
        },
        setTransition: function (t) {
          this.slides
            .transition(t)
            .find(
              ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
            )
            .transition(t);
        },
      },
      et = {
        init: function () {
          var t = this,
            e = t.params.thumbs,
            i = t.constructor;
          e.swiper instanceof i
            ? ((t.thumbs.swiper = e.swiper),
              R.extend(t.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1,
              }),
              R.extend(t.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1,
              }))
            : R.isObject(e.swiper) &&
              ((t.thumbs.swiper = new i(
                R.extend({}, e.swiper, {
                  watchSlidesVisibility: !0,
                  watchSlidesProgress: !0,
                  slideToClickedSlide: !1,
                })
              )),
              (t.thumbs.swiperCreated = !0)),
            t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass),
            t.thumbs.swiper.on("tap", t.thumbs.onThumbClick);
        },
        onThumbClick: function () {
          var t = this,
            e = t.thumbs.swiper;
          if (e) {
            var i = e.clickedIndex;
            if (null != i) {
              var a;
              if (
                ((a = e.params.loop
                  ? parseInt(
                      F(e.clickedSlide).attr("data-swiper-slide-index"),
                      10
                    )
                  : i),
                t.params.loop)
              ) {
                var s = t.activeIndex;
                t.slides.eq(s).hasClass(t.params.slideDuplicateClass) &&
                  (t.loopFix(),
                  (t._clientLeft = t.$wrapperEl[0].clientLeft),
                  (s = t.activeIndex));
                var n = t.slides
                    .eq(s)
                    .prevAll('[data-swiper-slide-index="' + a + '"]')
                    .eq(0)
                    .index(),
                  o = t.slides
                    .eq(s)
                    .nextAll('[data-swiper-slide-index="' + a + '"]')
                    .eq(0)
                    .index();
                a = void 0 === n ? o : void 0 === o ? n : o - s < s - n ? o : n;
              }
              t.slideTo(a);
            }
          }
        },
        update: function (t) {
          var e = this,
            i = e.thumbs.swiper;
          if (i) {
            var a =
              "auto" === i.params.slidesPerView
                ? i.slidesPerViewDynamic()
                : i.params.slidesPerView;
            if (e.realIndex !== i.realIndex) {
              var s,
                n = i.activeIndex;
              if (i.params.loop) {
                i.slides.eq(n).hasClass(i.params.slideDuplicateClass) &&
                  (i.loopFix(),
                  (i._clientLeft = i.$wrapperEl[0].clientLeft),
                  (n = i.activeIndex));
                var o = i.slides
                    .eq(n)
                    .prevAll('[data-swiper-slide-index="' + e.realIndex + '"]')
                    .eq(0)
                    .index(),
                  r = i.slides
                    .eq(n)
                    .nextAll('[data-swiper-slide-index="' + e.realIndex + '"]')
                    .eq(0)
                    .index();
                s = void 0 === o ? r : void 0 === r ? o : r - n < n - o ? r : o;
              } else s = e.realIndex;
              i.visibleSlidesIndexes.indexOf(s) < 0 &&
                (i.params.centeredSlides
                  ? (s =
                      n < s
                        ? s - Math.floor(a / 2) + 1
                        : s + Math.floor(a / 2) - 1)
                  : n < s && (s = s - a + 1),
                i.slideTo(s, t ? 0 : void 0));
            }
            var l = 1,
              h = e.params.thumbs.slideThumbActiveClass;
            if (
              (1 < e.params.slidesPerView &&
                !e.params.centeredSlides &&
                (l = e.params.slidesPerView),
              i.slides.removeClass(h),
              i.params.loop)
            )
              for (var d = 0; d < l; d += 1)
                i.$wrapperEl
                  .children(
                    '[data-swiper-slide-index="' + (e.realIndex + d) + '"]'
                  )
                  .addClass(h);
            else
              for (var c = 0; c < l; c += 1)
                i.slides.eq(e.realIndex + c).addClass(h);
          }
        },
      },
      it = [
        T,
        C,
        P,
        S,
        _,
        I,
        D,
        {
          name: "mousewheel",
          params: {
            mousewheel: {
              enabled: !1,
              releaseOnEdges: !1,
              invert: !1,
              forceToAxis: !1,
              sensitivity: 1,
              eventsTarged: "container",
            },
          },
          create: function () {
            var t = this;
            R.extend(t, {
              mousewheel: {
                enabled: !1,
                enable: V.enable.bind(t),
                disable: V.disable.bind(t),
                handle: V.handle.bind(t),
                handleMouseEnter: V.handleMouseEnter.bind(t),
                handleMouseLeave: V.handleMouseLeave.bind(t),
                lastScrollTime: R.now(),
              },
            });
          },
          on: {
            init: function () {
              this.params.mousewheel.enabled && this.mousewheel.enable();
            },
            destroy: function () {
              this.mousewheel.enabled && this.mousewheel.disable();
            },
          },
        },
        {
          name: "navigation",
          params: {
            navigation: {
              nextEl: null,
              prevEl: null,
              hideOnClick: !1,
              disabledClass: "swiper-button-disabled",
              hiddenClass: "swiper-button-hidden",
              lockClass: "swiper-button-lock",
            },
          },
          create: function () {
            R.extend(this, {
              navigation: {
                init: z.init.bind(this),
                update: z.update.bind(this),
                destroy: z.destroy.bind(this),
              },
            });
          },
          on: {
            init: function () {
              this.navigation.init(), this.navigation.update();
            },
            toEdge: function () {
              this.navigation.update();
            },
            fromEdge: function () {
              this.navigation.update();
            },
            destroy: function () {
              this.navigation.destroy();
            },
            click: function (t) {
              var e = this.navigation,
                i = e.$nextEl,
                a = e.$prevEl;
              !this.params.navigation.hideOnClick ||
                F(t.target).is(a) ||
                F(t.target).is(i) ||
                (i && i.toggleClass(this.params.navigation.hiddenClass),
                a && a.toggleClass(this.params.navigation.hiddenClass));
            },
          },
        },
        {
          name: "pagination",
          params: {
            pagination: {
              el: null,
              bulletElement: "span",
              clickable: !1,
              hideOnClick: !1,
              renderBullet: null,
              renderProgressbar: null,
              renderFraction: null,
              renderCustom: null,
              progressbarOpposite: !1,
              type: "bullets",
              dynamicBullets: !1,
              dynamicMainBullets: 1,
              formatFractionCurrent: function (t) {
                return t;
              },
              formatFractionTotal: function (t) {
                return t;
              },
              bulletClass: "swiper-pagination-bullet",
              bulletActiveClass: "swiper-pagination-bullet-active",
              modifierClass: "swiper-pagination-",
              currentClass: "swiper-pagination-current",
              totalClass: "swiper-pagination-total",
              hiddenClass: "swiper-pagination-hidden",
              progressbarFillClass: "swiper-pagination-progressbar-fill",
              progressbarOppositeClass:
                "swiper-pagination-progressbar-opposite",
              clickableClass: "swiper-pagination-clickable",
              lockClass: "swiper-pagination-lock",
            },
          },
          create: function () {
            var t = this;
            R.extend(t, {
              pagination: {
                init: W.init.bind(t),
                render: W.render.bind(t),
                update: W.update.bind(t),
                destroy: W.destroy.bind(t),
                dynamicBulletIndex: 0,
              },
            });
          },
          on: {
            init: function () {
              this.pagination.init(),
                this.pagination.render(),
                this.pagination.update();
            },
            activeIndexChange: function () {
              this.params.loop
                ? this.pagination.update()
                : void 0 === this.snapIndex && this.pagination.update();
            },
            snapIndexChange: function () {
              this.params.loop || this.pagination.update();
            },
            slidesLengthChange: function () {
              this.params.loop &&
                (this.pagination.render(), this.pagination.update());
            },
            snapGridLengthChange: function () {
              this.params.loop ||
                (this.pagination.render(), this.pagination.update());
            },
            destroy: function () {
              this.pagination.destroy();
            },
            click: function (t) {
              var e = this;
              e.params.pagination.el &&
                e.params.pagination.hideOnClick &&
                0 < e.pagination.$el.length &&
                !F(t.target).hasClass(e.params.pagination.bulletClass) &&
                e.pagination.$el.toggleClass(e.params.pagination.hiddenClass);
            },
          },
        },
        {
          name: "scrollbar",
          params: {
            scrollbar: {
              el: null,
              dragSize: "auto",
              hide: !1,
              draggable: !1,
              snapOnRelease: !0,
              lockClass: "swiper-scrollbar-lock",
              dragClass: "swiper-scrollbar-drag",
            },
          },
          create: function () {
            var t = this;
            R.extend(t, {
              scrollbar: {
                init: X.init.bind(t),
                destroy: X.destroy.bind(t),
                updateSize: X.updateSize.bind(t),
                setTranslate: X.setTranslate.bind(t),
                setTransition: X.setTransition.bind(t),
                enableDraggable: X.enableDraggable.bind(t),
                disableDraggable: X.disableDraggable.bind(t),
                setDragPosition: X.setDragPosition.bind(t),
                onDragStart: X.onDragStart.bind(t),
                onDragMove: X.onDragMove.bind(t),
                onDragEnd: X.onDragEnd.bind(t),
                isTouched: !1,
                timeout: null,
                dragTimeout: null,
              },
            });
          },
          on: {
            init: function () {
              this.scrollbar.init(),
                this.scrollbar.updateSize(),
                this.scrollbar.setTranslate();
            },
            update: function () {
              this.scrollbar.updateSize();
            },
            resize: function () {
              this.scrollbar.updateSize();
            },
            observerUpdate: function () {
              this.scrollbar.updateSize();
            },
            setTranslate: function () {
              this.scrollbar.setTranslate();
            },
            setTransition: function (t) {
              this.scrollbar.setTransition(t);
            },
            destroy: function () {
              this.scrollbar.destroy();
            },
          },
        },
        {
          name: "parallax",
          params: { parallax: { enabled: !1 } },
          create: function () {
            R.extend(this, {
              parallax: {
                setTransform: Y.setTransform.bind(this),
                setTranslate: Y.setTranslate.bind(this),
                setTransition: Y.setTransition.bind(this),
              },
            });
          },
          on: {
            beforeInit: function () {
              this.params.parallax.enabled &&
                ((this.params.watchSlidesProgress = !0),
                (this.originalParams.watchSlidesProgress = !0));
            },
            init: function () {
              this.params.parallax && this.parallax.setTranslate();
            },
            setTranslate: function () {
              this.params.parallax && this.parallax.setTranslate();
            },
            setTransition: function (t) {
              this.params.parallax && this.parallax.setTransition(t);
            },
          },
        },
        {
          name: "zoom",
          params: {
            zoom: {
              enabled: !1,
              maxRatio: 3,
              minRatio: 1,
              toggle: !0,
              containerClass: "swiper-zoom-container",
              zoomedSlideClass: "swiper-slide-zoomed",
            },
          },
          create: function () {
            var e = this,
              i = {
                enabled: !1,
                scale: 1,
                currentScale: 1,
                isScaling: !1,
                gesture: {
                  $slideEl: void 0,
                  slideWidth: void 0,
                  slideHeight: void 0,
                  $imageEl: void 0,
                  $imageWrapEl: void 0,
                  maxRatio: 3,
                },
                image: {
                  isTouched: void 0,
                  isMoved: void 0,
                  currentX: void 0,
                  currentY: void 0,
                  minX: void 0,
                  minY: void 0,
                  maxX: void 0,
                  maxY: void 0,
                  width: void 0,
                  height: void 0,
                  startX: void 0,
                  startY: void 0,
                  touchesStart: {},
                  touchesCurrent: {},
                },
                velocity: {
                  x: void 0,
                  y: void 0,
                  prevPositionX: void 0,
                  prevPositionY: void 0,
                  prevTime: void 0,
                },
              };
            "onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out"
              .split(" ")
              .forEach(function (t) {
                i[t] = H[t].bind(e);
              }),
              R.extend(e, { zoom: i });
          },
          on: {
            init: function () {
              this.params.zoom.enabled && this.zoom.enable();
            },
            destroy: function () {
              this.zoom.disable();
            },
            touchStart: function (t) {
              this.zoom.enabled && this.zoom.onTouchStart(t);
            },
            touchEnd: function (t) {
              this.zoom.enabled && this.zoom.onTouchEnd(t);
            },
            doubleTap: function (t) {
              this.params.zoom.enabled &&
                this.zoom.enabled &&
                this.params.zoom.toggle &&
                this.zoom.toggle(t);
            },
            transitionEnd: function () {
              this.zoom.enabled &&
                this.params.zoom.enabled &&
                this.zoom.onTransitionEnd();
            },
          },
        },
        {
          name: "lazy",
          params: {
            lazy: {
              enabled: !1,
              loadPrevNext: !1,
              loadPrevNextAmount: 1,
              loadOnTransitionStart: !1,
              elementClass: "swiper-lazy",
              loadingClass: "swiper-lazy-loading",
              loadedClass: "swiper-lazy-loaded",
              preloaderClass: "swiper-lazy-preloader",
            },
          },
          create: function () {
            R.extend(this, {
              lazy: {
                initialImageLoaded: !1,
                load: $.load.bind(this),
                loadInSlide: $.loadInSlide.bind(this),
              },
            });
          },
          on: {
            beforeInit: function () {
              this.params.lazy.enabled &&
                this.params.preloadImages &&
                (this.params.preloadImages = !1);
            },
            init: function () {
              this.params.lazy.enabled &&
                !this.params.loop &&
                0 === this.params.initialSlide &&
                this.lazy.load();
            },
            scroll: function () {
              this.params.freeMode &&
                !this.params.freeModeSticky &&
                this.lazy.load();
            },
            resize: function () {
              this.params.lazy.enabled && this.lazy.load();
            },
            scrollbarDragMove: function () {
              this.params.lazy.enabled && this.lazy.load();
            },
            transitionStart: function () {
              var t = this;
              t.params.lazy.enabled &&
                (t.params.lazy.loadOnTransitionStart ||
                  (!t.params.lazy.loadOnTransitionStart &&
                    !t.lazy.initialImageLoaded)) &&
                t.lazy.load();
            },
            transitionEnd: function () {
              this.params.lazy.enabled &&
                !this.params.lazy.loadOnTransitionStart &&
                this.lazy.load();
            },
          },
        },
        {
          name: "controller",
          params: { controller: { control: void 0, inverse: !1, by: "slide" } },
          create: function () {
            var t = this;
            R.extend(t, {
              controller: {
                control: t.params.controller.control,
                getInterpolateFunction: j.getInterpolateFunction.bind(t),
                setTranslate: j.setTranslate.bind(t),
                setTransition: j.setTransition.bind(t),
              },
            });
          },
          on: {
            update: function () {
              this.controller.control &&
                this.controller.spline &&
                ((this.controller.spline = void 0),
                delete this.controller.spline);
            },
            resize: function () {
              this.controller.control &&
                this.controller.spline &&
                ((this.controller.spline = void 0),
                delete this.controller.spline);
            },
            observerUpdate: function () {
              this.controller.control &&
                this.controller.spline &&
                ((this.controller.spline = void 0),
                delete this.controller.spline);
            },
            setTranslate: function (t, e) {
              this.controller.control && this.controller.setTranslate(t, e);
            },
            setTransition: function (t, e) {
              this.controller.control && this.controller.setTransition(t, e);
            },
          },
        },
        {
          name: "a11y",
          params: {
            a11y: {
              enabled: !0,
              notificationClass: "swiper-notification",
              prevSlideMessage: "Previous slide",
              nextSlideMessage: "Next slide",
              firstSlideMessage: "This is the first slide",
              lastSlideMessage: "This is the last slide",
              paginationBulletMessage: "Go to slide {{index}}",
            },
          },
          create: function () {
            var e = this;
            R.extend(e, {
              a11y: {
                liveRegion: F(
                  '<span class="' +
                    e.params.a11y.notificationClass +
                    '" aria-live="assertive" aria-atomic="true"></span>'
                ),
              },
            }),
              Object.keys(G).forEach(function (t) {
                e.a11y[t] = G[t].bind(e);
              });
          },
          on: {
            init: function () {
              this.params.a11y.enabled &&
                (this.a11y.init(), this.a11y.updateNavigation());
            },
            toEdge: function () {
              this.params.a11y.enabled && this.a11y.updateNavigation();
            },
            fromEdge: function () {
              this.params.a11y.enabled && this.a11y.updateNavigation();
            },
            paginationUpdate: function () {
              this.params.a11y.enabled && this.a11y.updatePagination();
            },
            destroy: function () {
              this.params.a11y.enabled && this.a11y.destroy();
            },
          },
        },
        {
          name: "history",
          params: { history: { enabled: !1, replaceState: !1, key: "slides" } },
          create: function () {
            var t = this;
            R.extend(t, {
              history: {
                init: U.init.bind(t),
                setHistory: U.setHistory.bind(t),
                setHistoryPopState: U.setHistoryPopState.bind(t),
                scrollToSlide: U.scrollToSlide.bind(t),
                destroy: U.destroy.bind(t),
              },
            });
          },
          on: {
            init: function () {
              this.params.history.enabled && this.history.init();
            },
            destroy: function () {
              this.params.history.enabled && this.history.destroy();
            },
            transitionEnd: function () {
              this.history.initialized &&
                this.history.setHistory(
                  this.params.history.key,
                  this.activeIndex
                );
            },
          },
        },
        {
          name: "hash-navigation",
          params: {
            hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 },
          },
          create: function () {
            var t = this;
            R.extend(t, {
              hashNavigation: {
                initialized: !1,
                init: q.init.bind(t),
                destroy: q.destroy.bind(t),
                setHash: q.setHash.bind(t),
                onHashCange: q.onHashCange.bind(t),
              },
            });
          },
          on: {
            init: function () {
              this.params.hashNavigation.enabled && this.hashNavigation.init();
            },
            destroy: function () {
              this.params.hashNavigation.enabled &&
                this.hashNavigation.destroy();
            },
            transitionEnd: function () {
              this.hashNavigation.initialized && this.hashNavigation.setHash();
            },
          },
        },
        {
          name: "autoplay",
          params: {
            autoplay: {
              enabled: !1,
              delay: 3e3,
              waitForTransition: !0,
              disableOnInteraction: !0,
              stopOnLastSlide: !1,
              reverseDirection: !1,
            },
          },
          create: function () {
            var e = this;
            R.extend(e, {
              autoplay: {
                running: !1,
                paused: !1,
                run: K.run.bind(e),
                start: K.start.bind(e),
                stop: K.stop.bind(e),
                pause: K.pause.bind(e),
                onTransitionEnd: function (t) {
                  e &&
                    !e.destroyed &&
                    e.$wrapperEl &&
                    t.target === this &&
                    (e.$wrapperEl[0].removeEventListener(
                      "transitionend",
                      e.autoplay.onTransitionEnd
                    ),
                    e.$wrapperEl[0].removeEventListener(
                      "webkitTransitionEnd",
                      e.autoplay.onTransitionEnd
                    ),
                    (e.autoplay.paused = !1),
                    e.autoplay.running ? e.autoplay.run() : e.autoplay.stop());
                },
              },
            });
          },
          on: {
            init: function () {
              this.params.autoplay.enabled && this.autoplay.start();
            },
            beforeTransitionStart: function (t, e) {
              this.autoplay.running &&
                (e || !this.params.autoplay.disableOnInteraction
                  ? this.autoplay.pause(t)
                  : this.autoplay.stop());
            },
            sliderFirstMove: function () {
              this.autoplay.running &&
                (this.params.autoplay.disableOnInteraction
                  ? this.autoplay.stop()
                  : this.autoplay.pause());
            },
            destroy: function () {
              this.autoplay.running && this.autoplay.stop();
            },
          },
        },
        {
          name: "effect-fade",
          params: { fadeEffect: { crossFade: !1 } },
          create: function () {
            R.extend(this, {
              fadeEffect: {
                setTranslate: Q.setTranslate.bind(this),
                setTransition: Q.setTransition.bind(this),
              },
            });
          },
          on: {
            beforeInit: function () {
              var t = this;
              if ("fade" === t.params.effect) {
                t.classNames.push(t.params.containerModifierClass + "fade");
                var e = {
                  slidesPerView: 1,
                  slidesPerColumn: 1,
                  slidesPerGroup: 1,
                  watchSlidesProgress: !0,
                  spaceBetween: 0,
                  virtualTranslate: !0,
                };
                R.extend(t.params, e), R.extend(t.originalParams, e);
              }
            },
            setTranslate: function () {
              "fade" === this.params.effect && this.fadeEffect.setTranslate();
            },
            setTransition: function (t) {
              "fade" === this.params.effect && this.fadeEffect.setTransition(t);
            },
          },
        },
        {
          name: "effect-cube",
          params: {
            cubeEffect: {
              slideShadows: !0,
              shadow: !0,
              shadowOffset: 20,
              shadowScale: 0.94,
            },
          },
          create: function () {
            R.extend(this, {
              cubeEffect: {
                setTranslate: J.setTranslate.bind(this),
                setTransition: J.setTransition.bind(this),
              },
            });
          },
          on: {
            beforeInit: function () {
              var t = this;
              if ("cube" === t.params.effect) {
                t.classNames.push(t.params.containerModifierClass + "cube"),
                  t.classNames.push(t.params.containerModifierClass + "3d");
                var e = {
                  slidesPerView: 1,
                  slidesPerColumn: 1,
                  slidesPerGroup: 1,
                  watchSlidesProgress: !0,
                  resistanceRatio: 0,
                  spaceBetween: 0,
                  centeredSlides: !1,
                  virtualTranslate: !0,
                };
                R.extend(t.params, e), R.extend(t.originalParams, e);
              }
            },
            setTranslate: function () {
              "cube" === this.params.effect && this.cubeEffect.setTranslate();
            },
            setTransition: function (t) {
              "cube" === this.params.effect && this.cubeEffect.setTransition(t);
            },
          },
        },
        {
          name: "effect-flip",
          params: { flipEffect: { slideShadows: !0, limitRotation: !0 } },
          create: function () {
            R.extend(this, {
              flipEffect: {
                setTranslate: Z.setTranslate.bind(this),
                setTransition: Z.setTransition.bind(this),
              },
            });
          },
          on: {
            beforeInit: function () {
              var t = this;
              if ("flip" === t.params.effect) {
                t.classNames.push(t.params.containerModifierClass + "flip"),
                  t.classNames.push(t.params.containerModifierClass + "3d");
                var e = {
                  slidesPerView: 1,
                  slidesPerColumn: 1,
                  slidesPerGroup: 1,
                  watchSlidesProgress: !0,
                  spaceBetween: 0,
                  virtualTranslate: !0,
                };
                R.extend(t.params, e), R.extend(t.originalParams, e);
              }
            },
            setTranslate: function () {
              "flip" === this.params.effect && this.flipEffect.setTranslate();
            },
            setTransition: function (t) {
              "flip" === this.params.effect && this.flipEffect.setTransition(t);
            },
          },
        },
        {
          name: "effect-coverflow",
          params: {
            coverflowEffect: {
              rotate: 50,
              stretch: 0,
              depth: 100,
              modifier: 1,
              slideShadows: !0,
            },
          },
          create: function () {
            R.extend(this, {
              coverflowEffect: {
                setTranslate: tt.setTranslate.bind(this),
                setTransition: tt.setTransition.bind(this),
              },
            });
          },
          on: {
            beforeInit: function () {
              var t = this;
              "coverflow" === t.params.effect &&
                (t.classNames.push(
                  t.params.containerModifierClass + "coverflow"
                ),
                t.classNames.push(t.params.containerModifierClass + "3d"),
                (t.params.watchSlidesProgress = !0),
                (t.originalParams.watchSlidesProgress = !0));
            },
            setTranslate: function () {
              "coverflow" === this.params.effect &&
                this.coverflowEffect.setTranslate();
            },
            setTransition: function (t) {
              "coverflow" === this.params.effect &&
                this.coverflowEffect.setTransition(t);
            },
          },
        },
        {
          name: "thumbs",
          params: {
            thumbs: {
              swiper: null,
              slideThumbActiveClass: "swiper-slide-thumb-active",
              thumbsContainerClass: "swiper-container-thumbs",
            },
          },
          create: function () {
            R.extend(this, {
              thumbs: {
                swiper: null,
                init: et.init.bind(this),
                update: et.update.bind(this),
                onThumbClick: et.onThumbClick.bind(this),
              },
            });
          },
          on: {
            beforeInit: function () {
              var t = this.params.thumbs;
              t && t.swiper && (this.thumbs.init(), this.thumbs.update(!0));
            },
            slideChange: function () {
              this.thumbs.swiper && this.thumbs.update();
            },
            update: function () {
              this.thumbs.swiper && this.thumbs.update();
            },
            resize: function () {
              this.thumbs.swiper && this.thumbs.update();
            },
            observerUpdate: function () {
              this.thumbs.swiper && this.thumbs.update();
            },
            setTransition: function (t) {
              var e = this.thumbs.swiper;
              e && e.setTransition(t);
            },
            beforeDestroy: function () {
              var t = this.thumbs.swiper;
              t && this.thumbs.swiperCreated && t && t.destroy();
            },
          },
        },
      ];
    return (
      void 0 === w.use &&
        ((w.use = w.Class.use), (w.installModule = w.Class.installModule)),
      w.use(it),
      w
    );
  }),
  (function () {
    function t(t, e) {
      (t.prototype = (function (t) {
        function e() {}
        return (e.prototype = t), new e();
      })(e.prototype)),
        ((t.prototype.constructor = t).base = e.prototype);
    }
    function b(t, e, i) {
      return (
        "millisecond" === i
          ? t.setMilliseconds(t.getMilliseconds() + 1 * e)
          : "second" === i
          ? t.setSeconds(t.getSeconds() + 1 * e)
          : "minute" === i
          ? t.setMinutes(t.getMinutes() + 1 * e)
          : "hour" === i
          ? t.setHours(t.getHours() + 1 * e)
          : "day" === i
          ? t.setDate(t.getDate() + 1 * e)
          : "week" === i
          ? t.setDate(t.getDate() + 7 * e)
          : "month" === i
          ? t.setMonth(t.getMonth() + 1 * e)
          : "year" === i && t.setFullYear(t.getFullYear() + 1 * e),
        t
      );
    }
    function v(t, e) {
      var i = !1;
      for (
        t < 0 && ((i = !0), (t *= -1)), t = "" + t, e = e || 1;
        t.length < e;

      )
        t = "0" + t;
      return i ? "-" + t : t;
    }
    function g(t) {
      if (!t) return t;
      for (
        var e = /\s/, i = (t = t.replace(/^\s\s*/, "")).length;
        e.test(t.charAt(--i));

      );
      return t.slice(0, i + 1);
    }
    function G(t) {
      t.roundRect = function (t, e, i, a, s, n, o, r) {
        o && (this.fillStyle = o),
          r && (this.strokeStyle = r),
          void 0 === s && (s = 5),
          (this.lineWidth = n),
          this.beginPath(),
          this.moveTo(t + s, e),
          this.lineTo(t + i - s, e),
          this.quadraticCurveTo(t + i, e, t + i, e + s),
          this.lineTo(t + i, e + a - s),
          this.quadraticCurveTo(t + i, e + a, t + i - s, e + a),
          this.lineTo(t + s, e + a),
          this.quadraticCurveTo(t, e + a, t, e + a - s),
          this.lineTo(t, e + s),
          this.quadraticCurveTo(t, e, t + s, e),
          this.closePath(),
          o && this.fill(),
          r && 0 < n && this.stroke();
      };
    }
    function E(t, e) {
      return t - e;
    }
    function N(t) {
      var e = ((16711680 & t) >> 16).toString(16),
        i = ((65280 & t) >> 8).toString(16);
      return (
        (t = ((255 & t) >> 0).toString(16)),
        "#" +
          (e = e.length < 2 ? "0" + e : e) +
          (i = i.length < 2 ? "0" + i : i) +
          (t = t.length < 2 ? "0" + t : t)
      );
    }
    function e(t, e) {
      var i,
        a = this.length >>> 0;
      for (
        (i = (i = Number(e) || 0) < 0 ? Math.ceil(i) : Math.floor(i)) < 0 &&
        (i += a);
        i < a;
        i++
      )
        if (i in this && this[i] === t) return i;
      return -1;
    }
    function U(t) {
      return null == t;
    }
    function q(t) {
      return t.indexOf || (t.indexOf = e), t;
    }
    function a(t, e, i) {
      var a = t + "_" + e + "_" + (i = i || "normal"),
        s = j[a];
      if (isNaN(s)) {
        try {
          if (
            ((t =
              "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" +
              t +
              "; font-size:" +
              e +
              "px; font-weight:" +
              i +
              ";"),
            !et)
          ) {
            var n = document.body;
            (et = document.createElement("span")).innerHTML = "";
            var o = document.createTextNode("Mpgyi");
            et.appendChild(o), n.appendChild(et);
          }
          (et.style.display = ""),
            et.setAttribute("style", t),
            (s = Math.round(et.offsetHeight)),
            (et.style.display = "none");
        } catch (t) {
          s = Math.ceil(1.1 * e);
        }
        (s = Math.max(s, e)), (j[a] = s);
      }
      return s;
    }
    function K(t, e) {
      var i = [];
      if (
        (i = {
          solid: [],
          shortDash: [3, 1],
          shortDot: [1, 1],
          shortDashDot: [3, 1, 1, 1],
          shortDashDotDot: [3, 1, 1, 1, 1, 1],
          dot: [1, 2],
          dash: [4, 2],
          dashDot: [4, 2, 1, 2],
          longDash: [8, 2],
          longDashDot: [8, 2, 1, 2],
          longDashDotDot: [8, 2, 1, 2, 1, 2],
        }[t || "solid"])
      )
        for (var a = 0; a < i.length; a++) i[a] *= e;
      else i = [];
      return i;
    }
    function f(e, t, i, a, s) {
      return (
        (s = s || !1),
        (a = a || []).push([e, t, i, s]),
        e.addEventListener
          ? (e.addEventListener(t, i, s), i)
          : !!e.attachEvent &&
            ((a = function (t) {
              ((t = t || window.event).preventDefault =
                t.preventDefault ||
                function () {
                  t.returnValue = !1;
                }),
                (t.stopPropagation =
                  t.stopPropagation ||
                  function () {
                    t.cancelBubble = !0;
                  }),
                i.call(e, t);
            }),
            e.attachEvent("on" + t, a),
            a)
      );
    }
    function y(t, e, i) {
      for (
        t *= lt, e *= lt, t = i.getImageData(t, e, 2, 2).data, e = !0, i = 0;
        i < 4;
        i++
      )
        if ((t[i] !== t[i + 4]) | (t[i] !== t[i + 8]) | (t[i] !== t[i + 12])) {
          e = !1;
          break;
        }
      return e ? (t[0] << 16) | (t[1] << 8) | t[2] : 0;
    }
    function C(t, e, i) {
      return t in e ? e[t] : i[t];
    }
    function M(t, e, i) {
      if (Z && nt) {
        var a = t.getContext("2d");
        (rt =
          a.webkitBackingStorePixelRatio ||
          a.mozBackingStorePixelRatio ||
          a.msBackingStorePixelRatio ||
          a.oBackingStorePixelRatio ||
          a.backingStorePixelRatio ||
          1),
          (lt = ot / rt),
          (t.width = e * lt),
          (t.height = i * lt),
          ot !== rt &&
            ((t.style.width = e + "px"),
            (t.style.height = i + "px"),
            a.scale(lt, lt));
      } else (t.width = e), (t.height = i);
    }
    function k(t, e) {
      var i = document.createElement("canvas");
      return (
        i.setAttribute("class", "canvasjs-chart-canvas"),
        M(i, t, e),
        Z ||
          "undefined" == typeof G_vmlCanvasManager ||
          G_vmlCanvasManager.initElement(i),
        i
      );
    }
    function w(t, e, i) {
      for (var a in i) e.style[a] = i[a];
    }
    function P(t, e, i) {
      e.getAttribute("state") ||
        ((e.style.backgroundColor = t.toolbar.backgroundColor),
        (e.style.color = t.toolbar.fontColor),
        (e.style.border = "none"),
        w(0, e, {
          WebkitUserSelect: "none",
          MozUserSelect: "none",
          msUserSelect: "none",
          userSelect: "none",
        })),
        e.getAttribute("state") !== i &&
          (e.setAttribute("state", i),
          e.setAttribute("type", "button"),
          w(0, e, {
            padding: "5px 12px",
            cursor: "pointer",
            float: "left",
            width: "40px",
            height: "25px",
            outline: "0px",
            verticalAlign: "baseline",
            lineHeight: "0",
          }),
          e.setAttribute("title", t._cultureInfo[i + "Text"]),
          (e.innerHTML =
            "<img style='height:95%;' src='" +
            pt[i].image +
            "' alt='" +
            t._cultureInfo[i + "Text"] +
            "' />"));
    }
    function S() {
      for (var t = null, e = 0; e < arguments.length; e++)
        (t = arguments[e]).style && (t.style.display = "inline");
    }
    function F() {
      for (var t = null, e = 0; e < arguments.length; e++)
        (t = arguments[e]) && t.style && (t.style.display = "none");
    }
    function L(t, e, i, a, s) {
      (this._defaultsKey = t),
        (this._themeOptionsKey = e),
        (this._index = a),
        (this.parent = s),
        (this._eventListeners = []),
        (t = {}),
        this.theme && U(e) && U(a)
          ? (t = U(H[this.theme]) ? H.light1 : H[this.theme])
          : this.parent &&
            this.parent.themeOptions &&
            this.parent.themeOptions[e] &&
            (null === a
              ? (t = this.parent.themeOptions[e])
              : 0 < this.parent.themeOptions[e].length &&
                ((a = Math.min(this.parent.themeOptions[e].length - 1, a)),
                (t = this.parent.themeOptions[e][a]))),
        (this.themeOptions = t),
        (this.options = i || { _isPlaceholder: !0 }),
        this.setOptions(this.options, t);
    }
    function D(t, e, i, a, s) {
      void 0 === s && (s = 0),
        (this._padding = s),
        (this._x1 = t),
        (this._y1 = e),
        (this._x2 = i),
        (this._y2 = a),
        (this._rightOccupied =
          this._leftOccupied =
          this._bottomOccupied =
          this._topOccupied =
            this._padding);
    }
    function Q(t, e) {
      Q.base.constructor.call(this, "TextBlock", null, e, null, null),
        (this.ctx = t),
        (this._isDirty = !0),
        (this._wrappedText = null),
        this._initialize();
    }
    function V(t, e) {
      V.base.constructor.call(this, "Toolbar", "toolbar", e, null, t),
        (this.chart = t),
        (this.canvas = t.canvas),
        (this.ctx = this.chart.ctx),
        (this.optionsName = "toolbar");
    }
    function z(t, e) {
      if (
        (z.base.constructor.call(this, "Title", "title", e, null, t),
        (this.chart = t),
        (this.canvas = t.canvas),
        (this.ctx = this.chart.ctx),
        (this.optionsName = "title"),
        U(this.options.margin) && t.options.subtitles)
      )
        for (var i = t.options.subtitles, a = 0; a < i.length; a++)
          if (
            ((U(i[a].horizontalAlign) && "center" === this.horizontalAlign) ||
              i[a].horizontalAlign === this.horizontalAlign) &&
            ((U(i[a].verticalAlign) && "top" === this.verticalAlign) ||
              i[a].verticalAlign === this.verticalAlign) &&
            !i[a].dockInsidePlotArea == !this.dockInsidePlotArea
          ) {
            this.margin = 0;
            break;
          }
      void 0 === this.options.fontSize &&
        (this.fontSize = this.chart.getAutoFontSize(this.fontSize)),
        (this.height = this.width = null),
        (this.bounds = { x1: null, y1: null, x2: null, y2: null });
    }
    function W(t, e, i) {
      W.base.constructor.call(this, "Subtitle", "subtitles", e, i, t),
        (this.chart = t),
        (this.canvas = t.canvas),
        (this.ctx = this.chart.ctx),
        (this.optionsName = "subtitles"),
        (this.isOptionsInArray = !0),
        void 0 === this.options.fontSize &&
          (this.fontSize = this.chart.getAutoFontSize(this.fontSize)),
        (this.height = this.width = null),
        (this.bounds = { x1: null, y1: null, x2: null, y2: null });
    }
    function X(t) {
      var e;
      t && h[t] && (e = h[t]),
        X.base.constructor.call(this, "CultureInfo", null, e, null, null);
    }
    var s,
      n,
      o,
      r,
      l,
      J = {},
      Z = !!document.createElement("canvas").getContext,
      Y = {
        Chart: {
          width: 500,
          height: 400,
          zoomEnabled: !1,
          zoomType: "x",
          backgroundColor: "white",
          theme: "light1",
          animationEnabled: !1,
          animationDuration: 1200,
          dataPointWidth: null,
          dataPointMinWidth: null,
          dataPointMaxWidth: null,
          colorSet: "colorSet1",
          culture: "en",
          creditHref: "",
          creditText: "CanvasJS",
          interactivityEnabled: !0,
          exportEnabled: !1,
          exportFileName: "Chart",
          rangeChanging: null,
          rangeChanged: null,
          publicProperties: {
            title: "readWrite",
            subtitles: "readWrite",
            toolbar: "readWrite",
            toolTip: "readWrite",
            legend: "readWrite",
            axisX: "readWrite",
            axisY: "readWrite",
            axisX2: "readWrite",
            axisY2: "readWrite",
            data: "readWrite",
            options: "readWrite",
            bounds: "readOnly",
            container: "readOnly",
          },
        },
        Title: {
          padding: 0,
          text: null,
          verticalAlign: "top",
          horizontalAlign: "center",
          fontSize: 20,
          fontFamily: "Calibri",
          fontWeight: "normal",
          fontColor: "black",
          fontStyle: "normal",
          borderThickness: 0,
          borderColor: "black",
          cornerRadius: 0,
          backgroundColor: Z ? "transparent" : null,
          margin: 5,
          wrap: !0,
          maxWidth: null,
          dockInsidePlotArea: !1,
          publicProperties: {
            options: "readWrite",
            bounds: "readOnly",
            chart: "readOnly",
          },
        },
        Subtitle: {
          padding: 0,
          text: null,
          verticalAlign: "top",
          horizontalAlign: "center",
          fontSize: 14,
          fontFamily: "Calibri",
          fontWeight: "normal",
          fontColor: "black",
          fontStyle: "normal",
          borderThickness: 0,
          borderColor: "black",
          cornerRadius: 0,
          backgroundColor: null,
          margin: 2,
          wrap: !0,
          maxWidth: null,
          dockInsidePlotArea: !1,
          publicProperties: {
            options: "readWrite",
            bounds: "readOnly",
            chart: "readOnly",
          },
        },
        Toolbar: {
          backgroundColor: "white",
          backgroundColorOnHover: "#2196f3",
          borderColor: "#2196f3",
          borderThickness: 1,
          fontColor: "black",
          fontColorOnHover: "white",
          publicProperties: { options: "readWrite", chart: "readOnly" },
        },
        Legend: {
          name: null,
          verticalAlign: "center",
          horizontalAlign: "right",
          fontSize: 14,
          fontFamily: "calibri",
          fontWeight: "normal",
          fontColor: "black",
          fontStyle: "normal",
          cursor: null,
          itemmouseover: null,
          itemmouseout: null,
          itemmousemove: null,
          itemclick: null,
          dockInsidePlotArea: !1,
          reversed: !1,
          backgroundColor: Z ? "transparent" : null,
          borderColor: Z ? "transparent" : null,
          borderThickness: 0,
          cornerRadius: 0,
          maxWidth: null,
          maxHeight: null,
          markerMargin: null,
          itemMaxWidth: null,
          itemWidth: null,
          itemWrap: !0,
          itemTextFormatter: null,
          publicProperties: {
            options: "readWrite",
            bounds: "readOnly",
            chart: "readOnly",
          },
        },
        ToolTip: {
          enabled: !0,
          shared: !1,
          animationEnabled: !0,
          content: null,
          contentFormatter: null,
          reversed: !1,
          backgroundColor: Z ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",
          borderColor: null,
          borderThickness: 2,
          cornerRadius: 5,
          fontSize: 14,
          fontColor: "black",
          fontFamily: "Calibri, Arial, Georgia, serif;",
          fontWeight: "normal",
          fontStyle: "italic",
          publicProperties: { options: "readWrite", chart: "readOnly" },
        },
        Axis: {
          minimum: null,
          maximum: null,
          viewportMinimum: null,
          viewportMaximum: null,
          interval: null,
          intervalType: null,
          reversed: !1,
          logarithmic: !1,
          logarithmBase: 10,
          title: null,
          titleFontColor: "black",
          titleFontSize: 20,
          titleFontFamily: "arial",
          titleFontWeight: "normal",
          titleFontStyle: "normal",
          titleWrap: !0,
          titleMaxWidth: null,
          titleBackgroundColor: Z ? "transparent" : null,
          titleBorderColor: Z ? "transparent" : null,
          titleBorderThickness: 0,
          titleCornerRadius: 0,
          labelAngle: 0,
          labelFontFamily: "arial",
          labelFontColor: "black",
          labelFontSize: 12,
          labelFontWeight: "normal",
          labelFontStyle: "normal",
          labelAutoFit: !0,
          labelWrap: !0,
          labelMaxWidth: null,
          labelFormatter: null,
          labelBackgroundColor: Z ? "transparent" : null,
          labelBorderColor: Z ? "transparent" : null,
          labelBorderThickness: 0,
          labelCornerRadius: 0,
          labelPlacement: "outside",
          prefix: "",
          suffix: "",
          includeZero: !0,
          tickLength: 5,
          tickColor: "black",
          tickThickness: 1,
          lineColor: "black",
          lineThickness: 1,
          lineDashType: "solid",
          gridColor: "A0A0A0",
          gridThickness: 0,
          gridDashType: "solid",
          interlacedColor: Z ? "transparent" : null,
          valueFormatString: null,
          margin: 2,
          publicProperties: {
            options: "readWrite",
            stripLines: "readWrite",
            scaleBreaks: "readWrite",
            crosshair: "readWrite",
            bounds: "readOnly",
            chart: "readOnly",
          },
        },
        StripLine: {
          value: null,
          startValue: null,
          endValue: null,
          color: "orange",
          opacity: null,
          thickness: 2,
          lineDashType: "solid",
          label: "",
          labelPlacement: "inside",
          labelAlign: "far",
          labelWrap: !0,
          labelMaxWidth: null,
          labelBackgroundColor: null,
          labelBorderColor: Z ? "transparent" : null,
          labelBorderThickness: 0,
          labelCornerRadius: 0,
          labelFontFamily: "arial",
          labelFontColor: "orange",
          labelFontSize: 12,
          labelFontWeight: "normal",
          labelFontStyle: "normal",
          labelFormatter: null,
          showOnTop: !1,
          publicProperties: {
            options: "readWrite",
            axis: "readOnly",
            bounds: "readOnly",
            chart: "readOnly",
          },
        },
        ScaleBreaks: {
          autoCalculate: !1,
          collapsibleThreshold: "25%",
          maxNumberOfAutoBreaks: 2,
          spacing: 8,
          type: "straight",
          color: "#FFFFFF",
          fillOpacity: 0.9,
          lineThickness: 2,
          lineColor: "#E16E6E",
          lineDashType: "solid",
          publicProperties: {
            options: "readWrite",
            customBreaks: "readWrite",
            axis: "readOnly",
            autoBreaks: "readOnly",
            bounds: "readOnly",
            chart: "readOnly",
          },
        },
        Break: {
          startValue: null,
          endValue: null,
          spacing: 8,
          type: "straight",
          color: "#FFFFFF",
          fillOpacity: 0.9,
          lineThickness: 2,
          lineColor: "#E16E6E",
          lineDashType: "solid",
          publicProperties: {
            options: "readWrite",
            scaleBreaks: "readOnly",
            bounds: "readOnly",
            chart: "readOnly",
          },
        },
        Crosshair: {
          enabled: !1,
          snapToDataPoint: !1,
          color: "grey",
          opacity: null,
          thickness: 2,
          lineDashType: "solid",
          label: "",
          labelWrap: !0,
          labelMaxWidth: null,
          labelBackgroundColor: Z ? "grey" : null,
          labelBorderColor: Z ? "grey" : null,
          labelBorderThickness: 0,
          labelCornerRadius: 0,
          labelFontFamily: Z
            ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif"
            : "calibri",
          labelFontSize: 12,
          labelFontColor: "#fff",
          labelFontWeight: "normal",
          labelFontStyle: "normal",
          labelFormatter: null,
          valueFormatString: null,
          publicProperties: {
            options: "readWrite",
            axis: "readOnly",
            bounds: "readOnly",
            chart: "readOnly",
          },
        },
        DataSeries: {
          name: null,
          dataPoints: null,
          label: "",
          bevelEnabled: !1,
          highlightEnabled: !0,
          cursor: "default",
          indexLabel: "",
          indexLabelPlacement: "auto",
          indexLabelOrientation: "horizontal",
          indexLabelFontColor: "black",
          indexLabelFontSize: 12,
          indexLabelFontStyle: "normal",
          indexLabelFontFamily: "Arial",
          indexLabelFontWeight: "normal",
          indexLabelBackgroundColor: null,
          indexLabelLineColor: "gray",
          indexLabelLineThickness: 1,
          indexLabelLineDashType: "solid",
          indexLabelMaxWidth: null,
          indexLabelWrap: !0,
          indexLabelFormatter: null,
          lineThickness: 2,
          lineDashType: "solid",
          connectNullData: !1,
          nullDataLineDashType: "dash",
          color: null,
          lineColor: null,
          risingColor: "white",
          fallingColor: "red",
          fillOpacity: null,
          startAngle: 0,
          radius: null,
          innerRadius: null,
          neckHeight: null,
          neckWidth: null,
          reversed: !1,
          valueRepresents: null,
          linkedDataSeriesIndex: null,
          whiskerThickness: 2,
          whiskerDashType: "solid",
          whiskerColor: null,
          whiskerLength: null,
          stemThickness: 2,
          stemColor: null,
          stemDashType: "solid",
          upperBoxColor: "white",
          lowerBoxColor: "white",
          type: "column",
          xValueType: "number",
          axisXType: "primary",
          axisYType: "primary",
          axisXIndex: 0,
          axisYIndex: 0,
          xValueFormatString: null,
          yValueFormatString: null,
          zValueFormatString: null,
          percentFormatString: null,
          showInLegend: null,
          legendMarkerType: null,
          legendMarkerColor: null,
          legendText: null,
          legendMarkerBorderColor: Z ? "transparent" : null,
          legendMarkerBorderThickness: 0,
          markerType: "circle",
          markerColor: null,
          markerSize: null,
          markerBorderColor: Z ? "transparent" : null,
          markerBorderThickness: 0,
          mouseover: null,
          mouseout: null,
          mousemove: null,
          click: null,
          toolTipContent: null,
          visible: !0,
          publicProperties: {
            options: "readWrite",
            axisX: "readWrite",
            axisY: "readWrite",
            chart: "readOnly",
          },
        },
        TextBlock: {
          x: 0,
          y: 0,
          width: null,
          height: null,
          maxWidth: null,
          maxHeight: null,
          padding: 0,
          angle: 0,
          text: "",
          horizontalAlign: "center",
          fontSize: 12,
          fontFamily: "calibri",
          fontWeight: "normal",
          fontColor: "black",
          fontStyle: "normal",
          borderThickness: 0,
          borderColor: "black",
          cornerRadius: 0,
          backgroundColor: null,
          textBaseline: "top",
        },
        CultureInfo: {
          decimalSeparator: ".",
          digitGroupSeparator: ",",
          zoomText: "Zoom",
          panText: "Pan",
          resetText: "Reset",
          menuText: "More Options",
          saveJPGText: "Save as JPEG",
          savePNGText: "Save as PNG",
          printText: "Print",
          days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
            " "
          ),
          shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
          months:
            "January February March April May June July August September October November December".split(
              " "
            ),
          shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(
            " "
          ),
        },
      },
      h = { en: {} },
      d = Z ? "Trebuchet MS, Helvetica, sans-serif" : "Arial",
      c = Z ? "Impact, Charcoal, sans-serif" : "Arial",
      O = {
        colorSet1:
          "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(
            " "
          ),
        colorSet2:
          "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(
            " "
          ),
        colorSet3:
          "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(
            " "
          ),
      },
      p = {
        colorSet: "colorSet1",
        backgroundColor: "#FFFFFF",
        title: {
          fontFamily: c,
          fontSize: 32,
          fontColor: (n = "#333333"),
          fontWeight: "normal",
          verticalAlign: "top",
          margin: 5,
        },
        subtitles: [
          {
            fontFamily: c,
            fontSize: (m = 14),
            fontColor: n,
            fontWeight: "normal",
            verticalAlign: "top",
            margin: 5,
          },
        ],
        data: [
          {
            indexLabelFontFamily: d,
            indexLabelFontSize: m,
            indexLabelFontColor: n,
            indexLabelFontWeight: "normal",
            indexLabelLineThickness: 1,
          },
        ],
        axisX: [
          {
            titleFontFamily: d,
            titleFontSize: (x = 20),
            titleFontColor: n,
            titleFontWeight: "normal",
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: (o = "#000000"),
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: (s = "#666666"),
            tickThickness: 1,
            tickColor: s,
            gridThickness: 0,
            gridColor: s,
            stripLines: [
              {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1,
              },
            ],
            crosshair: {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#EEEEEE",
              labelFontWeight: "normal",
              labelBackgroundColor: (l = r = "#000000"),
              color: r,
              thickness: 1,
              lineDashType: "dash",
            },
            scaleBreaks: {
              type: "zigzag",
              spacing: "2%",
              lineColor: "#BBBBBB",
              lineThickness: 1,
              lineDashType: "solid",
            },
          },
        ],
        axisX2: [
          {
            titleFontFamily: d,
            titleFontSize: x,
            titleFontColor: n,
            titleFontWeight: "normal",
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: o,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: s,
            tickThickness: 1,
            tickColor: s,
            gridThickness: 0,
            gridColor: s,
            stripLines: [
              {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1,
              },
            ],
            crosshair: {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#EEEEEE",
              labelFontWeight: "normal",
              labelBackgroundColor: l,
              color: r,
              thickness: 1,
              lineDashType: "dash",
            },
            scaleBreaks: {
              type: "zigzag",
              spacing: "2%",
              lineColor: "#BBBBBB",
              lineThickness: 1,
              lineDashType: "solid",
            },
          },
        ],
        axisY: [
          {
            titleFontFamily: d,
            titleFontSize: x,
            titleFontColor: n,
            titleFontWeight: "normal",
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: o,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: s,
            tickThickness: 1,
            tickColor: s,
            gridThickness: 1,
            gridColor: s,
            stripLines: [
              {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1,
              },
            ],
            crosshair: {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#EEEEEE",
              labelFontWeight: "normal",
              labelBackgroundColor: l,
              color: r,
              thickness: 1,
              lineDashType: "dash",
            },
            scaleBreaks: {
              type: "zigzag",
              spacing: "2%",
              lineColor: "#BBBBBB",
              lineThickness: 1,
              lineDashType: "solid",
            },
          },
        ],
        axisY2: [
          {
            titleFontFamily: d,
            titleFontSize: x,
            titleFontColor: n,
            titleFontWeight: "normal",
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: o,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: s,
            tickThickness: 1,
            tickColor: s,
            gridThickness: 1,
            gridColor: s,
            stripLines: [
              {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1,
              },
            ],
            crosshair: {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#EEEEEE",
              labelFontWeight: "normal",
              labelBackgroundColor: l,
              color: r,
              thickness: 1,
              lineDashType: "dash",
            },
            scaleBreaks: {
              type: "zigzag",
              spacing: "2%",
              lineColor: "#BBBBBB",
              lineThickness: 1,
              lineDashType: "solid",
            },
          },
        ],
        legend: {
          fontFamily: d,
          fontSize: 14,
          fontColor: n,
          fontWeight: "bold",
          verticalAlign: "bottom",
          horizontalAlign: "center",
        },
        toolTip: {
          fontFamily: d,
          fontSize: 14,
          fontStyle: "normal",
          cornerRadius: 0,
          borderThickness: 1,
        },
      };
    o = n = "#F5F5F5";
    var u = {
      colorSet: "colorSet2",
      title: {
        fontFamily: d,
        fontSize: 33,
        fontColor: "#3A3A3A",
        fontWeight: "bold",
        verticalAlign: "top",
        margin: 5,
      },
      subtitles: [
        {
          fontFamily: d,
          fontSize: (m = 14),
          fontColor: "#3A3A3A",
          fontWeight: "normal",
          verticalAlign: "top",
          margin: 5,
        },
      ],
      data: [
        {
          indexLabelFontFamily: d,
          indexLabelFontSize: m,
          indexLabelFontColor: "#666666",
          indexLabelFontWeight: "normal",
          indexLabelLineThickness: 1,
        },
      ],
      axisX: [
        {
          titleFontFamily: d,
          titleFontSize: (x = 20),
          titleFontColor: "#666666",
          titleFontWeight: "normal",
          labelFontFamily: d,
          labelFontSize: m,
          labelFontColor: "#666666",
          labelFontWeight: "normal",
          lineThickness: 1,
          lineColor: "#BBBBBB",
          tickThickness: 1,
          tickColor: "#BBBBBB",
          gridThickness: 1,
          gridColor: "#BBBBBB",
          stripLines: [
            {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#FFA500",
              labelFontWeight: "normal",
              labelBackgroundColor: null,
              color: "#FFA500",
              thickness: 1,
            },
          ],
          crosshair: {
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: "#EEEEEE",
            labelFontWeight: "normal",
            labelBackgroundColor: "black",
            color: "black",
            thickness: 1,
            lineDashType: "dot",
          },
          scaleBreaks: {
            type: "zigzag",
            spacing: "2%",
            lineColor: "#BBBBBB",
            lineThickness: 1,
            lineDashType: "solid",
          },
        },
      ],
      axisX2: [
        {
          titleFontFamily: d,
          titleFontSize: x,
          titleFontColor: "#666666",
          titleFontWeight: "normal",
          labelFontFamily: d,
          labelFontSize: m,
          labelFontColor: "#666666",
          labelFontWeight: "normal",
          lineThickness: 1,
          lineColor: "#BBBBBB",
          tickColor: "#BBBBBB",
          tickThickness: 1,
          gridThickness: 1,
          gridColor: "#BBBBBB",
          stripLines: [
            {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#FFA500",
              labelFontWeight: "normal",
              labelBackgroundColor: null,
              color: "#FFA500",
              thickness: 1,
            },
          ],
          crosshair: {
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: "#EEEEEE",
            labelFontWeight: "normal",
            labelBackgroundColor: "black",
            color: "black",
            thickness: 1,
            lineDashType: "dot",
          },
          scaleBreaks: {
            type: "zigzag",
            spacing: "2%",
            lineColor: "#BBBBBB",
            lineThickness: 1,
            lineDashType: "solid",
          },
        },
      ],
      axisY: [
        {
          titleFontFamily: d,
          titleFontSize: x,
          titleFontColor: "#666666",
          titleFontWeight: "normal",
          labelFontFamily: d,
          labelFontSize: m,
          labelFontColor: "#666666",
          labelFontWeight: "normal",
          lineThickness: 0,
          lineColor: "#BBBBBB",
          tickColor: "#BBBBBB",
          tickThickness: 1,
          gridThickness: 1,
          gridColor: "#BBBBBB",
          stripLines: [
            {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#FFA500",
              labelFontWeight: "normal",
              labelBackgroundColor: null,
              color: "#FFA500",
              thickness: 1,
            },
          ],
          crosshair: {
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: "#EEEEEE",
            labelFontWeight: "normal",
            labelBackgroundColor: "black",
            color: "black",
            thickness: 1,
            lineDashType: "dot",
          },
          scaleBreaks: {
            type: "zigzag",
            spacing: "2%",
            lineColor: "#BBBBBB",
            lineThickness: 1,
            lineDashType: "solid",
          },
        },
      ],
      axisY2: [
        {
          titleFontFamily: d,
          titleFontSize: x,
          titleFontColor: "#666666",
          titleFontWeight: "normal",
          labelFontFamily: d,
          labelFontSize: m,
          labelFontColor: "#666666",
          labelFontWeight: "normal",
          lineThickness: 0,
          lineColor: "#BBBBBB",
          tickColor: "#BBBBBB",
          tickThickness: 1,
          gridThickness: 1,
          gridColor: "#BBBBBB",
          stripLines: [
            {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#FFA500",
              labelFontWeight: "normal",
              labelBackgroundColor: null,
              color: "#FFA500",
              thickness: 1,
            },
          ],
          crosshair: {
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: "#EEEEEE",
            labelFontWeight: "normal",
            labelBackgroundColor: "black",
            color: "black",
            thickness: 1,
            lineDashType: "dot",
          },
          scaleBreaks: {
            type: "zigzag",
            spacing: "2%",
            lineColor: "#BBBBBB",
            lineThickness: 1,
            lineDashType: "solid",
          },
        },
      ],
      legend: {
        fontFamily: d,
        fontSize: 14,
        fontColor: "#3A3A3A",
        fontWeight: "bold",
        verticalAlign: "bottom",
        horizontalAlign: "center",
      },
      toolTip: {
        fontFamily: d,
        fontSize: 14,
        fontStyle: "normal",
        cornerRadius: 0,
        borderThickness: 1,
      },
    };
    (o = n = l = "#F5F5F5"),
      (c = {
        colorSet: "colorSet12",
        backgroundColor: "#2A2A2A",
        title: {
          fontFamily: c,
          fontSize: 32,
          fontColor: n,
          fontWeight: "normal",
          verticalAlign: "top",
          margin: 5,
        },
        subtitles: [
          {
            fontFamily: c,
            fontSize: (m = 14),
            fontColor: n,
            fontWeight: "normal",
            verticalAlign: "top",
            margin: 5,
          },
        ],
        toolbar: {
          backgroundColor: "#666666",
          backgroundColorOnHover: "#FF7372",
          borderColor: "#FF7372",
          borderThickness: 1,
          fontColor: (l = "#F5F5F5"),
          fontColorOnHover: "#F5F5F5",
        },
        data: [
          {
            indexLabelFontFamily: d,
            indexLabelFontSize: m,
            indexLabelFontColor: o,
            indexLabelFontWeight: "normal",
            indexLabelLineThickness: 1,
          },
        ],
        axisX: [
          {
            titleFontFamily: d,
            titleFontSize: (x = 20),
            titleFontColor: o,
            titleFontWeight: "normal",
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: o,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: (s = s = "#FFFFFF"),
            tickThickness: 1,
            tickColor: s,
            gridThickness: 0,
            gridColor: s,
            stripLines: [
              {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1,
              },
            ],
            crosshair: {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#000000",
              labelFontWeight: "normal",
              labelBackgroundColor: l,
              color: (r = r = "#40BAF1"),
              thickness: 1,
              lineDashType: "dash",
            },
            scaleBreaks: {
              type: "zigzag",
              spacing: "2%",
              lineColor: "#777777",
              lineThickness: 1,
              lineDashType: "solid",
              color: "#111111",
            },
          },
        ],
        axisX2: [
          {
            titleFontFamily: d,
            titleFontSize: x,
            titleFontColor: o,
            titleFontWeight: "normal",
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: o,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: s,
            tickThickness: 1,
            tickColor: s,
            gridThickness: 0,
            gridColor: s,
            stripLines: [
              {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1,
              },
            ],
            crosshair: {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#000000",
              labelFontWeight: "normal",
              labelBackgroundColor: l,
              color: r,
              thickness: 1,
              lineDashType: "dash",
            },
            scaleBreaks: {
              type: "zigzag",
              spacing: "2%",
              lineColor: "#777777",
              lineThickness: 1,
              lineDashType: "solid",
              color: "#111111",
            },
          },
        ],
        axisY: [
          {
            titleFontFamily: d,
            titleFontSize: x,
            titleFontColor: o,
            titleFontWeight: "normal",
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: o,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: s,
            tickThickness: 1,
            tickColor: s,
            gridThickness: 1,
            gridColor: s,
            stripLines: [
              {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1,
              },
            ],
            crosshair: {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#000000",
              labelFontWeight: "normal",
              labelBackgroundColor: l,
              color: r,
              thickness: 1,
              lineDashType: "dash",
            },
            scaleBreaks: {
              type: "zigzag",
              spacing: "2%",
              lineColor: "#777777",
              lineThickness: 1,
              lineDashType: "solid",
              color: "#111111",
            },
          },
        ],
        axisY2: [
          {
            titleFontFamily: d,
            titleFontSize: x,
            titleFontColor: o,
            titleFontWeight: "normal",
            labelFontFamily: d,
            labelFontSize: m,
            labelFontColor: o,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: s,
            tickThickness: 1,
            tickColor: s,
            gridThickness: 1,
            gridColor: s,
            stripLines: [
              {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1,
              },
            ],
            crosshair: {
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: "#000000",
              labelFontWeight: "normal",
              labelBackgroundColor: l,
              color: r,
              thickness: 1,
              lineDashType: "dash",
            },
            scaleBreaks: {
              type: "zigzag",
              spacing: "2%",
              lineColor: "#777777",
              lineThickness: 1,
              lineDashType: "solid",
              color: "#111111",
            },
          },
        ],
        legend: {
          fontFamily: d,
          fontSize: 14,
          fontColor: n,
          fontWeight: "bold",
          verticalAlign: "bottom",
          horizontalAlign: "center",
        },
        toolTip: {
          fontFamily: d,
          fontSize: 14,
          fontStyle: "normal",
          cornerRadius: 0,
          borderThickness: 1,
          fontColor: o,
          backgroundColor: "rgba(0, 0, 0, .7)",
        },
      }),
      (o = n = "#FAFAFA");
    var x,
      m,
      H = {
        light1: p,
        light2: u,
        dark1: c,
        dark2: {
          colorSet: "colorSet2",
          backgroundColor: "#32373A",
          title: {
            fontFamily: d,
            fontSize: 32,
            fontColor: n,
            fontWeight: "normal",
            verticalAlign: "top",
            margin: 5,
          },
          subtitles: [
            {
              fontFamily: d,
              fontSize: (m = 14),
              fontColor: n,
              fontWeight: "normal",
              verticalAlign: "top",
              margin: 5,
            },
          ],
          toolbar: {
            backgroundColor: "#666666",
            backgroundColorOnHover: "#FF7372",
            borderColor: "#FF7372",
            borderThickness: 1,
            fontColor: (l = "#F5F5F5"),
            fontColorOnHover: "#F5F5F5",
          },
          data: [
            {
              indexLabelFontFamily: d,
              indexLabelFontSize: m,
              indexLabelFontColor: o,
              indexLabelFontWeight: "normal",
              indexLabelLineThickness: 1,
            },
          ],
          axisX: [
            {
              titleFontFamily: d,
              titleFontSize: (x = 20),
              titleFontColor: o,
              titleFontWeight: "normal",
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: o,
              labelFontWeight: "normal",
              lineThickness: 1,
              lineColor: (s = "#FFFFFF"),
              tickThickness: 1,
              tickColor: s,
              gridThickness: 0,
              gridColor: s,
              stripLines: [
                {
                  labelFontFamily: d,
                  labelFontSize: m,
                  labelFontColor: "#FF7300",
                  labelFontWeight: "normal",
                  labelBackgroundColor: null,
                  color: "#FF7300",
                  thickness: 1,
                },
              ],
              crosshair: {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#000000",
                labelFontWeight: "normal",
                labelBackgroundColor: l,
                color: (r = "#40BAF1"),
                thickness: 1,
                lineDashType: "dash",
              },
              scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#777777",
                lineThickness: 1,
                lineDashType: "solid",
                color: "#111111",
              },
            },
          ],
          axisX2: [
            {
              titleFontFamily: d,
              titleFontSize: x,
              titleFontColor: o,
              titleFontWeight: "normal",
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: o,
              labelFontWeight: "normal",
              lineThickness: 1,
              lineColor: s,
              tickThickness: 1,
              tickColor: s,
              gridThickness: 0,
              gridColor: s,
              stripLines: [
                {
                  labelFontFamily: d,
                  labelFontSize: m,
                  labelFontColor: "#FF7300",
                  labelFontWeight: "normal",
                  labelBackgroundColor: null,
                  color: "#FF7300",
                  thickness: 1,
                },
              ],
              crosshair: {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#000000",
                labelFontWeight: "normal",
                labelBackgroundColor: l,
                color: r,
                thickness: 1,
                lineDashType: "dash",
              },
              scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#777777",
                lineThickness: 1,
                lineDashType: "solid",
                color: "#111111",
              },
            },
          ],
          axisY: [
            {
              titleFontFamily: d,
              titleFontSize: x,
              titleFontColor: o,
              titleFontWeight: "normal",
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: o,
              labelFontWeight: "normal",
              lineThickness: 0,
              lineColor: s,
              tickThickness: 1,
              tickColor: s,
              gridThickness: 1,
              gridColor: s,
              stripLines: [
                {
                  labelFontFamily: d,
                  labelFontSize: m,
                  labelFontColor: "#FF7300",
                  labelFontWeight: "normal",
                  labelBackgroundColor: null,
                  color: "#FF7300",
                  thickness: 1,
                },
              ],
              crosshair: {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#000000",
                labelFontWeight: "normal",
                labelBackgroundColor: l,
                color: r,
                thickness: 1,
                lineDashType: "dash",
              },
              scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#777777",
                lineThickness: 1,
                lineDashType: "solid",
                color: "#111111",
              },
            },
          ],
          axisY2: [
            {
              titleFontFamily: d,
              titleFontSize: x,
              titleFontColor: o,
              titleFontWeight: "normal",
              labelFontFamily: d,
              labelFontSize: m,
              labelFontColor: o,
              labelFontWeight: "normal",
              lineThickness: 0,
              lineColor: s,
              tickThickness: 1,
              tickColor: s,
              gridThickness: 1,
              gridColor: s,
              stripLines: [
                {
                  labelFontFamily: d,
                  labelFontSize: m,
                  labelFontColor: "#FF7300",
                  labelFontWeight: "normal",
                  labelBackgroundColor: null,
                  color: "#FF7300",
                  thickness: 1,
                },
              ],
              crosshair: {
                labelFontFamily: d,
                labelFontSize: m,
                labelFontColor: "#000000",
                labelFontWeight: "normal",
                labelBackgroundColor: l,
                color: r,
                thickness: 1,
                lineDashType: "dash",
              },
              scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#777777",
                lineThickness: 1,
                lineDashType: "solid",
                color: "#111111",
              },
            },
          ],
          legend: {
            fontFamily: d,
            fontSize: 14,
            fontColor: n,
            fontWeight: "bold",
            verticalAlign: "bottom",
            horizontalAlign: "center",
          },
          toolTip: {
            fontFamily: d,
            fontSize: 14,
            fontStyle: "normal",
            cornerRadius: 0,
            borderThickness: 1,
            fontColor: o,
            backgroundColor: "rgba(0, 0, 0, .7)",
          },
        },
        theme1: p,
        theme2: u,
        theme3: p,
      },
      tt = {
        numberDuration: 1,
        yearDuration: 314496e5,
        monthDuration: 2592e6,
        weekDuration: 6048e5,
        dayDuration: 864e5,
        hourDuration: 36e5,
        minuteDuration: 6e4,
        secondDuration: 1e3,
        millisecondDuration: 1,
        dayOfWeekFromInt:
          "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
      };
    (J.fSDec = function (t) {
      for (var e = "", i = 0; i < t.length; i++)
        e += String.fromCharCode(
          Math.ceil(t.length / 57 / 5) ^ t.charCodeAt(i)
        );
      return e;
    }),
      (J.obj = {
        trVs: "Ush`m!Wdsrhno",
        fntStr:
          "qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg",
        txtBl: "udyuC`rdmhod",
        fnt: "gnou",
        fSy: "ghmmRuxmd",
        fTx: "ghmmUdyu",
        grClr: "fsdx",
        cntx: "buy",
        tp: "unq",
      }),
      delete Y[J.fSDec("Bi`su")][J.fSDec("bsdehuIsdg")],
      (J.pro = { sCH: Y[J.fSDec("Bi`su")][J.fSDec("bsdehuIsdg")] }),
      (J._fTWm = function (t) {
        if (void 0 === J.pro.sCH && !dt)
          try {
            var e = t[J.fSDec(J.obj.cntx)];
            (e[J.fSDec(J.obj.txtBl)] = J.fSDec(J.obj.tp)),
              (e[J.fSDec(J.obj.fnt)] = 11 + J.fSDec(J.obj.fntStr)),
              (e[J.fSDec(J.obj.fSy)] = J.fSDec(J.obj.grClr)),
              e[J.fSDec(J.obj.fTx)](J.fSDec(J.obj.trVs), 2, t.height - 11 - 2);
          } catch (t) {}
      });
    var T,
      A,
      _,
      B,
      I,
      R,
      $,
      j = {},
      et = null,
      it =
        ((T =
          /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g),
        (A = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
          " "
        )),
        (_ = "Sun Mon Tue Wed Thu Fri Sat".split(" ")),
        (B =
          "January February March April May June July August September October November December".split(
            " "
          )),
        (I = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")),
        (R =
          /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g),
        ($ = /[^-+\dA-Z]/g),
        function (e, t, i) {
          var a = i ? i.days : A,
            s = i ? i.months : B,
            n = i ? i.shortDays : _,
            o = i ? i.shortMonths : I;
          i = "";
          var r = !1;
          if (
            ((e = e && e.getTime ? e : e ? new Date(e) : new Date()), isNaN(e))
          )
            throw SyntaxError("invalid date");
          "UTC:" === t.slice(0, 4) && ((t = t.slice(4)), (r = !0));
          var l = e[(i = r ? "getUTC" : "get") + "Date"](),
            h = e[i + "Day"](),
            d = e[i + "Month"](),
            c = e[i + "FullYear"](),
            p = e[i + "Hours"](),
            u = e[i + "Minutes"](),
            x = e[i + "Seconds"](),
            m = e[i + "Milliseconds"](),
            g = r ? 0 : e.getTimezoneOffset();
          return t.replace(T, function (t) {
            switch (t) {
              case "D":
                return l;
              case "DD":
                return v(l, 2);
              case "DDD":
                return n[h];
              case "DDDD":
                return a[h];
              case "M":
                return d + 1;
              case "MM":
                return v(d + 1, 2);
              case "MMM":
                return o[d];
              case "MMMM":
                return s[d];
              case "Y":
                return parseInt(String(c).slice(-2));
              case "YY":
                return v(String(c).slice(-2), 2);
              case "YYY":
                return v(String(c).slice(-3), 3);
              case "YYYY":
                return v(c, 4);
              case "h":
                return p % 12 || 12;
              case "hh":
                return v(p % 12 || 12, 2);
              case "H":
                return p;
              case "HH":
                return v(p, 2);
              case "m":
                return u;
              case "mm":
                return v(u, 2);
              case "s":
                return x;
              case "ss":
                return v(x, 2);
              case "f":
                return String(m).slice(0, 1);
              case "ff":
                return v(String(m).slice(0, 2), 2);
              case "fff":
                return v(String(m).slice(0, 3), 3);
              case "t":
                return p < 12 ? "a" : "p";
              case "tt":
                return p < 12 ? "am" : "pm";
              case "T":
                return p < 12 ? "A" : "P";
              case "TT":
                return p < 12 ? "AM" : "PM";
              case "K":
                return r
                  ? "UTC"
                  : (String(e).match(R) || [""]).pop().replace($, "");
              case "z":
                return (0 < g ? "-" : "+") + Math.floor(Math.abs(g) / 60);
              case "zz":
                return (0 < g ? "-" : "+") + v(Math.floor(Math.abs(g) / 60), 2);
              case "zzz":
                return (
                  (0 < g ? "-" : "+") +
                  v(Math.floor(Math.abs(g) / 60), 2) +
                  v(Math.abs(g) % 60, 2)
                );
              default:
                return t.slice(1, t.length - 1);
            }
          });
        }),
      at = function (t, e, i) {
        if (null === t) return "";
        if (!isFinite(t)) return t;
        var a = (t = Number(t)) < 0;
        a && (t *= -1);
        var s = i ? i.decimalSeparator : ".",
          n = i ? i.digitGroupSeparator : ",",
          o = "";
        e = String(e);
        o = 1;
        var r = (i = ""),
          l = -1,
          h = [],
          d = [],
          c = 0,
          p = 0,
          u = 0,
          x = !1,
          m = 0;
        r = e.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
        e = null;
        for (var g = 0; r && g < r.length; g++)
          if ("." === (e = r[g]) && l < 0) l = g;
          else {
            if ("%" === e) o *= 100;
            else {
              if ("" === e) {
                o *= 1e3;
                continue;
              }
              if ("," === e[0] && "." === e[e.length - 1]) {
                (o /= Math.pow(1e3, e.length - 1)), (l = g + e.length - 1);
                continue;
              }
              ("E" !== e[0] && "e" !== e[0]) ||
                "0" !== e[e.length - 1] ||
                (x = !0);
            }
            l < 0
              ? (h.push(e), "#" === e || "0" === e ? c++ : "," === e && u++)
              : (d.push(e), ("#" !== e && "0" !== e) || p++);
          }
        for (
          x &&
            ((e = Math.floor(t)),
            (r = -Math.floor(Math.log(t) / Math.LN10 + 1)),
            (m = 0 === t ? 0 : 0 === e ? -(c + r) : String(e).length - c),
            (o /= Math.pow(10, m))),
            l < 0 && (l = g),
            o = ((e = (o = (t * o).toFixed(p)).split("."))[0] + "").split(""),
            t = (e[1] + "").split(""),
            o && "0" === o[0] && o.shift(),
            x = r = g = p = l = 0;
          0 < h.length;

        )
          if ("#" === (e = h.pop()) || "0" === e)
            if (++l === c) {
              var b = o;
              o = [];
              if ("0" === e)
                for (e = c - p - (b ? b.length : 0); 0 < e; )
                  b.unshift("0"), e--;
              for (; 0 < b.length; )
                (i = b.pop() + i),
                  0 == ++x % r && g === u && 0 < b.length && (i = n + i);
            } else
              0 < o.length
                ? ((i = o.pop() + i), p++, x++)
                : "0" === e && ((i = "0" + i), p++, x++),
                0 == x % r && g === u && 0 < o.length && (i = n + i);
          else
            ("E" !== e[0] && "e" !== e[0]) ||
            "0" !== e[e.length - 1] ||
            !/[eE][+-]*[0]+/.test(e)
              ? "," === e
                ? (g++, (r = x), (x = 0) < o.length && (i = n + i))
                : (i =
                    1 < e.length &&
                    (('"' === e[0] && '"' === e[e.length - 1]) ||
                      ("'" === e[0] && "'" === e[e.length - 1]))
                      ? e.slice(1, e.length - 1) + i
                      : e + i)
              : (i += (e =
                  m < 0
                    ? e.replace("+", "").replace("-", "")
                    : e.replace("-", "")).replace(/[0]+/, function (t) {
                  return v(m, t.length);
                }));
        for (n = "", h = !1; 0 < d.length; )
          "#" === (e = d.shift()) || "0" === e
            ? 0 < t.length && 0 !== Number(t.join(""))
              ? ((n += t.shift()), (h = !0))
              : "0" === e && ((n += "0"), (h = !0))
            : 1 < e.length &&
              (('"' === e[0] && '"' === e[e.length - 1]) ||
                ("'" === e[0] && "'" === e[e.length - 1]))
            ? (n += e.slice(1, e.length - 1))
            : ("E" !== e[0] && "e" !== e[0]) ||
              "0" !== e[e.length - 1] ||
              !/[eE][+-]*[0]+/.test(e)
            ? (n += e)
            : (n += (e =
                m < 0
                  ? e.replace("+", "").replace("-", "")
                  : e.replace("-", "")).replace(/[0]+/, function (t) {
                return v(m, t.length);
              }));
        return (i += (h ? s : "") + n), a ? "-" + i : i;
      },
      st = function (t) {
        var e = 0,
          i = 0;
        return (
          (i =
            (t = t || window.event).offsetX || 0 === t.offsetX
              ? ((e = t.offsetX), t.offsetY)
              : t.layerX || 0 == t.layerX
              ? ((e = t.layerX), t.layerY)
              : ((e = t.pageX - t.target.offsetLeft),
                t.pageY - t.target.offsetTop)),
          { x: e, y: i }
        );
      },
      nt = !0,
      ot = window.devicePixelRatio || 1,
      rt = 1,
      lt = nt ? ot / rt : 1,
      ht = function (t) {
        for (var e = "", i = 0; i < t.length; i++)
          e += String.fromCharCode(
            Math.ceil(t.length / 57 / 5) ^ t.charCodeAt(i)
          );
        return e;
      },
      dt =
        window &&
        window[ht("mnb`uhno")] &&
        window[ht("mnb`uhno")].href &&
        window[ht("mnb`uhno")].href.indexOf &&
        (-1 !== window[ht("mnb`uhno")].href.indexOf(ht("b`ow`rkr/bnl")) ||
          -1 !== window[ht("mnb`uhno")].href.indexOf(ht("gdonqhy/bnl")) ||
          -1 !== window[ht("mnb`uhno")].href.indexOf(ht("gheemd"))),
      ct = dt && -1 === window[ht("mnb`uhno")].href.indexOf(ht("gheemd")),
      pt = {
        reset: {
          image:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==",
        },
        pan: {
          image:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC",
        },
        zoom: {
          image:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=",
        },
        menu: {
          image:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC",
        },
      };
    (L.prototype.setOptions = function (t, e) {
      if (Y[this._defaultsKey]) {
        var i,
          a = Y[this._defaultsKey];
        for (i in a)
          "publicProperties" !== i &&
            a.hasOwnProperty(i) &&
            (this[i] = t && i in t ? t[i] : e && i in e ? e[i] : a[i]);
      }
    }),
      (L.prototype.get = function (t) {
        var e = Y[this._defaultsKey];
        return "options" === t
          ? this.options && this.options._isPlaceholder
            ? null
            : this.options
          : e.hasOwnProperty(t) ||
            (e.publicProperties && e.publicProperties.hasOwnProperty(t))
          ? this[t]
          : void (
              window.console &&
              window.console.log(
                'Property "' + t + "\" doesn't exist. Please check for typo."
              )
            );
      }),
      (L.prototype.set = function (t, e, i) {
        i = void 0 === i || i;
        var a = Y[this._defaultsKey];
        if ("options" === t) this.createUserOptions(e);
        else {
          if (
            !(
              a.hasOwnProperty(t) ||
              (a.publicProperties &&
                a.publicProperties.hasOwnProperty(t) &&
                "readWrite" === a.publicProperties[t])
            )
          )
            return void (
              window.console &&
              (a.publicProperties &&
              a.publicProperties.hasOwnProperty(t) &&
              "readOnly" === a.publicProperties[t]
                ? window.console.log('Property "' + t + '" is read-only.')
                : window.console.log(
                    'Property "' +
                      t +
                      "\" doesn't exist. Please check for typo."
                  ))
            );
          this.options._isPlaceholder && this.createUserOptions(),
            (this.options[t] = e);
        }
        i && (this.chart || this).render();
      }),
      (L.prototype.addTo = function (t, e, i, a) {
        a = void 0 === a || a;
        var s = Y[this._defaultsKey];
        s.hasOwnProperty(t) ||
        (s.publicProperties &&
          s.publicProperties.hasOwnProperty(t) &&
          "readWrite" === s.publicProperties[t])
          ? (this.options._isPlaceholder && this.createUserOptions(),
            void 0 === this.options[t] && (this.options[t] = []),
            (t = this.options[t]),
            (i = null == i ? t.length : i),
            t.splice(i, 0, e),
            a && (this.chart || this).render())
          : window.console &&
            (s.publicProperties &&
            s.publicProperties.hasOwnProperty(t) &&
            "readOnly" === s.publicProperties[t]
              ? window.console.log('Property "' + t + '" is read-only.')
              : window.console.log(
                  'Property "' + t + "\" doesn't exist. Please check for typo."
                ));
      }),
      (L.prototype.createUserOptions = function (t) {
        if (void 0 !== t || this.options._isPlaceholder)
          if (
            (this.parent.options._isPlaceholder &&
              this.parent.createUserOptions(),
            this.isOptionsInArray)
          ) {
            this.parent.options[this.optionsName] ||
              (this.parent.options[this.optionsName] = []);
            var e = this.parent.options[this.optionsName],
              i = e.length;
            this.options._isPlaceholder ||
              (q(e), (i = e.indexOf(this.options))),
              (this.options = void 0 === t ? {} : t),
              (e[i] = this.options);
          } else
            (this.options = void 0 === t ? {} : t),
              ((t = this.parent.options)[
                (e = this.optionsName
                  ? this.optionsName
                  : (e = this._defaultsKey) && 0 !== e.length
                  ? ((i = e.charAt(0).toLowerCase()),
                    1 < e.length && (i = i.concat(e.slice(1))),
                    i)
                  : void 0)
              ] = this.options);
      }),
      (L.prototype.remove = function (t) {
        if (((t = void 0 === t || t), this.isOptionsInArray)) {
          var e = this.parent.options[this.optionsName];
          q(e);
          var i = e.indexOf(this.options);
          0 <= i && e.splice(i, 1);
        } else delete this.parent.options[this.optionsName];
        t && (this.chart || this).render();
      }),
      (L.prototype.updateOption = function (t) {
        var e = Y[this._defaultsKey],
          i = {},
          a = this[t],
          s = this._themeOptionsKey,
          n = this._index;
        return (
          this.theme && U(s) && U(n)
            ? (i = U(H[this.theme]) ? H.light1 : H[this.theme])
            : this.parent &&
              this.parent.themeOptions &&
              this.parent.themeOptions[s] &&
              (null === n
                ? (i = this.parent.themeOptions[s])
                : 0 < this.parent.themeOptions[s].length &&
                  ((i = Math.min(this.parent.themeOptions[s].length - 1, n)),
                  (i = this.parent.themeOptions[s][i]))),
          (this.themeOptions = i),
          t in e &&
            (a =
              t in this.options ? this.options[t] : i && t in i ? i[t] : e[t]),
          a !== this[t] && ((this[t] = a), !0)
        );
      }),
      (L.prototype.trackChanges = function (t) {
        if (!this.sessionVariables) throw "Session Variable Store not set";
        this.sessionVariables[t] = this.options[t];
      }),
      (L.prototype.isBeingTracked = function (t) {
        return (
          this.options._oldOptions || (this.options._oldOptions = {}),
          !!this.options._oldOptions[t]
        );
      }),
      (L.prototype.hasOptionChanged = function (t) {
        if (!this.sessionVariables) throw "Session Variable Store not set";
        return this.sessionVariables[t] !== this.options[t];
      }),
      (L.prototype.addEventListener = function (t, e, i) {
        t &&
          e &&
          ((this._eventListeners[t] = this._eventListeners[t] || []),
          this._eventListeners[t].push({
            context: i || this,
            eventHandler: e,
          }));
      }),
      (L.prototype.removeEventListener = function (t, e) {
        if (t && e && this._eventListeners[t])
          for (var i = this._eventListeners[t], a = 0; a < i.length; a++)
            if (i[a].eventHandler === e) {
              i[a].splice(a, 1);
              break;
            }
      }),
      (L.prototype.removeAllEventListeners = function () {
        this._eventListeners = [];
      }),
      (L.prototype.dispatchEvent = function (t, e, i) {
        if (t && this._eventListeners[t]) {
          e = e || {};
          for (var a = this._eventListeners[t], s = 0; s < a.length; s++)
            a[s].eventHandler.call(a[s].context, e);
        }
        "function" == typeof this[t] && this[t].call(i || this.chart, e);
      }),
      (D.prototype.registerSpace = function (t, e) {
        "top" === t
          ? (this._topOccupied += e.height)
          : "bottom" === t
          ? (this._bottomOccupied += e.height)
          : "left" === t
          ? (this._leftOccupied += e.width)
          : "right" === t && (this._rightOccupied += e.width);
      }),
      (D.prototype.unRegisterSpace = function (t, e) {
        "top" === t
          ? (this._topOccupied -= e.height)
          : "bottom" === t
          ? (this._bottomOccupied -= e.height)
          : "left" === t
          ? (this._leftOccupied -= e.width)
          : "right" === t && (this._rightOccupied -= e.width);
      }),
      (D.prototype.getFreeSpace = function () {
        return {
          x1: this._x1 + this._leftOccupied,
          y1: this._y1 + this._topOccupied,
          x2: this._x2 - this._rightOccupied,
          y2: this._y2 - this._bottomOccupied,
          width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied,
          height:
            this._y2 - this._y1 - this._bottomOccupied - this._topOccupied,
        };
      }),
      (D.prototype.reset = function () {
        this._rightOccupied =
          this._leftOccupied =
          this._bottomOccupied =
          this._topOccupied =
            this._padding;
      }),
      t(Q, L),
      (Q.prototype._initialize = function () {
        U(this.padding) || "object" != typeof this.padding
          ? (this.topPadding =
              this.rightPadding =
              this.bottomPadding =
              this.leftPadding =
                0 | Number(this.padding))
          : ((this.topPadding = U(this.padding.top)
              ? 0
              : 0 | Number(this.padding.top)),
            (this.rightPadding = U(this.padding.right)
              ? 0
              : 0 | Number(this.padding.right)),
            (this.bottomPadding = U(this.padding.bottom)
              ? 0
              : 0 | Number(this.padding.bottom)),
            (this.leftPadding = U(this.padding.left)
              ? 0
              : 0 | Number(this.padding.left)));
      }),
      (Q.prototype.render = function (t) {
        if (0 !== this.fontSize) {
          t && this.ctx.save();
          var e = this.ctx.font;
          this.ctx.textBaseline = this.textBaseline;
          var i = 0;
          this._isDirty && this.measureText(this.ctx),
            this.ctx.translate(this.x, this.y + i),
            "middle" === this.textBaseline && (i = -this._lineHeight / 2),
            (this.ctx.font = this._getFontString()),
            this.ctx.rotate((Math.PI / 180) * this.angle);
          var a = 0,
            s = this.topPadding,
            n = null;
          for (
            this.ctx.roundRect || G(this.ctx),
              ((0 < this.borderThickness && this.borderColor) ||
                this.backgroundColor) &&
                this.ctx.roundRect(
                  0,
                  i,
                  this.width,
                  this.height,
                  this.cornerRadius,
                  this.borderThickness,
                  this.backgroundColor,
                  this.borderColor
                ),
              this.ctx.fillStyle = this.fontColor,
              i = 0;
            i < this._wrappedText.lines.length;
            i++
          )
            (n = this._wrappedText.lines[i]),
              "right" === this.horizontalAlign
                ? (a =
                    (this.width - (this.leftPadding + this.rightPadding)) / 2 -
                    n.width / 2 +
                    this.leftPadding)
                : "left" === this.horizontalAlign
                ? (a = this.leftPadding)
                : "center" === this.horizontalAlign &&
                  (a =
                    (this.width - (this.leftPadding + this.rightPadding)) / 2 -
                    n.width / 2 +
                    this.leftPadding),
              this.ctx.fillText(n.text, a, s),
              (s += n.height);
          (this.ctx.font = e), t && this.ctx.restore();
        }
      }),
      (Q.prototype.setText = function (t) {
        (this.text = t), (this._isDirty = !0), (this._wrappedText = null);
      }),
      (Q.prototype.measureText = function () {
        if (
          ((this._lineHeight = a(
            this.fontFamily,
            this.fontSize,
            this.fontWeight
          )),
          null === this.maxWidth)
        )
          throw "Please set maxWidth and height for TextBlock";
        return (
          this._wrapText(this.ctx),
          (this._isDirty = !1),
          { width: this.width, height: this.height }
        );
      }),
      (Q.prototype._getLineWithWidth = function (t, e, i) {
        if (!(t = String(t))) return { text: "", width: 0 };
        var a = (i = 0),
          s = t.length - 1,
          n = 1 / 0;
        for (this.ctx.font = this._getFontString(); a <= s; ) {
          n = Math.floor((a + s) / 2);
          var o = t.substr(0, n + 1);
          if ((i = this.ctx.measureText(o).width) < e) a = n + 1;
          else {
            if (!(e < i)) break;
            s = n - 1;
          }
        }
        return (
          e < i &&
            1 < o.length &&
            ((o = o.substr(0, o.length - 1)),
            (i = this.ctx.measureText(o).width)),
          (e = !0),
          (o.length !== t.length && " " !== t[o.length]) || (e = !1),
          e &&
            (1 < (t = o.split(" ")).length && t.pop(),
            (o = t.join(" ")),
            (i = this.ctx.measureText(o).width)),
          { text: o, width: i }
        );
      }),
      (Q.prototype._wrapText = function () {
        var t = new String(g(String(this.text))),
          e = [],
          i = this.ctx.font,
          a = 0,
          s = 0;
        if (((this.ctx.font = this._getFontString()), 0 === this.frontSize))
          s = a = 0;
        else
          for (; 0 < t.length; ) {
            var n = this.maxHeight - (this.topPadding + this.bottomPadding),
              o = this._getLineWithWidth(
                t,
                this.maxWidth - (this.leftPadding + this.rightPadding),
                !1
              );
            (o.height = this._lineHeight), e.push(o);
            var r = s;
            (s = Math.max(s, o.width)),
              (a = a + o.height),
              (t = g(t.slice(o.text.length, t.length)));
            n && n < a && ((a -= (o = e.pop()).height), (s = r));
          }
        (this._wrappedText = { lines: e, width: s, height: a }),
          (this.width = s + (this.leftPadding + this.rightPadding)),
          (this.height = a + (this.topPadding + this.bottomPadding)),
          (this.ctx.font = i);
      }),
      (Q.prototype._getFontString = function () {
        var t;
        (t = this.fontStyle ? this.fontStyle + " " : ""),
          (t += this.fontWeight ? this.fontWeight + " " : ""),
          (t += this.fontSize ? this.fontSize + "px " : "");
        var e = this.fontFamily ? this.fontFamily + "" : "";
        return (
          !Z &&
            e &&
            "'" !== (e = e.split(",")[0])[0] &&
            '"' !== e[0] &&
            (e = "'" + e + "'"),
          t + e
        );
      }),
      t(V, L),
      t(z, L),
      (z.prototype.render = function () {
        if (this.text) {
          var t,
            e,
            i,
            a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,
            s = a.layoutManager.getFreeSpace(),
            n = s.x1,
            o = s.y1,
            r = 0,
            l = 0,
            h =
              this.chart._menuButton &&
              this.chart.exportEnabled &&
              "top" === this.verticalAlign
                ? 22
                : 0;
          "top" === this.verticalAlign || "bottom" === this.verticalAlign
            ? (null === this.maxWidth &&
                (this.maxWidth =
                  s.width -
                  4 -
                  h * ("center" === this.horizontalAlign ? 2 : 1)),
              (l = 0.5 * s.height - this.margin - 2),
              (r = 0))
            : "center" === this.verticalAlign &&
              ("left" === this.horizontalAlign ||
              "right" === this.horizontalAlign
                ? (null === this.maxWidth && (this.maxWidth = s.height - 4),
                  (l = 0.5 * s.width - this.margin - 2))
                : "center" === this.horizontalAlign &&
                  (null === this.maxWidth && (this.maxWidth = s.width - 4),
                  (l = 0.5 * s.height - 4))),
            U(this.padding) || "number" != typeof this.padding
              ? U(this.padding) ||
                "object" != typeof this.padding ||
                ((i = this.padding.top
                  ? this.padding.top
                  : this.padding.bottom
                  ? this.padding.bottom
                  : 0),
                (i += this.padding.bottom
                  ? this.padding.bottom
                  : this.padding.top
                  ? this.padding.top
                  : 0),
                (i *= 1.25))
              : (i = 2.5 * this.padding),
            this.wrap ||
              (l = Math.min(
                l,
                Math.max(1.5 * this.fontSize, this.fontSize + i)
              )),
            (i = (l = new Q(this.ctx, {
              fontSize: this.fontSize,
              fontFamily: this.fontFamily,
              fontColor: this.fontColor,
              fontStyle: this.fontStyle,
              fontWeight: this.fontWeight,
              horizontalAlign: this.horizontalAlign,
              verticalAlign: this.verticalAlign,
              borderColor: this.borderColor,
              borderThickness: this.borderThickness,
              backgroundColor: this.backgroundColor,
              maxWidth: this.maxWidth,
              maxHeight: l,
              cornerRadius: this.cornerRadius,
              text: this.text,
              padding: this.padding,
              textBaseline: "top",
            })).measureText()),
            "top" === this.verticalAlign || "bottom" === this.verticalAlign
              ? ("top" === this.verticalAlign
                  ? ((o = s.y1 + 2), (e = "top"))
                  : "bottom" === this.verticalAlign &&
                    ((o = s.y2 - 2 - i.height), (e = "bottom")),
                "left" === this.horizontalAlign
                  ? (n = s.x1 + 2)
                  : "center" === this.horizontalAlign
                  ? (n = s.x1 + s.width / 2 - i.width / 2)
                  : "right" === this.horizontalAlign &&
                    (n = s.x2 - 2 - i.width - h),
                (t = this.horizontalAlign),
                (this.width = i.width),
                (this.height = i.height))
              : "center" === this.verticalAlign &&
                ("left" === this.horizontalAlign
                  ? ((n = s.x1 + 2),
                    (o = s.y2 - 2 - (this.maxWidth / 2 - i.width / 2)),
                    (r = -90),
                    (e = "left"),
                    (this.width = i.height),
                    (this.height = i.width))
                  : "right" === this.horizontalAlign
                  ? ((n = s.x2 - 2),
                    (o = s.y1 + 2 + (this.maxWidth / 2 - i.width / 2)),
                    (r = 90),
                    (e = "right"),
                    (this.width = i.height),
                    (this.height = i.width))
                  : "center" === this.horizontalAlign &&
                    ((o = a.y1 + (a.height / 2 - i.height / 2)),
                    (n = a.x1 + (a.width / 2 - i.width / 2)),
                    (e = "center"),
                    (this.width = i.width),
                    (this.height = i.height)),
                (t = "center")),
            (l.x = n),
            (l.y = o),
            (l.angle = r),
            (l.horizontalAlign = t),
            l.render(!0),
            a.layoutManager.registerSpace(e, {
              width:
                this.width +
                ("left" === e || "right" === e ? this.margin + 2 : 0),
              height:
                this.height +
                ("top" === e || "bottom" === e ? this.margin + 2 : 0),
            }),
            (this.bounds = {
              x1: n,
              y1: o,
              x2: n + this.width,
              y2: o + this.height,
            }),
            (this.ctx.textBaseline = "top");
        }
      }),
      t(W, L),
      (W.prototype.render = z.prototype.render),
      t(X, L);
    var ut = {
      addTheme: function (t, e) {
        H[t] = e;
      },
      addColorSet: function (t, e) {
        O[t] = e;
      },
      addCultureInfo: function (t, e) {
        h[t] = e;
      },
      formatNumber: function (t, e, i) {
        if (h[(i = i || "en")]) return at(t, e || "#,##0.##", new X(i));
        throw "Unknown Culture Name";
      },
      formatDate: function (t, e, i) {
        if (h[(i = i || "en")]) return it(t, e || "DD MMM YYYY", new X(i));
        throw "Unknown Culture Name";
      },
    };
    "undefined" != typeof module && void 0 !== module.exports
      ? (module.exports = ut)
      : "function" == typeof define && define.amd
      ? define([], function () {
          return ut;
        })
      : (window.CanvasJS = ut),
      (ut.Chart = (function () {
        function o(t, e) {
          return t.x - e.x;
        }
        function s(e, i, t) {
          if (e && i && t) {
            t = t + "." + i;
            var a = "image/" + i;
            e = e.toDataURL(a);
            var s = !1,
              n = document.createElement("a");
            if (
              ((n.download = t),
              (n.href = e),
              "undefined" != typeof Blob && new Blob())
            ) {
              for (
                var o = e.replace(/^data:[a-z\/]*;base64,/, ""),
                  r = ((o = atob(o)), new ArrayBuffer(o.length)),
                  l = ((r = new Uint8Array(r)), 0);
                l < o.length;
                l++
              )
                r[l] = o.charCodeAt(l);
              i = new Blob([r.buffer], { type: "image/" + i });
              try {
                window.navigator.msSaveBlob(i, t), (s = !0);
              } catch (t) {
                (n.dataset.downloadurl = [a, n.download, n.href].join(":")),
                  (n.href = window.URL.createObjectURL(i));
              }
            }
            if (!s)
              try {
                (event = document.createEvent("MouseEvents")),
                  event.initMouseEvent(
                    "click",
                    !0,
                    !1,
                    window,
                    0,
                    0,
                    0,
                    0,
                    0,
                    !1,
                    !1,
                    !1,
                    !1,
                    0,
                    null
                  ),
                  n.dispatchEvent
                    ? n.dispatchEvent(event)
                    : n.fireEvent && n.fireEvent("onclick");
              } catch (t) {
                (i = window.open()).document.write(
                  "<img src='" +
                    e +
                    "'></img><div>Please right click on the image and save it to your device</div>"
                ),
                  i.document.close();
              }
          }
        }
        function r(t, e) {
          (e = e || {}),
            (this.theme = U(e.theme) || U(H[e.theme]) ? "light1" : e.theme),
            r.base.constructor.call(this, "Chart", null, e, null, null);
          var i = this;
          if (
            ((this._containerId = t),
            (this._objectsInitialized = !1),
            (this.overlaidCanvasCtx = this.ctx = null),
            (this._indexLabels = []),
            (this._panTimerId = 0),
            (this._lastTouchEventType = ""),
            (this._lastTouchData = null),
            (this.isAnimating = !1),
            (this.renderCount = 0),
            (this.disableToolTip = this.animatedRender = !1),
            (this.allDOMEventHandlers = []),
            (this.panEnabled = !1),
            (this._defaultCursor = "default"),
            (this.plotArea = {
              canvas: null,
              ctx: null,
              x1: 0,
              y1: 0,
              x2: 0,
              y2: 0,
              width: 0,
              height: 0,
            }),
            (this._dataInRenderedOrder = []),
            (this.container =
              "string" == typeof this._containerId
                ? document.getElementById(this._containerId)
                : this._containerId))
          ) {
            this.container.innerHTML = "";
            var a = this.options.width
                ? this.width
                : 0 < this.container.clientWidth
                ? this.container.clientWidth
                : this.width,
              s = this.options.height
                ? this.height
                : 0 < this.container.clientHeight
                ? this.container.clientHeight
                : this.height;
            (this.width = a),
              (this.height = s),
              (this.x1 = this.y1 = 0),
              (this.x2 = this.width),
              (this.y2 = this.height),
              (this._selectedColorSet =
                void 0 !== O[this.colorSet] ? O[this.colorSet] : O.colorSet1),
              (this._canvasJSContainer = document.createElement("div")),
              this._canvasJSContainer.setAttribute(
                "class",
                "canvasjs-chart-container"
              ),
              (this._canvasJSContainer.style.position = "relative"),
              (this._canvasJSContainer.style.textAlign = "left"),
              (this._canvasJSContainer.style.cursor = "auto"),
              Z || (this._canvasJSContainer.style.height = "0px"),
              this.container.appendChild(this._canvasJSContainer),
              (this.canvas = k(a, s)),
              (this._preRenderCanvas = k(a, s)),
              (this.canvas.style.position = "absolute"),
              this.canvas.getContext &&
                (this._canvasJSContainer.appendChild(this.canvas),
                (this.ctx = this.canvas.getContext("2d")),
                (this.ctx.textBaseline = "top"),
                G(this.ctx),
                (this._preRenderCtx = this._preRenderCanvas.getContext("2d")),
                (this._preRenderCtx.textBaseline = "top"),
                G(this._preRenderCtx),
                (this.plotArea.ctx = Z
                  ? this.ctx
                  : ((this.plotArea.canvas = k(a, s)),
                    (this.plotArea.canvas.style.position = "absolute"),
                    this.plotArea.canvas.setAttribute(
                      "class",
                      "plotAreaCanvas"
                    ),
                    this._canvasJSContainer.appendChild(this.plotArea.canvas),
                    this.plotArea.canvas.getContext("2d"))),
                (this.overlaidCanvas = k(a, s)),
                (this.overlaidCanvas.style.position = "absolute"),
                (this.overlaidCanvas.style.webkitTapHighlightColor =
                  "transparent"),
                this.overlaidCanvas.getContext &&
                  (this._canvasJSContainer.appendChild(this.overlaidCanvas),
                  (this.overlaidCanvasCtx =
                    this.overlaidCanvas.getContext("2d")),
                  (this.overlaidCanvasCtx.textBaseline = "top"),
                  G(this.overlaidCanvasCtx)),
                (this._eventManager = new u(this)),
                (this.windowResizeHandler = f(
                  window,
                  "resize",
                  function () {
                    i._updateSize() && i.render();
                  },
                  this.allDOMEventHandlers
                )),
                (this._toolBar = document.createElement("div")),
                this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"),
                (this._toolBar.style.cssText =
                  "position: absolute; right: 1px; top: 1px;"),
                this._canvasJSContainer.appendChild(this._toolBar),
                (this.bounds = {
                  x1: 0,
                  y1: 0,
                  x2: this.width,
                  y2: this.height,
                }),
                f(
                  this.overlaidCanvas,
                  "click",
                  function (t) {
                    i._mouseEventHandler(t);
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this.overlaidCanvas,
                  "mousemove",
                  function (t) {
                    i._mouseEventHandler(t);
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this.overlaidCanvas,
                  "mouseup",
                  function (t) {
                    i._mouseEventHandler(t);
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this.overlaidCanvas,
                  "mousedown",
                  function (t) {
                    i._mouseEventHandler(t), F(i._dropdownMenu);
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this.overlaidCanvas,
                  "mouseout",
                  function (t) {
                    i._mouseEventHandler(t);
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this.overlaidCanvas,
                  window.navigator.msPointerEnabled
                    ? "MSPointerDown"
                    : "touchstart",
                  function (t) {
                    i._touchEventHandler(t);
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this.overlaidCanvas,
                  window.navigator.msPointerEnabled
                    ? "MSPointerMove"
                    : "touchmove",
                  function (t) {
                    i._touchEventHandler(t);
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this.overlaidCanvas,
                  window.navigator.msPointerEnabled
                    ? "MSPointerUp"
                    : "touchend",
                  function (t) {
                    i._touchEventHandler(t);
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this.overlaidCanvas,
                  window.navigator.msPointerEnabled
                    ? "MSPointerCancel"
                    : "touchcancel",
                  function (t) {
                    i._touchEventHandler(t);
                  },
                  this.allDOMEventHandlers
                ),
                (this.toolTip = new n(this, this.options.toolTip)),
                (this.data = null),
                (this.axisX = []),
                (this.axisX2 = []),
                (this.axisY = []),
                (this.axisY2 = []),
                (this.sessionVariables = {
                  axisX: [],
                  axisX2: [],
                  axisY: [],
                  axisY2: [],
                }));
          } else
            window.console &&
              window.console.log(
                'CanvasJS Error: Chart Container with id "' +
                  this._containerId +
                  '" was not found'
              );
        }
        function A(t, e) {
          for (var i, a = [], s = 0; s < t.length; s++)
            if (0 == s) a.push(t[0]);
            else {
              var n, o, r;
              (n = 0 === (r = s - 1) ? 0 : r - 1),
                (o = r === t.length - 1 ? r : r + 1),
                (i =
                  (Math.abs(
                    (t[o].x - t[n].x) /
                      (0 == t[o].x - t[r].x ? 0.01 : t[o].x - t[r].x)
                  ) *
                    (e - 1)) /
                    2 +
                  1);
              var l = (t[o].x - t[n].x) / i;
              (i = (t[o].y - t[n].y) / i),
                (a[a.length] =
                  (t[r].x > t[n].x && 0 < l) || (t[r].x < t[n].x && l < 0)
                    ? { x: t[r].x + l / 3, y: t[r].y + i / 3 }
                    : { x: t[r].x, y: t[r].y + i / 9 }),
                (n = 0 === (r = s) ? 0 : r - 1),
                (o = r === t.length - 1 ? r : r + 1),
                (i =
                  (Math.abs(
                    (t[o].x - t[n].x) /
                      (0 == t[r].x - t[n].x ? 0.01 : t[r].x - t[n].x)
                  ) *
                    (e - 1)) /
                    2 +
                  1),
                (l = (t[o].x - t[n].x) / i),
                (i = (t[o].y - t[n].y) / i),
                (a[a.length] =
                  (t[r].x > t[n].x && 0 < l) || (t[r].x < t[n].x && l < 0)
                    ? { x: t[r].x - l / 3, y: t[r].y - i / 3 }
                    : { x: t[r].x, y: t[r].y - i / 9 }),
                (a[a.length] = t[s]);
            }
          return a;
        }
        function _(t, e, i, a, s, n, o, r, l, h) {
          var d = 0;
          h ? ((o.color = n), (r.color = n)) : (h = 1),
            (d = l ? Math.abs(s - i) : Math.abs(a - e)),
            (d =
              0 < o.trimLength
                ? Math.abs((d * o.trimLength) / 100)
                : Math.abs(d - o.length)),
            l ? ((i += d / 2), (s -= d / 2)) : ((e += d / 2), (a -= d / 2));
          d = 1 == Math.round(o.thickness) % 2 ? 0.5 : 0;
          var c = 1 == Math.round(r.thickness) % 2 ? 0.5 : 0;
          t.save(),
            (t.globalAlpha = h),
            (t.strokeStyle = r.color || n),
            (t.lineWidth = r.thickness || 2),
            t.setLineDash && t.setLineDash(K(r.dashType, r.thickness)),
            t.beginPath(),
            l && 0 < r.thickness
              ? (t.moveTo(a - o.thickness / 2, Math.round((i + s) / 2) - c),
                t.lineTo(e + o.thickness / 2, Math.round((i + s) / 2) - c))
              : 0 < r.thickness &&
                (t.moveTo(Math.round((e + a) / 2) - c, i + o.thickness / 2),
                t.lineTo(Math.round((e + a) / 2) - c, s - o.thickness / 2)),
            t.stroke(),
            (t.strokeStyle = o.color || n),
            (t.lineWidth = o.thickness || 2),
            t.setLineDash && t.setLineDash(K(o.dashType, o.thickness)),
            t.beginPath(),
            l && 0 < o.thickness
              ? (t.moveTo(a - d, i),
                t.lineTo(a - d, s),
                t.moveTo(e + d, i),
                t.lineTo(e + d, s))
              : 0 < o.thickness &&
                (t.moveTo(e, i + d),
                t.lineTo(a, i + d),
                t.moveTo(e, s - d),
                t.lineTo(a, s - d)),
            t.stroke(),
            t.restore();
        }
        function l(t, e, i, a, s) {
          return null == t
            ? void 0 === i
              ? e
              : i
            : ((t =
                parseFloat(t.toString()) *
                (0 <= t.toString().indexOf("%") ? e / 100 : 1)),
              void 0 !== a &&
                ((t = Math.min(a, t)), void 0 !== s && (t = Math.max(s, t))),
              !isNaN(t) && t <= e && 0 <= t ? t : void 0 === i ? e : i);
        }
        function p(t, e) {
          p.base.constructor.call(this, "Legend", "legend", e, null, t),
            (this.chart = t),
            (this.canvas = t.canvas),
            (this.ctx = this.chart.ctx),
            (this.ghostCtx = this.chart._eventManager.ghostCtx),
            (this.items = []),
            (this.optionsName = "legend"),
            (this.height = this.width = 0),
            (this.orientation = null),
            (this.dataSeries = []),
            (this.bounds = { x1: null, y1: null, x2: null, y2: null }),
            void 0 === this.options.fontSize &&
              (this.fontSize = this.chart.getAutoFontSize(this.fontSize)),
            (this.lineHeight = a(
              this.fontFamily,
              this.fontSize,
              this.fontWeight
            )),
            (this.horizontalSpacing = this.fontSize);
        }
        function T(t, e, i, a) {
          for (
            T.base.constructor.call(this, "DataSeries", "data", e, i, t),
              this.chart = t,
              this.canvas = t.canvas,
              this._ctx = t.canvas.ctx,
              this.index = i,
              this.noDataPointsInPlotArea = 0,
              this.id = a,
              this.chart._eventManager.objectMap[a] = {
                id: a,
                objectType: "dataSeries",
                dataSeriesIndex: i,
              },
              t = e.dataPoints ? e.dataPoints.length : 0,
              this.dataPointEOs = [],
              e = 0;
            e < t;
            e++
          )
            this.dataPointEOs[e] = {};
          (this.dataPointIds = []),
            (this.plotUnit = []),
            (this.axisY = this.axisX = null),
            (this.optionsName = "data"),
            (this.isOptionsInArray = !0),
            null === this.fillOpacity &&
              (this.type.match(/area/i)
                ? (this.fillOpacity = 0.7)
                : (this.fillOpacity = 1)),
            (this.axisPlacement = this.getDefaultAxisPlacement()),
            void 0 === this.options.indexLabelFontSize &&
              (this.indexLabelFontSize = this.chart.getAutoFontSize(
                this.indexLabelFontSize
              ));
        }
        function v(t, e, i, a, s, n) {
          if (
            (v.base.constructor.call(this, "Axis", e, i, a, t),
            (this.chart = t),
            (this.canvas = t.canvas),
            (this.ctx = t.ctx),
            (this.intervalStartPosition = this.maxHeight = this.maxWidth = 0),
            (this.labels = []),
            (this.dataSeries = []),
            (this._stripLineLabels = this._ticks = this._labels = null),
            (this.dataInfo = {
              min: 1 / 0,
              max: -1 / 0,
              viewPortMin: 1 / 0,
              viewPortMax: -1 / 0,
              minDiff: 1 / 0,
            }),
            (this.isOptionsInArray = !0),
            "axisX" === s
              ? ((this.sessionVariables =
                  "left" === n || "bottom" === n
                    ? ((this.optionsName = "axisX"),
                      U(this.chart.sessionVariables.axisX[a]) &&
                        (this.chart.sessionVariables.axisX[a] = {}),
                      this.chart.sessionVariables.axisX[a])
                    : ((this.optionsName = "axisX2"),
                      U(this.chart.sessionVariables.axisX2[a]) &&
                        (this.chart.sessionVariables.axisX2[a] = {}),
                      this.chart.sessionVariables.axisX2[a])),
                this.options.interval || (this.intervalType = null))
              : (this.sessionVariables =
                  "left" === n || "bottom" === n
                    ? ((this.optionsName = "axisY"),
                      U(this.chart.sessionVariables.axisY[a]) &&
                        (this.chart.sessionVariables.axisY[a] = {}),
                      this.chart.sessionVariables.axisY[a])
                    : ((this.optionsName = "axisY2"),
                      U(this.chart.sessionVariables.axisY2[a]) &&
                        (this.chart.sessionVariables.axisY2[a] = {}),
                      this.chart.sessionVariables.axisY2[a])),
            void 0 === this.options.titleFontSize &&
              (this.titleFontSize = this.chart.getAutoFontSize(
                this.titleFontSize
              )),
            void 0 === this.options.labelFontSize &&
              (this.labelFontSize = this.chart.getAutoFontSize(
                this.labelFontSize
              )),
            "axisX" !== (this.type = s) ||
              (i && void 0 !== i.gridThickness) ||
              (this.gridThickness = 0),
            (this._position = n),
            (this.lineCoordinates = {
              x1: null,
              y1: null,
              x2: null,
              y2: null,
              width: null,
            }),
            (this.labelAngle = ((this.labelAngle % 360) + 360) % 360),
            90 < this.labelAngle && this.labelAngle < 270
              ? (this.labelAngle -= 180)
              : 270 <= this.labelAngle &&
                this.labelAngle <= 360 &&
                (this.labelAngle -= 360),
            this.options.scaleBreaks &&
              (this.scaleBreaks = new h(
                this.chart,
                this.options.scaleBreaks,
                ++this.chart._eventManager.lastObjectId,
                this
              )),
            (this.stripLines = []),
            this.options.stripLines && 0 < this.options.stripLines.length)
          )
            for (t = 0; t < this.options.stripLines.length; t++)
              this.stripLines.push(
                new d(
                  this.chart,
                  this.options.stripLines[t],
                  t,
                  ++this.chart._eventManager.lastObjectId,
                  this
                )
              );
          this.options.crosshair &&
            (this.crosshair = new c(this.chart, this.options.crosshair, this)),
            (this._titleTextBlock = null),
            this.hasOptionChanged("viewportMinimum") &&
              null === this.viewportMinimum &&
              ((this.options.viewportMinimum = void 0),
              (this.sessionVariables.viewportMinimum = null)),
            this.hasOptionChanged("viewportMinimum") ||
            isNaN(this.sessionVariables.newViewportMinimum) ||
            null === this.sessionVariables.newViewportMinimum
              ? (this.sessionVariables.newViewportMinimum = null)
              : (this.viewportMinimum =
                  this.sessionVariables.newViewportMinimum),
            this.hasOptionChanged("viewportMaximum") &&
              null === this.viewportMaximum &&
              ((this.options.viewportMaximum = void 0),
              (this.sessionVariables.viewportMaximum = null)),
            this.hasOptionChanged("viewportMaximum") ||
            isNaN(this.sessionVariables.newViewportMaximum) ||
            null === this.sessionVariables.newViewportMaximum
              ? (this.sessionVariables.newViewportMaximum = null)
              : (this.viewportMaximum =
                  this.sessionVariables.newViewportMaximum),
            null !== this.minimum &&
              null !== this.viewportMinimum &&
              (this.viewportMinimum = Math.max(
                this.viewportMinimum,
                this.minimum
              )),
            null !== this.maximum &&
              null !== this.viewportMaximum &&
              (this.viewportMaximum = Math.min(
                this.viewportMaximum,
                this.maximum
              )),
            this.trackChanges("viewportMinimum"),
            this.trackChanges("viewportMaximum");
        }
        function h(t, e, i, a) {
          if (
            (h.base.constructor.call(
              this,
              "ScaleBreaks",
              "scaleBreaks",
              e,
              null,
              a
            ),
            (this.id = i),
            (this.chart = t),
            (this.ctx = this.chart.ctx),
            (this.axis = a),
            (this.optionsName = "scaleBreaks"),
            (this.isOptionsInArray = !1),
            (this._appliedBreaks = []),
            (this.customBreaks = []),
            (this.autoBreaks = []),
            "string" == typeof this.spacing
              ? ((this.spacing = parseFloat(this.spacing)),
                (this.spacing = isNaN(this.spacing)
                  ? 8
                  : (10 < this.spacing ? 10 : this.spacing) + "%"))
              : "number" != typeof this.spacing && (this.spacing = 8),
            this.autoCalculate &&
              (this.maxNumberOfAutoBreaks = Math.min(
                this.maxNumberOfAutoBreaks,
                5
              )),
            this.options.customBreaks && 0 < this.options.customBreaks.length)
          ) {
            for (t = 0; t < this.options.customBreaks.length; t++)
              this.customBreaks.push(
                new x(
                  this.chart,
                  "customBreaks",
                  this.options.customBreaks[t],
                  t,
                  ++this.chart._eventManager.lastObjectId,
                  this
                )
              ),
                "number" == typeof this.customBreaks[t].startValue &&
                  "number" == typeof this.customBreaks[t].endValue &&
                  this.customBreaks[t].endValue !==
                    this.customBreaks[t].startValue &&
                  this._appliedBreaks.push(this.customBreaks[t]);
            for (
              this._appliedBreaks.sort(function (t, e) {
                return t.startValue - e.startValue;
              }),
                t = 0;
              t < this._appliedBreaks.length - 1;
              t++
            )
              this._appliedBreaks[t].endValue >=
                this._appliedBreaks[t + 1].startValue &&
                ((this._appliedBreaks[t].endValue = Math.max(
                  this._appliedBreaks[t].endValue,
                  this._appliedBreaks[t + 1].endValue
                )),
                window.console &&
                  window.console.log(
                    "CanvasJS Error: Breaks " +
                      t +
                      " and " +
                      (t + 1) +
                      " are overlapping."
                  ),
                this._appliedBreaks.splice(t, 2),
                t--);
          }
        }
        function x(t, e, i, a, s, n) {
          x.base.constructor.call(this, "Break", e, i, a, n),
            (this.id = s),
            (this.chart = t),
            (this.ctx = this.chart.ctx),
            (this.scaleBreaks = n),
            (this.optionsName = e),
            (this.isOptionsInArray = !0),
            (this.type = i.type ? this.type : n.type),
            (this.fillOpacity = U(i.fillOpacity)
              ? n.fillOpacity
              : this.fillOpacity),
            (this.lineThickness = U(i.lineThickness)
              ? n.lineThickness
              : this.lineThickness),
            (this.color = i.color ? this.color : n.color),
            (this.lineColor = i.lineColor ? this.lineColor : n.lineColor),
            (this.lineDashType = i.lineDashType
              ? this.lineDashType
              : n.lineDashType),
            !U(this.startValue) &&
              this.startValue.getTime &&
              (this.startValue = this.startValue.getTime()),
            !U(this.endValue) &&
              this.endValue.getTime &&
              (this.endValue = this.endValue.getTime()),
            "number" == typeof this.startValue &&
              "number" == typeof this.endValue &&
              this.endValue < this.startValue &&
              ((t = this.startValue),
              (this.startValue = this.endValue),
              (this.endValue = t)),
            (this.spacing = void 0 === i.spacing ? n.spacing : i.spacing),
            "string" == typeof this.options.spacing
              ? ((this.spacing = parseFloat(this.spacing)),
                (this.spacing = isNaN(this.spacing)
                  ? 0
                  : (10 < this.spacing ? 10 : this.spacing) + "%"))
              : "number" != typeof this.options.spacing &&
                (this.spacing = n.spacing),
            (this.size = n.parent.logarithmic ? 1 : 0);
        }
        function d(t, e, i, a, s) {
          d.base.constructor.call(this, "StripLine", "stripLines", e, i, s),
            (this.id = a),
            (this.chart = t),
            (this.ctx = this.chart.ctx),
            (this.label = this.label),
            (this.axis = s),
            (this.optionsName = "stripLines"),
            (this.isOptionsInArray = !0),
            (this._thicknessType = "pixel"),
            null !== this.startValue &&
              null !== this.endValue &&
              ((this.value = s.logarithmic
                ? Math.sqrt(
                    (this.startValue.getTime
                      ? this.startValue.getTime()
                      : this.startValue) *
                      (this.endValue.getTime
                        ? this.endValue.getTime()
                        : this.endValue)
                  )
                : ((this.startValue.getTime
                    ? this.startValue.getTime()
                    : this.startValue) +
                    (this.endValue.getTime
                      ? this.endValue.getTime()
                      : this.endValue)) /
                  2),
              (this._thicknessType = null));
        }
        function c(t, e, i) {
          c.base.constructor.call(this, "Crosshair", "crosshair", e, null, i),
            (this.chart = t),
            (this.ctx = this.chart.ctx),
            (this.axis = i),
            (this.optionsName = "crosshair"),
            (this._thicknessType = "pixel");
        }
        function n(t, e) {
          n.base.constructor.call(this, "ToolTip", "toolTip", e, null, t),
            (this.chart = t),
            (this.canvas = t.canvas),
            (this.ctx = this.chart.ctx),
            (this.currentDataPointIndex = this.currentSeriesIndex = -1),
            (this._prevY = this._prevX = NaN),
            (this.containerTransitionDuration = 0.1),
            (this.mozContainerTransition = this.getContainerTransition(
              this.containerTransitionDuration
            )),
            (this.optionsName = "toolTip"),
            this._initialize();
        }
        function u(t) {
          (this.chart = t),
            (this.lastObjectId = 0),
            (this.objectMap = []),
            (this.rectangularRegionEventSubscriptions = []),
            (this.previousDataPointEventObject = null),
            (this.ghostCanvas = k(this.chart.width, this.chart.height)),
            (this.ghostCtx = this.ghostCanvas.getContext("2d")),
            (this.mouseoveredObjectMaps = []);
        }
        function m(t) {
          (this.chart = t),
            (this.ctx = this.chart.plotArea.ctx),
            (this.animations = []),
            (this.animationRequestId = null);
        }
        t(r, L),
          (r.prototype.destroy = function () {
            var t = this.allDOMEventHandlers;
            for (
              this._animator && this._animator.cancelAllAnimations(),
                this._panTimerId && clearTimeout(this._panTimerId),
                i = 0;
              i < t.length;
              i++
            ) {
              var e = t[i][0],
                a = t[i][1],
                s = t[i][2],
                n = (n = t[i][3]) || !1;
              e.removeEventListener
                ? e.removeEventListener(a, s, n)
                : e.detachEvent && e.detachEvent("on" + a, s);
            }
            for (
              this.allDOMEventHandlers = [], this.removeAllEventListeners();
              this._canvasJSContainer &&
              this._canvasJSContainer.hasChildNodes();

            )
              this._canvasJSContainer.removeChild(
                this._canvasJSContainer.lastChild
              );
            for (; this.container && this.container.hasChildNodes(); )
              this.container.removeChild(this.container.lastChild);
            for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes(); )
              this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
            (this.overlaidCanvas =
              this.canvas =
              this.container =
              this._canvasJSContainer =
                null),
              (this._toolBar =
                this._dropdownMenu =
                this._menuButton =
                this._resetButton =
                this._zoomButton =
                this._breaksCanvas =
                this._preRenderCanvas =
                this.toolTip.container =
                  null);
          }),
          (r.prototype._updateOptions = function () {
            var e = this;
            if (
              (this.updateOption("width"),
              this.updateOption("height"),
              this.updateOption("dataPointWidth"),
              this.updateOption("dataPointMinWidth"),
              this.updateOption("dataPointMaxWidth"),
              this.updateOption("interactivityEnabled"),
              this.updateOption("theme"),
              this.updateOption("colorSet") &&
                (this._selectedColorSet =
                  void 0 !== O[this.colorSet] ? O[this.colorSet] : O.colorSet1),
              this.updateOption("backgroundColor"),
              this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)"),
              this.updateOption("culture"),
              (this._cultureInfo = new X(this.options.culture)),
              this.updateOption("animationEnabled"),
              (this.animationEnabled = this.animationEnabled && Z),
              this.updateOption("animationDuration"),
              this.updateOption("rangeChanging"),
              this.updateOption("rangeChanged"),
              this.updateOption("exportEnabled"),
              this.updateOption("exportFileName"),
              this.updateOption("zoomType"),
              this.options.zoomEnabled)
            ) {
              if (!this._zoomButton) {
                var i = !1;
                F((this._zoomButton = document.createElement("button"))),
                  P(this, this._zoomButton, "pan"),
                  this._toolBar.appendChild(this._zoomButton),
                  (this._zoomButton.style.borderRight =
                    this.toolbar.borderThickness +
                    "px solid " +
                    this.toolbar.borderColor),
                  f(
                    this._zoomButton,
                    "touchstart",
                    function (t) {
                      i = !0;
                    },
                    this.allDOMEventHandlers
                  ),
                  f(
                    this._zoomButton,
                    "click",
                    function () {
                      e.zoomEnabled
                        ? ((e.zoomEnabled = !1),
                          (e.panEnabled = !0),
                          P(e, e._zoomButton, "zoom"))
                        : ((e.zoomEnabled = !0),
                          (e.panEnabled = !1),
                          P(e, e._zoomButton, "pan")),
                        e.render();
                    },
                    this.allDOMEventHandlers
                  ),
                  f(
                    this._zoomButton,
                    "mouseover",
                    function () {
                      i
                        ? (i = !1)
                        : (w(0, e._zoomButton, {
                            backgroundColor: e.toolbar.backgroundColorOnHover,
                            color: e.toolbar.fontColorOnHover,
                            transition: "0.4s",
                            WebkitTransition: "0.4s",
                          }),
                          navigator.userAgent.search("MSIE") <= 0 &&
                            w(0, e._zoomButton.childNodes[0], {
                              WebkitFilter: "invert(100%)",
                              filter: "invert(100%)",
                            }));
                    },
                    this.allDOMEventHandlers
                  ),
                  f(
                    this._zoomButton,
                    "mouseout",
                    function () {
                      i ||
                        (w(0, e._zoomButton, {
                          backgroundColor: e.toolbar.backgroundColor,
                          color: e.toolbar.fontColor,
                          transition: "0.4s",
                          WebkitTransition: "0.4s",
                        }),
                        navigator.userAgent.search("MSIE") <= 0 &&
                          w(0, e._zoomButton.childNodes[0], {
                            WebkitFilter: "invert(0%)",
                            filter: "invert(0%)",
                          }));
                    },
                    this.allDOMEventHandlers
                  );
              }
              this._resetButton ||
                ((i = !1),
                F((this._resetButton = document.createElement("button"))),
                P(this, this._resetButton, "reset"),
                (this._resetButton.style.borderRight =
                  (this.exportEnabled ? this.toolbar.borderThickness : 0) +
                  "px solid " +
                  this.toolbar.borderColor),
                this._toolBar.appendChild(this._resetButton),
                f(
                  this._resetButton,
                  "touchstart",
                  function (t) {
                    i = !0;
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this._resetButton,
                  "click",
                  function () {
                    if (
                      (e.toolTip.hide(),
                      e.zoomEnabled || e.panEnabled
                        ? ((e.zoomEnabled = !0),
                          (e.panEnabled = !1),
                          P(e, e._zoomButton, "pan"),
                          (e._defaultCursor = "default"),
                          (e.overlaidCanvas.style.cursor = e._defaultCursor))
                        : ((e.zoomEnabled = !1), (e.panEnabled = !1)),
                      e.sessionVariables.axisX)
                    )
                      for (var t = 0; t < e.sessionVariables.axisX.length; t++)
                        (e.sessionVariables.axisX[t].newViewportMinimum = null),
                          (e.sessionVariables.axisX[t].newViewportMaximum =
                            null);
                    if (e.sessionVariables.axisX2)
                      for (t = 0; t < e.sessionVariables.axisX2.length; t++)
                        (e.sessionVariables.axisX2[t].newViewportMinimum =
                          null),
                          (e.sessionVariables.axisX2[t].newViewportMaximum =
                            null);
                    if (e.sessionVariables.axisY)
                      for (t = 0; t < e.sessionVariables.axisY.length; t++)
                        (e.sessionVariables.axisY[t].newViewportMinimum = null),
                          (e.sessionVariables.axisY[t].newViewportMaximum =
                            null);
                    if (e.sessionVariables.axisY2)
                      for (t = 0; t < e.sessionVariables.axisY2.length; t++)
                        (e.sessionVariables.axisY2[t].newViewportMinimum =
                          null),
                          (e.sessionVariables.axisY2[t].newViewportMaximum =
                            null);
                    e.resetOverlayedCanvas(),
                      F(e._zoomButton, e._resetButton),
                      e._dispatchRangeEvent("rangeChanging", "reset"),
                      e.render(),
                      e._dispatchRangeEvent("rangeChanged", "reset");
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this._resetButton,
                  "mouseover",
                  function () {
                    i ||
                      (w(0, e._resetButton, {
                        backgroundColor: e.toolbar.backgroundColorOnHover,
                        color: e.toolbar.hoverFfontColorOnHoverontColor,
                        transition: "0.4s",
                        WebkitTransition: "0.4s",
                      }),
                      navigator.userAgent.search("MSIE") <= 0 &&
                        w(0, e._resetButton.childNodes[0], {
                          WebkitFilter: "invert(100%)",
                          filter: "invert(100%)",
                        }));
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  this._resetButton,
                  "mouseout",
                  function () {
                    i ||
                      (w(0, e._resetButton, {
                        backgroundColor: e.toolbar.backgroundColor,
                        color: e.toolbar.fontColor,
                        transition: "0.4s",
                        WebkitTransition: "0.4s",
                      }),
                      navigator.userAgent.search("MSIE") <= 0 &&
                        w(0, e._resetButton.childNodes[0], {
                          WebkitFilter: "invert(0%)",
                          filter: "invert(0%)",
                        }));
                  },
                  this.allDOMEventHandlers
                ),
                (this.overlaidCanvas.style.cursor = e._defaultCursor)),
                this.zoomEnabled ||
                  this.panEnabled ||
                  (this._zoomButton
                    ? (e._zoomButton.getAttribute("state") ===
                      e._cultureInfo.zoomText
                        ? ((this.panEnabled = !0), (this.zoomEnabled = !1))
                        : ((this.zoomEnabled = !0), (this.panEnabled = !1)),
                      S(e._zoomButton, e._resetButton))
                    : ((this.zoomEnabled = !0), (this.panEnabled = !1)));
            } else this.panEnabled = this.zoomEnabled = !1;
            if (
              (this._menuButton
                ? this.exportEnabled
                  ? S(this._menuButton)
                  : F(this._menuButton)
                : this.exportEnabled &&
                  Z &&
                  ((i = !1),
                  (this._menuButton = document.createElement("button")),
                  P(this, this._menuButton, "menu"),
                  this._toolBar.appendChild(this._menuButton),
                  f(
                    this._menuButton,
                    "touchstart",
                    function (t) {
                      i = !0;
                    },
                    this.allDOMEventHandlers
                  ),
                  f(
                    this._menuButton,
                    "click",
                    function () {
                      "none" !== e._dropdownMenu.style.display ||
                        (e._dropDownCloseTime &&
                          new Date().getTime() -
                            e._dropDownCloseTime.getTime() <=
                            500) ||
                        ((e._dropdownMenu.style.display = "block"),
                        e._menuButton.blur(),
                        e._dropdownMenu.focus());
                    },
                    this.allDOMEventHandlers,
                    !0
                  ),
                  f(
                    this._menuButton,
                    "mouseover",
                    function () {
                      i ||
                        (w(0, e._menuButton, {
                          backgroundColor: e.toolbar.backgroundColorOnHover,
                          color: e.toolbar.fontColorOnHover,
                        }),
                        navigator.userAgent.search("MSIE") <= 0 &&
                          w(0, e._menuButton.childNodes[0], {
                            WebkitFilter: "invert(100%)",
                            filter: "invert(100%)",
                          }));
                    },
                    this.allDOMEventHandlers,
                    !0
                  ),
                  f(
                    this._menuButton,
                    "mouseout",
                    function () {
                      i ||
                        (w(0, e._menuButton, {
                          backgroundColor: e.toolbar.backgroundColor,
                          color: e.toolbar.fontColor,
                        }),
                        navigator.userAgent.search("MSIE") <= 0 &&
                          w(0, e._menuButton.childNodes[0], {
                            WebkitFilter: "invert(0%)",
                            filter: "invert(0%)",
                          }));
                    },
                    this.allDOMEventHandlers,
                    !0
                  )),
              !this._dropdownMenu && this.exportEnabled && Z)
            ) {
              (i = !1),
                (this._dropdownMenu = document.createElement("div")),
                this._dropdownMenu.setAttribute("tabindex", -1);
              var t = -1 !== this.theme.indexOf("dark") ? "black" : "#888888";
              (this._dropdownMenu.style.cssText =
                "position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:" +
                this.toolbar.backgroundColor +
                ";box-shadow: 2px 2px 10px " +
                t),
                (e._dropdownMenu.style.display = "none"),
                this._toolBar.appendChild(this._dropdownMenu),
                f(
                  this._dropdownMenu,
                  "blur",
                  function () {
                    F(e._dropdownMenu), (e._dropDownCloseTime = new Date());
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                ((t = document.createElement("div")).style.cssText =
                  "padding: 12px 8px 12px 8px"),
                (t.innerHTML = this._cultureInfo.printText),
                (t.style.backgroundColor = this.toolbar.backgroundColor),
                (t.style.color = this.toolbar.fontColor),
                this._dropdownMenu.appendChild(t),
                f(
                  t,
                  "touchstart",
                  function (t) {
                    i = !0;
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  t,
                  "mouseover",
                  function () {
                    i ||
                      ((this.style.backgroundColor =
                        e.toolbar.backgroundColorOnHover),
                      (this.style.color = e.toolbar.fontColorOnHover));
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                f(
                  t,
                  "mouseout",
                  function () {
                    i ||
                      ((this.style.backgroundColor = e.toolbar.backgroundColor),
                      (this.style.color = e.toolbar.fontColor));
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                f(
                  t,
                  "click",
                  function () {
                    e.print(), F(e._dropdownMenu);
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                ((t = document.createElement("div")).style.cssText =
                  "padding: 12px 8px 12px 8px"),
                (t.innerHTML = this._cultureInfo.saveJPGText),
                (t.style.backgroundColor = this.toolbar.backgroundColor),
                (t.style.color = this.toolbar.fontColor),
                this._dropdownMenu.appendChild(t),
                f(
                  t,
                  "touchstart",
                  function (t) {
                    i = !0;
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  t,
                  "mouseover",
                  function () {
                    i ||
                      ((this.style.backgroundColor =
                        e.toolbar.backgroundColorOnHover),
                      (this.style.color = e.toolbar.fontColorOnHover));
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                f(
                  t,
                  "mouseout",
                  function () {
                    i ||
                      ((this.style.backgroundColor = e.toolbar.backgroundColor),
                      (this.style.color = e.toolbar.fontColor));
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                f(
                  t,
                  "click",
                  function () {
                    s(e.canvas, "jpeg", e.exportFileName), F(e._dropdownMenu);
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                ((t = document.createElement("div")).style.cssText =
                  "padding: 12px 8px 12px 8px"),
                (t.innerHTML = this._cultureInfo.savePNGText),
                (t.style.backgroundColor = this.toolbar.backgroundColor),
                (t.style.color = this.toolbar.fontColor),
                this._dropdownMenu.appendChild(t),
                f(
                  t,
                  "touchstart",
                  function (t) {
                    i = !0;
                  },
                  this.allDOMEventHandlers
                ),
                f(
                  t,
                  "mouseover",
                  function () {
                    i ||
                      ((this.style.backgroundColor =
                        e.toolbar.backgroundColorOnHover),
                      (this.style.color = e.toolbar.fontColorOnHover));
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                f(
                  t,
                  "mouseout",
                  function () {
                    i ||
                      ((this.style.backgroundColor = e.toolbar.backgroundColor),
                      (this.style.color = e.toolbar.fontColor));
                  },
                  this.allDOMEventHandlers,
                  !0
                ),
                f(
                  t,
                  "click",
                  function () {
                    s(e.canvas, "png", e.exportFileName), F(e._dropdownMenu);
                  },
                  this.allDOMEventHandlers,
                  !0
                );
            }
            for (var a in ("none" !== this._toolBar.style.display &&
              this._zoomButton &&
              (this.panEnabled
                ? P(e, e._zoomButton, "zoom")
                : P(e, e._zoomButton, "pan"),
              e._resetButton.getAttribute("state") !==
                e._cultureInfo.resetText && P(e, e._resetButton, "reset")),
            this.options.toolTip &&
              this.toolTip.options !== this.options.toolTip &&
              (this.toolTip.options = this.options.toolTip),
            this.toolTip.options))
              this.toolTip.options.hasOwnProperty(a) &&
                this.toolTip.updateOption(a);
          }),
          (r.prototype._updateSize = function () {
            var t = 0,
              e = 0;
            return (
              this.options.width
                ? (t = this.width)
                : (this.width = t =
                    0 < this.container.clientWidth
                      ? this.container.clientWidth
                      : this.width),
              this.options.height
                ? (e = this.height)
                : (this.height = e =
                    0 < this.container.clientHeight
                      ? this.container.clientHeight
                      : this.height),
              (this.canvas.width !== t * lt || this.canvas.height !== e * lt) &&
                (M(this.canvas, t, e),
                M(this._preRenderCanvas, t, e),
                M(this.overlaidCanvas, t, e),
                M(this._eventManager.ghostCanvas, t, e),
                (this.bounds = {
                  x1: 0,
                  y1: 0,
                  x2: this.width,
                  y2: this.height,
                }),
                !0)
            );
          }),
          (r.prototype._initialize = function () {
            (this.toolbar = new V(this, this.options.toolbar)),
              this._animator
                ? this._animator.cancelAllAnimations()
                : (this._animator = new m(this)),
              this.removeAllEventListeners(),
              (this.disableToolTip = !1),
              (this._axes = []),
              (this.funnelPyramidClickHandler = this.pieDoughnutClickHandler =
                null),
              this._updateOptions(),
              (this.animatedRender =
                Z && this.animationEnabled && 0 === this.renderCount),
              this._updateSize(),
              this.clearCanvas(),
              this.ctx.beginPath(),
              (this.axisX = []),
              (this.axisX2 = []),
              (this.axisY = []),
              (this.axisY2 = []),
              (this._indexLabels = []),
              (this._dataInRenderedOrder = []),
              (this._events = []),
              this._eventManager && this._eventManager.reset(),
              (this.plotInfo = { axisPlacement: null, plotTypes: [] }),
              (this.layoutManager = new D(0, 0, this.width, this.height, 2)),
              this.plotArea.layoutManager &&
                this.plotArea.layoutManager.reset(),
              (this.data = []);
            var t = 0,
              e = null;
            if (this.options.data) {
              for (var i = 0; i < this.options.data.length; i++)
                if (
                  (t++,
                  !this.options.data[i].type ||
                    0 <=
                      r._supportedChartTypes.indexOf(this.options.data[i].type))
                ) {
                  var a = new T(
                    this,
                    this.options.data[i],
                    t - 1,
                    ++this._eventManager.lastObjectId
                  );
                  "error" === a.type &&
                    ((a.linkedDataSeriesIndex = U(
                      this.options.data[i].linkedDataSeriesIndex
                    )
                      ? i - 1
                      : this.options.data[i].linkedDataSeriesIndex),
                    a.linkedDataSeriesIndex < 0 ||
                      a.linkedDataSeriesIndex >= this.options.data.length ||
                      "number" != typeof a.linkedDataSeriesIndex ||
                      "error" ===
                        this.options.data[a.linkedDataSeriesIndex].type) &&
                    (a.linkedDataSeriesIndex = null),
                    null === a.name && (a.name = "DataSeries " + t),
                    null === a.color
                      ? 1 < this.options.data.length
                        ? ((a._colorSet = [
                            this._selectedColorSet[
                              a.index % this._selectedColorSet.length
                            ],
                          ]),
                          (a.color =
                            this._selectedColorSet[
                              a.index % this._selectedColorSet.length
                            ]))
                        : (a._colorSet =
                            "line" === a.type ||
                            "stepLine" === a.type ||
                            "spline" === a.type ||
                            "area" === a.type ||
                            "stepArea" === a.type ||
                            "splineArea" === a.type ||
                            "stackedArea" === a.type ||
                            "stackedArea100" === a.type ||
                            "rangeArea" === a.type ||
                            "rangeSplineArea" === a.type ||
                            "candlestick" === a.type ||
                            "ohlc" === a.type ||
                            "waterfall" === a.type ||
                            "boxAndWhisker" === a.type
                              ? [this._selectedColorSet[0]]
                              : this._selectedColorSet)
                      : (a._colorSet = [a.color]),
                    null === a.markerSize &&
                      ((("line" === a.type ||
                        "stepLine" === a.type ||
                        "spline" === a.type ||
                        0 <= a.type.toLowerCase().indexOf("area")) &&
                        a.dataPoints &&
                        a.dataPoints.length < this.width / 16) ||
                        "scatter" === a.type) &&
                      (a.markerSize = 8),
                    ("bubble" !== a.type && "scatter" !== a.type) ||
                      !a.dataPoints ||
                      (a.dataPoints.some
                        ? a.dataPoints.some(function (t) {
                            return t.x;
                          }) && a.dataPoints.sort(o)
                        : a.dataPoints.sort(o)),
                    this.data.push(a);
                  var s,
                    n = a.axisPlacement;
                  e = e || n;
                  if (
                    ("normal" === n
                      ? "xySwapped" === this.plotInfo.axisPlacement
                        ? (s =
                            'You cannot combine "' +
                            a.type +
                            '" with bar chart')
                        : "none" === this.plotInfo.axisPlacement
                        ? (s =
                            'You cannot combine "' +
                            a.type +
                            '" with pie chart')
                        : null === this.plotInfo.axisPlacement &&
                          (this.plotInfo.axisPlacement = "normal")
                      : "xySwapped" === n
                      ? "normal" === this.plotInfo.axisPlacement
                        ? (s =
                            'You cannot combine "' +
                            a.type +
                            '" with line, area, column or pie chart')
                        : "none" === this.plotInfo.axisPlacement
                        ? (s =
                            'You cannot combine "' +
                            a.type +
                            '" with pie chart')
                        : null === this.plotInfo.axisPlacement &&
                          (this.plotInfo.axisPlacement = "xySwapped")
                      : "none" === n
                      ? "normal" === this.plotInfo.axisPlacement
                        ? (s =
                            'You cannot combine "' +
                            a.type +
                            '" with line, area, column or bar chart')
                        : "xySwapped" === this.plotInfo.axisPlacement
                        ? (s =
                            'You cannot combine "' +
                            a.type +
                            '" with bar chart')
                        : null === this.plotInfo.axisPlacement &&
                          (this.plotInfo.axisPlacement = "none")
                      : null === n &&
                        "none" === this.plotInfo.axisPlacement &&
                        (s =
                          'You cannot combine "' + a.type + '" with pie chart'),
                    s && window.console)
                  )
                    return void window.console.log(s);
                }
              for (i = 0; i < this.data.length; i++) {
                if (
                  "none" == e &&
                  "error" === this.data[i].type &&
                  window.console
                )
                  return void window.console.log(
                    'You cannot combine "' + a.type + '" with error chart'
                  );
                "error" === this.data[i].type &&
                  ((this.data[i].axisPlacement = this.plotInfo.axisPlacement =
                    e || "normal"),
                  (this.data[i]._linkedSeries =
                    null === this.data[i].linkedDataSeriesIndex
                      ? null
                      : this.data[this.data[i].linkedDataSeriesIndex]));
              }
            }
            this._objectsInitialized = !0;
          }),
          (r._supportedChartTypes = q(
            "line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(
              " "
            )
          )),
          (r.prototype.render = function (t) {
            t && (this.options = t), this._initialize();
            var e,
              i = [];
            for (t = 0; t < this.data.length; t++)
              if (
                "normal" === this.plotInfo.axisPlacement ||
                "xySwapped" === this.plotInfo.axisPlacement
              ) {
                if (
                  !this.data[t].axisYType ||
                  "primary" === this.data[t].axisYType
                )
                  if (this.options.axisY && 0 < this.options.axisY.length) {
                    if (!this.axisY.length)
                      for (var a = 0; a < this.options.axisY.length; a++)
                        "normal" === this.plotInfo.axisPlacement
                          ? this._axes.push(
                              (this.axisY[a] = new v(
                                this,
                                "axisY",
                                this.options.axisY[a],
                                a,
                                "axisY",
                                "left"
                              ))
                            )
                          : "xySwapped" === this.plotInfo.axisPlacement &&
                            this._axes.push(
                              (this.axisY[a] = new v(
                                this,
                                "axisY",
                                this.options.axisY[a],
                                a,
                                "axisY",
                                "bottom"
                              ))
                            );
                    (this.data[t].axisY =
                      this.axisY[
                        0 <= this.data[t].axisYIndex &&
                        this.data[t].axisYIndex < this.axisY.length
                          ? this.data[t].axisYIndex
                          : 0
                      ]),
                      this.axisY[
                        0 <= this.data[t].axisYIndex &&
                        this.data[t].axisYIndex < this.axisY.length
                          ? this.data[t].axisYIndex
                          : 0
                      ].dataSeries.push(this.data[t]);
                  } else
                    this.axisY.length ||
                      ("normal" === this.plotInfo.axisPlacement
                        ? this._axes.push(
                            (this.axisY[0] = new v(
                              this,
                              "axisY",
                              this.options.axisY,
                              0,
                              "axisY",
                              "left"
                            ))
                          )
                        : "xySwapped" === this.plotInfo.axisPlacement &&
                          this._axes.push(
                            (this.axisY[0] = new v(
                              this,
                              "axisY",
                              this.options.axisY,
                              0,
                              "axisY",
                              "bottom"
                            ))
                          )),
                      (this.data[t].axisY = this.axisY[0]),
                      this.axisY[0].dataSeries.push(this.data[t]);
                if ("secondary" === this.data[t].axisYType)
                  if (this.options.axisY2 && 0 < this.options.axisY2.length) {
                    if (!this.axisY2.length)
                      for (a = 0; a < this.options.axisY2.length; a++)
                        "normal" === this.plotInfo.axisPlacement
                          ? this._axes.push(
                              (this.axisY2[a] = new v(
                                this,
                                "axisY2",
                                this.options.axisY2[a],
                                a,
                                "axisY",
                                "right"
                              ))
                            )
                          : "xySwapped" === this.plotInfo.axisPlacement &&
                            this._axes.push(
                              (this.axisY2[a] = new v(
                                this,
                                "axisY2",
                                this.options.axisY2[a],
                                a,
                                "axisY",
                                "top"
                              ))
                            );
                    (this.data[t].axisY =
                      this.axisY2[
                        0 <= this.data[t].axisYIndex &&
                        this.data[t].axisYIndex < this.axisY2.length
                          ? this.data[t].axisYIndex
                          : 0
                      ]),
                      this.axisY2[
                        0 <= this.data[t].axisYIndex &&
                        this.data[t].axisYIndex < this.axisY2.length
                          ? this.data[t].axisYIndex
                          : 0
                      ].dataSeries.push(this.data[t]);
                  } else
                    this.axisY2.length ||
                      ("normal" === this.plotInfo.axisPlacement
                        ? this._axes.push(
                            (this.axisY2[0] = new v(
                              this,
                              "axisY2",
                              this.options.axisY2,
                              0,
                              "axisY",
                              "right"
                            ))
                          )
                        : "xySwapped" === this.plotInfo.axisPlacement &&
                          this._axes.push(
                            (this.axisY2[0] = new v(
                              this,
                              "axisY2",
                              this.options.axisY2,
                              0,
                              "axisY",
                              "top"
                            ))
                          )),
                      (this.data[t].axisY = this.axisY2[0]),
                      this.axisY2[0].dataSeries.push(this.data[t]);
                if (
                  !this.data[t].axisXType ||
                  "primary" === this.data[t].axisXType
                )
                  if (this.options.axisX && 0 < this.options.axisX.length) {
                    if (!this.axisX.length)
                      for (a = 0; a < this.options.axisX.length; a++)
                        "normal" === this.plotInfo.axisPlacement
                          ? this._axes.push(
                              (this.axisX[a] = new v(
                                this,
                                "axisX",
                                this.options.axisX[a],
                                a,
                                "axisX",
                                "bottom"
                              ))
                            )
                          : "xySwapped" === this.plotInfo.axisPlacement &&
                            this._axes.push(
                              (this.axisX[a] = new v(
                                this,
                                "axisX",
                                this.options.axisX[a],
                                a,
                                "axisX",
                                "left"
                              ))
                            );
                    (this.data[t].axisX =
                      this.axisX[
                        0 <= this.data[t].axisXIndex &&
                        this.data[t].axisXIndex < this.axisX.length
                          ? this.data[t].axisXIndex
                          : 0
                      ]),
                      this.axisX[
                        0 <= this.data[t].axisXIndex &&
                        this.data[t].axisXIndex < this.axisX.length
                          ? this.data[t].axisXIndex
                          : 0
                      ].dataSeries.push(this.data[t]);
                  } else
                    this.axisX.length ||
                      ("normal" === this.plotInfo.axisPlacement
                        ? this._axes.push(
                            (this.axisX[0] = new v(
                              this,
                              "axisX",
                              this.options.axisX,
                              0,
                              "axisX",
                              "bottom"
                            ))
                          )
                        : "xySwapped" === this.plotInfo.axisPlacement &&
                          this._axes.push(
                            (this.axisX[0] = new v(
                              this,
                              "axisX",
                              this.options.axisX,
                              0,
                              "axisX",
                              "left"
                            ))
                          )),
                      (this.data[t].axisX = this.axisX[0]),
                      this.axisX[0].dataSeries.push(this.data[t]);
                if ("secondary" === this.data[t].axisXType)
                  if (this.options.axisX2 && 0 < this.options.axisX2.length) {
                    if (!this.axisX2.length)
                      for (a = 0; a < this.options.axisX2.length; a++)
                        "normal" === this.plotInfo.axisPlacement
                          ? this._axes.push(
                              (this.axisX2[a] = new v(
                                this,
                                "axisX2",
                                this.options.axisX2[a],
                                a,
                                "axisX",
                                "top"
                              ))
                            )
                          : "xySwapped" === this.plotInfo.axisPlacement &&
                            this._axes.push(
                              (this.axisX2[a] = new v(
                                this,
                                "axisX2",
                                this.options.axisX2[a],
                                a,
                                "axisX",
                                "right"
                              ))
                            );
                    (this.data[t].axisX =
                      this.axisX2[
                        0 <= this.data[t].axisXIndex &&
                        this.data[t].axisXIndex < this.axisX2.length
                          ? this.data[t].axisXIndex
                          : 0
                      ]),
                      this.axisX2[
                        0 <= this.data[t].axisXIndex &&
                        this.data[t].axisXIndex < this.axisX2.length
                          ? this.data[t].axisXIndex
                          : 0
                      ].dataSeries.push(this.data[t]);
                  } else
                    this.axisX2.length ||
                      ("normal" === this.plotInfo.axisPlacement
                        ? this._axes.push(
                            (this.axisX2[0] = new v(
                              this,
                              "axisX2",
                              this.options.axisX2,
                              0,
                              "axisX",
                              "top"
                            ))
                          )
                        : "xySwapped" === this.plotInfo.axisPlacement &&
                          this._axes.push(
                            (this.axisX2[0] = new v(
                              this,
                              "axisX2",
                              this.options.axisX2,
                              0,
                              "axisX",
                              "right"
                            ))
                          )),
                      (this.data[t].axisX = this.axisX2[0]),
                      this.axisX2[0].dataSeries.push(this.data[t]);
              }
            if (this.axisY) {
              for (a = 1; a < this.axisY.length; a++)
                void 0 === this.axisY[a].options.gridThickness &&
                  (this.axisY[a].gridThickness = 0);
              for (a = 0; a < this.axisY.length - 1; a++)
                void 0 === this.axisY[a].options.margin &&
                  (this.axisY[a].margin = 10);
            }
            if (this.axisY2) {
              for (a = 1; a < this.axisY2.length; a++)
                void 0 === this.axisY2[a].options.gridThickness &&
                  (this.axisY2[a].gridThickness = 0);
              for (a = 0; a < this.axisY2.length - 1; a++)
                void 0 === this.axisY2[a].options.margin &&
                  (this.axisY2[a].margin = 10);
            }
            if (
              (this.axisY &&
                0 < this.axisY.length &&
                this.axisY2 &&
                0 < this.axisY2.length &&
                (0 < this.axisY[0].gridThickness &&
                void 0 === this.axisY2[0].options.gridThickness
                  ? (this.axisY2[0].gridThickness = 0)
                  : 0 < this.axisY2[0].gridThickness &&
                    void 0 === this.axisY[0].options.gridThickness &&
                    (this.axisY[0].gridThickness = 0)),
              this.axisX)
            )
              for (a = 0; a < this.axisX.length; a++)
                void 0 === this.axisX[a].options.gridThickness &&
                  (this.axisX[a].gridThickness = 0);
            if (this.axisX2)
              for (a = 0; a < this.axisX2.length; a++)
                void 0 === this.axisX2[a].options.gridThickness &&
                  (this.axisX2[a].gridThickness = 0);
            if (
              (this.axisX &&
                0 < this.axisX.length &&
                this.axisX2 &&
                0 < this.axisX2.length &&
                (0 < this.axisX[0].gridThickness &&
                void 0 === this.axisX2[0].options.gridThickness
                  ? (this.axisX2[0].gridThickness = 0)
                  : 0 < this.axisX2[0].gridThickness &&
                    void 0 === this.axisX[0].options.gridThickness &&
                    (this.axisX[0].gridThickness = 0)),
              (a = !1),
              0 < this._axes.length && (this.zoomEnabled || this.panEnabled))
            )
              for (t = 0; t < this._axes.length; t++)
                if (
                  null !== this._axes[t].viewportMinimum ||
                  null !== this._axes[t].viewportMaximum
                ) {
                  a = !0;
                  break;
                }
            if (
              (a
                ? (S(this._zoomButton, this._resetButton),
                  (this._toolBar.style.border =
                    this.toolbar.borderThickness +
                    "px solid " +
                    this.toolbar.borderColor),
                  (this._zoomButton.style.borderRight =
                    this.toolbar.borderThickness +
                    "px solid " +
                    this.toolbar.borderColor),
                  (this._resetButton.style.borderRight =
                    (this.exportEnabled ? this.toolbar.borderThickness : 0) +
                    "px solid " +
                    this.toolbar.borderColor))
                : (F(this._zoomButton, this._resetButton),
                  (this._toolBar.style.border =
                    this.toolbar.borderThickness + "px solid transparent"),
                  this.options.zoomEnabled &&
                    ((this.zoomEnabled = !0), (this.panEnabled = !1))),
              (e = this),
              J.fSDec &&
                e[ht("`eeDwdouMhrudods")](
                  ht("e`u`@ohl`uhnoHuds`uhnoDoe"),
                  function () {
                    J._fTWm && J._fTWm(e);
                  }
                ),
              this._processData(),
              this.options.title &&
                ((this.title = new z(this, this.options.title)),
                this.title.dockInsidePlotArea
                  ? i.push(this.title)
                  : this.title.render()),
              this.options.subtitles)
            )
              for (
                this.subtitles = [], t = 0;
                t < this.options.subtitles.length;
                t++
              )
                (a = new W(this, this.options.subtitles[t], t)),
                  this.subtitles.push(a),
                  a.dockInsidePlotArea ? i.push(a) : a.render();
            for (
              this.legend = new p(this, this.options.legend), t = 0;
              t < this.data.length;
              t++
            )
              (this.data[t].showInLegend ||
                "pie" === this.data[t].type ||
                "doughnut" === this.data[t].type ||
                "funnel" === this.data[t].type ||
                "pyramid" === this.data[t].type) &&
                this.legend.dataSeries.push(this.data[t]);
            for (
              this.legend.dockInsidePlotArea
                ? i.push(this.legend)
                : this.legend.render(),
                t = 0;
              t < this._axes.length;
              t++
            )
              if (
                this._axes[t].scaleBreaks &&
                this._axes[t].scaleBreaks._appliedBreaks.length
              ) {
                this._breaksCanvasCtx = Z
                  ? ((this._breaksCanvas = k(this.width, this.height)),
                    this._breaksCanvas.getContext("2d"))
                  : ((this._breaksCanvas = this.canvas), this.ctx);
                break;
              }
            if (
              ((this._preRenderCanvas = k(this.width, this.height)),
              (this._preRenderCtx = this._preRenderCanvas.getContext("2d")),
              "normal" === this.plotInfo.axisPlacement ||
                "xySwapped" === this.plotInfo.axisPlacement)
            )
              v.setLayoutAndRender(
                this.axisX,
                this.axisX2,
                this.axisY,
                this.axisY2,
                this.plotInfo.axisPlacement,
                this.layoutManager.getFreeSpace()
              );
            else {
              if ("none" !== this.plotInfo.axisPlacement) return;
              this.preparePlotArea();
            }
            for (t = 0; t < i.length; t++) i[t].render();
            var s = [];
            if (this.animatedRender) {
              var n = k(this.width, this.height);
              n.getContext("2d").drawImage(
                this.canvas,
                0,
                0,
                this.width,
                this.height
              );
            }
            !(function (t) {
              if (!ct) {
                var e = !1,
                  i = !1;
                void 0 === Y.Chart.creditHref
                  ? ((t.creditHref = ht("iuuqr;..b`ow`rkr/bnl.")),
                    (t.creditText = ht("B`ow`rKR/bnl")))
                  : ((e = t.updateOption("creditText")),
                    (i = t.updateOption("creditHref"))),
                  t.creditHref &&
                    t.creditText &&
                    (t._creditLink ||
                      ((t._creditLink = document.createElement("a")),
                      t._creditLink.setAttribute(
                        "class",
                        "canvasjs-chart-credit"
                      ),
                      t._creditLink.setAttribute("title", "JavaScript Charts"),
                      t._creditLink.setAttribute(
                        "style",
                        "outline:none;margin:0px;position:absolute;right:2px;top:" +
                          (t.height - 14) +
                          "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"
                      ),
                      t._creditLink.setAttribute("tabIndex", -1),
                      t._creditLink.setAttribute("target", "_blank")),
                    (0 === t.renderCount || e || i) &&
                      (t._creditLink.setAttribute("href", t.creditHref),
                      (t._creditLink.innerHTML = t.creditText)),
                    t._creditLink && t.creditHref && t.creditText
                      ? (t._creditLink.parentElement ||
                          t._canvasJSContainer.appendChild(t._creditLink),
                        (t._creditLink.style.top = t.height - 14 + "px"))
                      : t._creditLink.parentElement &&
                        t._canvasJSContainer.removeChild(t._creditLink));
              }
            })(this);
            var o;
            i = this.ctx.miterLimit;
            for (
              this.ctx.miterLimit = 3,
                Z &&
                  this._breaksCanvas &&
                  (this._preRenderCtx.drawImage(
                    this.canvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  this._preRenderCtx.drawImage(
                    this._breaksCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (this._breaksCanvasCtx.globalCompositeOperation =
                    "source-atop"),
                  this._breaksCanvasCtx.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  this._preRenderCtx.clearRect(0, 0, this.width, this.height)),
                t = 0;
              t < this.plotInfo.plotTypes.length;
              t++
            )
              for (
                var r = this.plotInfo.plotTypes[t], l = 0;
                l < r.plotUnits.length;
                l++
              ) {
                var h = r.plotUnits[l],
                  d = null;
                for (
                  h.targetCanvas = null,
                    this.animatedRender &&
                      ((h.targetCanvas = k(this.width, this.height)),
                      (h.targetCanvasCtx = h.targetCanvas.getContext("2d")),
                      (o = h.targetCanvasCtx.miterLimit),
                      (h.targetCanvasCtx.miterLimit = 3)),
                    "line" === h.type
                      ? (d = this.renderLine(h))
                      : "stepLine" === h.type
                      ? (d = this.renderStepLine(h))
                      : "spline" === h.type
                      ? (d = this.renderSpline(h))
                      : "column" === h.type
                      ? (d = this.renderColumn(h))
                      : "bar" === h.type
                      ? (d = this.renderBar(h))
                      : "area" === h.type
                      ? (d = this.renderArea(h))
                      : "stepArea" === h.type
                      ? (d = this.renderStepArea(h))
                      : "splineArea" === h.type
                      ? (d = this.renderSplineArea(h))
                      : "stackedColumn" === h.type
                      ? (d = this.renderStackedColumn(h))
                      : "stackedColumn100" === h.type
                      ? (d = this.renderStackedColumn100(h))
                      : "stackedBar" === h.type
                      ? (d = this.renderStackedBar(h))
                      : "stackedBar100" === h.type
                      ? (d = this.renderStackedBar100(h))
                      : "stackedArea" === h.type
                      ? (d = this.renderStackedArea(h))
                      : "stackedArea100" === h.type
                      ? (d = this.renderStackedArea100(h))
                      : "bubble" === h.type
                      ? (d = d = this.renderBubble(h))
                      : "scatter" === h.type
                      ? (d = this.renderScatter(h))
                      : "pie" === h.type
                      ? this.renderPie(h)
                      : "doughnut" === h.type
                      ? this.renderPie(h)
                      : "funnel" === h.type
                      ? (d = this.renderFunnel(h))
                      : "pyramid" === h.type
                      ? (d = this.renderFunnel(h))
                      : "candlestick" === h.type
                      ? (d = this.renderCandlestick(h))
                      : "ohlc" === h.type
                      ? (d = this.renderCandlestick(h))
                      : "rangeColumn" === h.type
                      ? (d = this.renderRangeColumn(h))
                      : "error" === h.type
                      ? (d = this.renderError(h))
                      : "rangeBar" === h.type
                      ? (d = this.renderRangeBar(h))
                      : "rangeArea" === h.type
                      ? (d = this.renderRangeArea(h))
                      : "rangeSplineArea" === h.type
                      ? (d = this.renderRangeSplineArea(h))
                      : "waterfall" === h.type
                      ? (d = this.renderWaterfall(h))
                      : "boxAndWhisker" === h.type &&
                        (d = this.renderBoxAndWhisker(h)),
                    a = 0;
                  a < h.dataSeriesIndexes.length;
                  a++
                )
                  this._dataInRenderedOrder.push(
                    this.data[h.dataSeriesIndexes[a]]
                  );
                this.animatedRender &&
                  ((h.targetCanvasCtx.miterLimit = o), d && s.push(d));
              }
            (this.ctx.miterLimit = i),
              this.animatedRender &&
                this._breaksCanvasCtx &&
                s.push({
                  source: this._breaksCanvasCtx,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                  startTimePercent: 0.7,
                }),
              this.animatedRender &&
                0 < this._indexLabels.length &&
                ((o = k(this.width, this.height).getContext("2d")),
                s.push(this.renderIndexLabels(o)));
            var c = this;
            if (0 < s.length)
              (c.disableToolTip = !0),
                c._animator.animate(
                  200,
                  c.animationDuration,
                  function (t) {
                    c.ctx.clearRect(0, 0, c.width, c.height),
                      c.ctx.drawImage(
                        n,
                        0,
                        0,
                        Math.floor(c.width * lt),
                        Math.floor(c.height * lt),
                        0,
                        0,
                        c.width,
                        c.height
                      );
                    for (var e = 0; e < s.length; e++)
                      (d = s[e]),
                        t < 1 && void 0 !== d.startTimePercent
                          ? t >= d.startTimePercent &&
                            d.animationCallback(
                              d.easingFunction(
                                t - d.startTimePercent,
                                0,
                                1,
                                1 - d.startTimePercent
                              ),
                              d
                            )
                          : d.animationCallback(
                              d.easingFunction(t, 0, 1, 1),
                              d
                            );
                    c.dispatchEvent("dataAnimationIterationEnd", { chart: c });
                  },
                  function () {
                    s = [];
                    for (var t = 0; t < c.plotInfo.plotTypes.length; t++)
                      for (
                        var e = c.plotInfo.plotTypes[t], i = 0;
                        i < e.plotUnits.length;
                        i++
                      )
                        e.plotUnits[i].targetCanvas = null;
                    (n = null), (c.disableToolTip = !1);
                  }
                );
            else {
              if (c._breaksCanvas)
                if (Z)
                  c.plotArea.ctx.drawImage(
                    c._breaksCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  );
                else
                  for (a = 0; a < c._axes.length; a++) c._axes[a].createMask();
              0 < c._indexLabels.length && c.renderIndexLabels(),
                c.dispatchEvent("dataAnimationIterationEnd", { chart: c });
            }
            for (
              this.attachPlotAreaEventHandlers(),
                this.zoomEnabled ||
                  this.panEnabled ||
                  !this._zoomButton ||
                  "none" === this._zoomButton.style.display ||
                  F(this._zoomButton, this._resetButton),
                this.toolTip._updateToolTip(),
                this.renderCount++,
                this._breaksCanvas &&
                  (delete this._breaksCanvas, delete this._breaksCanvasCtx),
                a = 0;
              a < this._axes.length;
              a++
            )
              this._axes[a].maskCanvas &&
                (delete this._axes[a].maskCanvas, delete this._axes[a].maskCtx);
          }),
          (r.prototype.attachPlotAreaEventHandlers = function () {
            this.attachEvent({
              context: this,
              chart: this,
              mousedown: this._plotAreaMouseDown,
              mouseup: this._plotAreaMouseUp,
              mousemove: this._plotAreaMouseMove,
              cursor: this.panEnabled ? "move" : "default",
              capture: !0,
              bounds: this.plotArea,
            });
          }),
          (r.prototype.categoriseDataSeries = function () {
            for (var t = "", e = 0; e < this.data.length; e++)
              if (
                (t = this.data[e]).dataPoints &&
                0 !== t.dataPoints.length &&
                t.visible &&
                0 <= r._supportedChartTypes.indexOf(t.type)
              ) {
                for (
                  var i = null, a = !1, s = null, n = !1, o = 0;
                  o < this.plotInfo.plotTypes.length;
                  o++
                )
                  if (this.plotInfo.plotTypes[o].type === t.type) {
                    (a = !0), (i = this.plotInfo.plotTypes[o]);
                    break;
                  }
                for (
                  a ||
                    ((i = { type: t.type, totalDataSeries: 0, plotUnits: [] }),
                    this.plotInfo.plotTypes.push(i)),
                    o = 0;
                  o < i.plotUnits.length;
                  o++
                )
                  if (
                    i.plotUnits[o].axisYType === t.axisYType &&
                    i.plotUnits[o].axisXType === t.axisXType &&
                    i.plotUnits[o].axisYIndex === t.axisYIndex &&
                    i.plotUnits[o].axisXIndex === t.axisXIndex
                  ) {
                    (n = !0), (s = i.plotUnits[o]);
                    break;
                  }
                n ||
                  ((s = {
                    type: t.type,
                    previousDataSeriesCount: 0,
                    index: i.plotUnits.length,
                    plotType: i,
                    axisXType: t.axisXType,
                    axisYType: t.axisYType,
                    axisYIndex: t.axisYIndex,
                    axisXIndex: t.axisXIndex,
                    axisY:
                      "primary" === t.axisYType
                        ? this.axisY[
                            0 <= t.axisYIndex &&
                            t.axisYIndex < this.axisY.length
                              ? t.axisYIndex
                              : 0
                          ]
                        : this.axisY2[
                            0 <= t.axisYIndex &&
                            t.axisYIndex < this.axisY2.length
                              ? t.axisYIndex
                              : 0
                          ],
                    axisX:
                      "primary" === t.axisXType
                        ? this.axisX[
                            0 <= t.axisXIndex &&
                            t.axisXIndex < this.axisX.length
                              ? t.axisXIndex
                              : 0
                          ]
                        : this.axisX2[
                            0 <= t.axisXIndex &&
                            t.axisXIndex < this.axisX2.length
                              ? t.axisXIndex
                              : 0
                          ],
                    dataSeriesIndexes: [],
                    yTotals: [],
                  }),
                  i.plotUnits.push(s)),
                  i.totalDataSeries++,
                  s.dataSeriesIndexes.push(e),
                  (t.plotUnit = s);
              }
            for (e = 0; e < this.plotInfo.plotTypes.length; e++)
              for (
                i = this.plotInfo.plotTypes[e], o = t = 0;
                o < i.plotUnits.length;
                o++
              )
                (i.plotUnits[o].previousDataSeriesCount = t),
                  (t += i.plotUnits[o].dataSeriesIndexes.length);
          }),
          (r.prototype.assignIdToDataPoints = function () {
            for (var t = 0; t < this.data.length; t++) {
              var e = this.data[t];
              if (e.dataPoints)
                for (var i = e.dataPoints.length, a = 0; a < i; a++)
                  e.dataPointIds[a] = ++this._eventManager.lastObjectId;
            }
          }),
          (r.prototype._processData = function () {
            this.assignIdToDataPoints(), this.categoriseDataSeries();
            for (var t = 0; t < this.plotInfo.plotTypes.length; t++)
              for (
                var e = this.plotInfo.plotTypes[t], i = 0;
                i < e.plotUnits.length;
                i++
              ) {
                var a = e.plotUnits[i];
                "line" === a.type ||
                "stepLine" === a.type ||
                "spline" === a.type ||
                "column" === a.type ||
                "area" === a.type ||
                "stepArea" === a.type ||
                "splineArea" === a.type ||
                "bar" === a.type ||
                "bubble" === a.type ||
                "scatter" === a.type
                  ? this._processMultiseriesPlotUnit(a)
                  : "stackedColumn" === a.type ||
                    "stackedBar" === a.type ||
                    "stackedArea" === a.type
                  ? this._processStackedPlotUnit(a)
                  : "stackedColumn100" === a.type ||
                    "stackedBar100" === a.type ||
                    "stackedArea100" === a.type
                  ? this._processStacked100PlotUnit(a)
                  : "candlestick" === a.type ||
                    "ohlc" === a.type ||
                    "rangeColumn" === a.type ||
                    "rangeBar" === a.type ||
                    "rangeArea" === a.type ||
                    "rangeSplineArea" === a.type ||
                    "error" === a.type ||
                    "boxAndWhisker" === a.type
                  ? this._processMultiYPlotUnit(a)
                  : "waterfall" === a.type && this._processSpecificPlotUnit(a);
              }
            this.calculateAutoBreaks();
          }),
          (r.prototype._processMultiseriesPlotUnit = function (t) {
            if (t.dataSeriesIndexes && !(t.dataSeriesIndexes.length < 1))
              for (
                var e,
                  i,
                  a = t.axisY.dataInfo,
                  s = t.axisX.dataInfo,
                  n = !1,
                  o = 0;
                o < t.dataSeriesIndexes.length;
                o++
              ) {
                var r,
                  l = this.data[t.dataSeriesIndexes[o]],
                  h = 0,
                  d = !1,
                  c = !1;
                if (
                  "normal" === l.axisPlacement ||
                  "xySwapped" === l.axisPlacement
                )
                  var p = t.axisX.sessionVariables.newViewportMinimum
                      ? t.axisX.sessionVariables.newViewportMinimum
                      : this.options.axisX && this.options.axisX.viewportMinimum
                      ? this.options.axisX.viewportMinimum
                      : this.options.axisX && this.options.axisX.minimum
                      ? this.options.axisX.minimum
                      : t.axisX.logarithmic
                      ? 0
                      : -1 / 0,
                    u = t.axisX.sessionVariables.newViewportMaximum
                      ? t.axisX.sessionVariables.newViewportMaximum
                      : this.options.axisX && this.options.axisX.viewportMaximum
                      ? this.options.axisX.viewportMaximum
                      : this.options.axisX && this.options.axisX.maximum
                      ? this.options.axisX.maximum
                      : 1 / 0;
                for (
                  ((l.dataPoints[h].x && l.dataPoints[h].x.getTime) ||
                    "dateTime" === l.xValueType) &&
                    (n = !0),
                    h = 0;
                  h < l.dataPoints.length;
                  h++
                ) {
                  if (
                    (void 0 === l.dataPoints[h].x &&
                      (l.dataPoints[h].x = h + (t.axisX.logarithmic ? 1 : 0)),
                    (e = l.dataPoints[h].x.getTime
                      ? ((n = !0), l.dataPoints[h].x.getTime())
                      : l.dataPoints[h].x),
                    (i = l.dataPoints[h].y),
                    e < s.min && (s.min = e),
                    e > s.max && (s.max = e),
                    i < a.min && "number" == typeof i && (a.min = i),
                    i > a.max && "number" == typeof i && (a.max = i),
                    0 < h)
                  ) {
                    if (t.axisX.logarithmic) {
                      var x = e / l.dataPoints[h - 1].x;
                      x < 1 && (x = 1 / x),
                        s.minDiff > x && 1 !== x && (s.minDiff = x);
                    } else
                      (x = e - l.dataPoints[h - 1].x) < 0 && (x *= -1),
                        s.minDiff > x && 0 !== x && (s.minDiff = x);
                    null !== i &&
                      null !== l.dataPoints[h - 1].y &&
                      (t.axisY.logarithmic
                        ? ((x = i / l.dataPoints[h - 1].y) < 1 && (x = 1 / x),
                          a.minDiff > x && 1 !== x && (a.minDiff = x))
                        : ((x = i - l.dataPoints[h - 1].y) < 0 && (x *= -1),
                          a.minDiff > x && 0 !== x && (a.minDiff = x)));
                  }
                  if (e < p && !d) null !== i && (r = e);
                  else {
                    if (!d && ((d = !0), 0 < h)) {
                      h -= 2;
                      continue;
                    }
                    if (u < e && !c) c = !0;
                    else if (u < e && c) continue;
                    l.dataPoints[h].label &&
                      (t.axisX.labels[e] = l.dataPoints[h].label),
                      e < s.viewPortMin && (s.viewPortMin = e),
                      e > s.viewPortMax && (s.viewPortMax = e),
                      null === i
                        ? s.viewPortMin === e && r < e && (s.viewPortMin = r)
                        : (i < a.viewPortMin &&
                            "number" == typeof i &&
                            (a.viewPortMin = i),
                          i > a.viewPortMax &&
                            "number" == typeof i &&
                            (a.viewPortMax = i));
                  }
                }
                l.axisX.valueType = l.xValueType = n ? "dateTime" : "number";
              }
          }),
          (r.prototype._processStackedPlotUnit = function (t) {
            if (t.dataSeriesIndexes && !(t.dataSeriesIndexes.length < 1)) {
              for (
                var e,
                  i,
                  a = t.axisY.dataInfo,
                  s = t.axisX.dataInfo,
                  n = !1,
                  o = [],
                  r = [],
                  l = 1 / 0,
                  h = -1 / 0,
                  d = 0;
                d < t.dataSeriesIndexes.length;
                d++
              ) {
                var c,
                  p = this.data[t.dataSeriesIndexes[d]],
                  u = 0,
                  x = !1,
                  m = !1;
                if (
                  "normal" === p.axisPlacement ||
                  "xySwapped" === p.axisPlacement
                )
                  var g = t.axisX.sessionVariables.newViewportMinimum
                      ? t.axisX.sessionVariables.newViewportMinimum
                      : this.options.axisX && this.options.axisX.viewportMinimum
                      ? this.options.axisX.viewportMinimum
                      : this.options.axisX && this.options.axisX.minimum
                      ? this.options.axisX.minimum
                      : -1 / 0,
                    b = t.axisX.sessionVariables.newViewportMaximum
                      ? t.axisX.sessionVariables.newViewportMaximum
                      : this.options.axisX && this.options.axisX.viewportMaximum
                      ? this.options.axisX.viewportMaximum
                      : this.options.axisX && this.options.axisX.maximum
                      ? this.options.axisX.maximum
                      : 1 / 0;
                for (
                  ((p.dataPoints[u].x && p.dataPoints[u].x.getTime) ||
                    "dateTime" === p.xValueType) &&
                    (n = !0),
                    u = 0;
                  u < p.dataPoints.length;
                  u++
                ) {
                  if (
                    (void 0 === p.dataPoints[u].x &&
                      (p.dataPoints[u].x = u + (t.axisX.logarithmic ? 1 : 0)),
                    (e = p.dataPoints[u].x.getTime
                      ? ((n = !0), p.dataPoints[u].x.getTime())
                      : p.dataPoints[u].x),
                    (i = U(p.dataPoints[u].y) ? 0 : p.dataPoints[u].y),
                    e < s.min && (s.min = e),
                    e > s.max && (s.max = e),
                    0 < u)
                  ) {
                    if (t.axisX.logarithmic) {
                      var v = e / p.dataPoints[u - 1].x;
                      v < 1 && (v = 1 / v),
                        s.minDiff > v && 1 !== v && (s.minDiff = v);
                    } else
                      (v = e - p.dataPoints[u - 1].x) < 0 && (v *= -1),
                        s.minDiff > v && 0 !== v && (s.minDiff = v);
                    null !== i &&
                      null !== p.dataPoints[u - 1].y &&
                      (t.axisY.logarithmic
                        ? 0 < i &&
                          ((v = i / p.dataPoints[u - 1].y) < 1 && (v = 1 / v),
                          a.minDiff > v && 1 !== v && (a.minDiff = v))
                        : ((v = i - p.dataPoints[u - 1].y) < 0 && (v *= -1),
                          a.minDiff > v && 0 !== v && (a.minDiff = v)));
                  }
                  if (e < g && !x) null !== p.dataPoints[u].y && (c = e);
                  else {
                    if (!x && ((x = !0), 0 < u)) {
                      u -= 2;
                      continue;
                    }
                    if (b < e && !m) m = !0;
                    else if (b < e && m) continue;
                    p.dataPoints[u].label &&
                      (t.axisX.labels[e] = p.dataPoints[u].label),
                      e < s.viewPortMin && (s.viewPortMin = e),
                      e > s.viewPortMax && (s.viewPortMax = e),
                      null === p.dataPoints[u].y
                        ? s.viewPortMin === e && c < e && (s.viewPortMin = c)
                        : ((t.yTotals[e] =
                            (t.yTotals[e] ? t.yTotals[e] : 0) + i),
                          0 <= i
                            ? o[e]
                              ? (o[e] += i)
                              : ((o[e] = i), (l = Math.min(i, l)))
                            : r[e]
                            ? (r[e] += i)
                            : ((r[e] = i), (h = Math.max(i, h))));
                  }
                }
                t.axisY.scaleBreaks &&
                  t.axisY.scaleBreaks.autoCalculate &&
                  1 <= t.axisY.scaleBreaks.maxNumberOfAutoBreaks &&
                  (a.dataPointYPositiveSums
                    ? (a.dataPointYPositiveSums.push.apply(
                        a.dataPointYPositiveSums,
                        o
                      ),
                      a.dataPointYNegativeSums.push.apply(
                        a.dataPointYPositiveSums,
                        r
                      ))
                    : ((a.dataPointYPositiveSums = o),
                      (a.dataPointYNegativeSums = r))),
                  (p.axisX.valueType = p.xValueType =
                    n ? "dateTime" : "number");
              }
              for (u in o)
                o.hasOwnProperty(u) &&
                  !isNaN(u) &&
                  ((t = o[u]) < a.min && (a.min = Math.min(t, l)),
                  t > a.max && (a.max = t),
                  u < s.viewPortMin ||
                    u > s.viewPortMax ||
                    (t < a.viewPortMin && (a.viewPortMin = Math.min(t, l)),
                    t > a.viewPortMax && (a.viewPortMax = t)));
              for (u in r)
                r.hasOwnProperty(u) &&
                  !isNaN(u) &&
                  ((t = r[u]) < a.min && (a.min = t),
                  t > a.max && (a.max = Math.max(t, h)),
                  u < s.viewPortMin ||
                    u > s.viewPortMax ||
                    (t < a.viewPortMin && (a.viewPortMin = t),
                    t > a.viewPortMax && (a.viewPortMax = Math.max(t, h))));
            }
          }),
          (r.prototype._processStacked100PlotUnit = function (t) {
            if (t.dataSeriesIndexes && !(t.dataSeriesIndexes.length < 1)) {
              for (
                var e,
                  i,
                  a = t.axisY.dataInfo,
                  s = t.axisX.dataInfo,
                  n = !1,
                  o = !1,
                  r = !1,
                  l = [],
                  h = 0;
                h < t.dataSeriesIndexes.length;
                h++
              ) {
                var d,
                  c = this.data[t.dataSeriesIndexes[h]],
                  p = 0,
                  u = !1,
                  x = !1;
                if (
                  "normal" === c.axisPlacement ||
                  "xySwapped" === c.axisPlacement
                )
                  var m = t.axisX.sessionVariables.newViewportMinimum
                      ? t.axisX.sessionVariables.newViewportMinimum
                      : this.options.axisX && this.options.axisX.viewportMinimum
                      ? this.options.axisX.viewportMinimum
                      : this.options.axisX && this.options.axisX.minimum
                      ? this.options.axisX.minimum
                      : -1 / 0,
                    g = t.axisX.sessionVariables.newViewportMaximum
                      ? t.axisX.sessionVariables.newViewportMaximum
                      : this.options.axisX && this.options.axisX.viewportMaximum
                      ? this.options.axisX.viewportMaximum
                      : this.options.axisX && this.options.axisX.maximum
                      ? this.options.axisX.maximum
                      : 1 / 0;
                for (
                  ((c.dataPoints[p].x && c.dataPoints[p].x.getTime) ||
                    "dateTime" === c.xValueType) &&
                    (n = !0),
                    p = 0;
                  p < c.dataPoints.length;
                  p++
                ) {
                  if (
                    (void 0 === c.dataPoints[p].x &&
                      (c.dataPoints[p].x = p + (t.axisX.logarithmic ? 1 : 0)),
                    (e = c.dataPoints[p].x.getTime
                      ? ((n = !0), c.dataPoints[p].x.getTime())
                      : c.dataPoints[p].x),
                    (i = U(c.dataPoints[p].y) ? null : c.dataPoints[p].y),
                    e < s.min && (s.min = e),
                    e > s.max && (s.max = e),
                    0 < p)
                  ) {
                    if (t.axisX.logarithmic) {
                      var b = e / c.dataPoints[p - 1].x;
                      b < 1 && (b = 1 / b),
                        s.minDiff > b && 1 !== b && (s.minDiff = b);
                    } else
                      (b = e - c.dataPoints[p - 1].x) < 0 && (b *= -1),
                        s.minDiff > b && 0 !== b && (s.minDiff = b);
                    U(i) ||
                      null === c.dataPoints[p - 1].y ||
                      (t.axisY.logarithmic
                        ? 0 < i &&
                          ((b = i / c.dataPoints[p - 1].y) < 1 && (b = 1 / b),
                          a.minDiff > b && 1 !== b && (a.minDiff = b))
                        : ((b = i - c.dataPoints[p - 1].y) < 0 && (b *= -1),
                          a.minDiff > b && 0 !== b && (a.minDiff = b)));
                  }
                  if (e < m && !u) null !== i && (d = e);
                  else {
                    if (!u && ((u = !0), 0 < p)) {
                      p -= 2;
                      continue;
                    }
                    if (g < e && !x) x = !0;
                    else if (g < e && x) continue;
                    c.dataPoints[p].label &&
                      (t.axisX.labels[e] = c.dataPoints[p].label),
                      e < s.viewPortMin && (s.viewPortMin = e),
                      e > s.viewPortMax && (s.viewPortMax = e),
                      null === i
                        ? s.viewPortMin === e && d < e && (s.viewPortMin = d)
                        : ((t.yTotals[e] =
                            (t.yTotals[e] ? t.yTotals[e] : 0) + i),
                          0 <= i ? (o = !0) : i < 0 && (r = !0),
                          (l[e] = l[e] ? l[e] + Math.abs(i) : Math.abs(i)));
                  }
                }
                c.axisX.valueType = c.xValueType = n ? "dateTime" : "number";
              }
              t.axisY.logarithmic
                ? ((a.max = U(a.viewPortMax)
                    ? 99 * Math.pow(t.axisY.logarithmBase, -0.05)
                    : Math.max(
                        a.viewPortMax,
                        99 * Math.pow(t.axisY.logarithmBase, -0.05)
                      )),
                  (a.min = U(a.viewPortMin) ? 1 : Math.min(a.viewPortMin, 1)))
                : o && !r
                ? ((a.max = U(a.viewPortMax)
                    ? 99
                    : Math.max(a.viewPortMax, 99)),
                  (a.min = U(a.viewPortMin) ? 1 : Math.min(a.viewPortMin, 1)))
                : o && r
                ? ((a.max = U(a.viewPortMax)
                    ? 99
                    : Math.max(a.viewPortMax, 99)),
                  (a.min = U(a.viewPortMin)
                    ? -99
                    : Math.min(a.viewPortMin, -99)))
                : !o &&
                  r &&
                  ((a.max = U(a.viewPortMax)
                    ? -1
                    : Math.max(a.viewPortMax, -1)),
                  (a.min = U(a.viewPortMin)
                    ? -99
                    : Math.min(a.viewPortMin, -99))),
                (a.viewPortMin = a.min),
                (a.viewPortMax = a.max),
                (t.dataPointYSums = l);
            }
          }),
          (r.prototype._processMultiYPlotUnit = function (t) {
            if (t.dataSeriesIndexes && !(t.dataSeriesIndexes.length < 1))
              for (
                var e,
                  i,
                  a,
                  s,
                  n = t.axisY.dataInfo,
                  o = t.axisX.dataInfo,
                  r = !1,
                  l = 0;
                l < t.dataSeriesIndexes.length;
                l++
              ) {
                var h,
                  d,
                  c,
                  p = this.data[t.dataSeriesIndexes[l]],
                  u = 0,
                  x = !1,
                  m = !1;
                if (
                  "normal" === p.axisPlacement ||
                  "xySwapped" === p.axisPlacement
                )
                  var g = t.axisX.sessionVariables.newViewportMinimum
                      ? t.axisX.sessionVariables.newViewportMinimum
                      : this.options.axisX && this.options.axisX.viewportMinimum
                      ? this.options.axisX.viewportMinimum
                      : this.options.axisX && this.options.axisX.minimum
                      ? this.options.axisX.minimum
                      : t.axisX.logarithmic
                      ? 0
                      : -1 / 0,
                    b = t.axisX.sessionVariables.newViewportMaximum
                      ? t.axisX.sessionVariables.newViewportMaximum
                      : this.options.axisX && this.options.axisX.viewportMaximum
                      ? this.options.axisX.viewportMaximum
                      : this.options.axisX && this.options.axisX.maximum
                      ? this.options.axisX.maximum
                      : 1 / 0;
                for (
                  ((p.dataPoints[u].x && p.dataPoints[u].x.getTime) ||
                    "dateTime" === p.xValueType) &&
                    (r = !0),
                    u = 0;
                  u < p.dataPoints.length;
                  u++
                ) {
                  if (
                    (void 0 === p.dataPoints[u].x &&
                      (p.dataPoints[u].x = u + (t.axisX.logarithmic ? 1 : 0)),
                    (e = p.dataPoints[u].x.getTime
                      ? ((r = !0), p.dataPoints[u].x.getTime())
                      : p.dataPoints[u].x),
                    (i = p.dataPoints[u].y) && i.length)
                  ) {
                    (a = Math.min.apply(null, i)),
                      (s = Math.max.apply(null, i)),
                      (d = !0);
                    for (var v = 0; v < i.length; v++) null === i.k && (d = !1);
                    d && (x || (c = h), (h = e));
                  }
                  if (
                    (e < o.min && (o.min = e),
                    e > o.max && (o.max = e),
                    a < n.min && (n.min = a),
                    s > n.max && (n.max = s),
                    0 < u &&
                      (t.axisX.logarithmic
                        ? ((d = e / p.dataPoints[u - 1].x) < 1 && (d = 1 / d),
                          o.minDiff > d && 1 !== d && (o.minDiff = d))
                        : ((d = e - p.dataPoints[u - 1].x) < 0 && (d *= -1),
                          o.minDiff > d && 0 !== d && (o.minDiff = d)),
                      i &&
                        null !== i[0] &&
                        p.dataPoints[u - 1].y &&
                        null !== p.dataPoints[u - 1].y[0] &&
                        (t.axisY.logarithmic
                          ? ((d = i[0] / p.dataPoints[u - 1].y[0]) < 1 &&
                              (d = 1 / d),
                            n.minDiff > d && 1 !== d && (n.minDiff = d))
                          : ((d = i[0] - p.dataPoints[u - 1].y[0]) < 0 &&
                              (d *= -1),
                            n.minDiff > d && 0 !== d && (n.minDiff = d)))),
                    !(e < g) || x)
                  ) {
                    if (!x && ((x = !0), 0 < u)) {
                      (u -= 2), (h = c);
                      continue;
                    }
                    if (b < e && !m) m = !0;
                    else if (b < e && m) continue;
                    if (
                      (p.dataPoints[u].label &&
                        (t.axisX.labels[e] = p.dataPoints[u].label),
                      e < o.viewPortMin && (o.viewPortMin = e),
                      e > o.viewPortMax && (o.viewPortMax = e),
                      o.viewPortMin === e && i)
                    )
                      for (v = 0; v < i.length; v++)
                        if (null === i[v] && h < e) {
                          o.viewPortMin = h;
                          break;
                        }
                    null === i
                      ? o.viewPortMin === e && h < e && (o.viewPortMin = h)
                      : (a < n.viewPortMin && (n.viewPortMin = a),
                        s > n.viewPortMax && (n.viewPortMax = s));
                  }
                }
                p.axisX.valueType = p.xValueType = r ? "dateTime" : "number";
              }
          }),
          (r.prototype._processSpecificPlotUnit = function (t) {
            if (
              "waterfall" === t.type &&
              t.dataSeriesIndexes &&
              !(t.dataSeriesIndexes.length < 1)
            )
              for (
                var e,
                  i,
                  a = t.axisY.dataInfo,
                  s = t.axisX.dataInfo,
                  n = !1,
                  o = 0;
                o < t.dataSeriesIndexes.length;
                o++
              ) {
                var r = this.data[t.dataSeriesIndexes[o]],
                  l = 0,
                  h = !1,
                  d = !1,
                  c = (e = 0);
                if (
                  "normal" === r.axisPlacement ||
                  "xySwapped" === r.axisPlacement
                )
                  var p = t.axisX.sessionVariables.newViewportMinimum
                      ? t.axisX.sessionVariables.newViewportMinimum
                      : this.options.axisX && this.options.axisX.viewportMinimum
                      ? this.options.axisX.viewportMinimum
                      : this.options.axisX && this.options.axisX.minimum
                      ? this.options.axisX.minimum
                      : t.axisX.logarithmic
                      ? 0
                      : -1 / 0,
                    u = t.axisX.sessionVariables.newViewportMaximum
                      ? t.axisX.sessionVariables.newViewportMaximum
                      : this.options.axisX && this.options.axisX.viewportMaximum
                      ? this.options.axisX.viewportMaximum
                      : this.options.axisX && this.options.axisX.maximum
                      ? this.options.axisX.maximum
                      : 1 / 0;
                for (
                  ((r.dataPoints[l].x && r.dataPoints[l].x.getTime) ||
                    "dateTime" === r.xValueType) &&
                    (n = !0),
                    l = 0;
                  l < r.dataPoints.length;
                  l++
                )
                  void 0 !== r.dataPoints[l].isCumulativeSum &&
                  !0 === r.dataPoints[l].isCumulativeSum
                    ? ((r.dataPointEOs[l].cumulativeSumYStartValue = 0),
                      (r.dataPointEOs[l].cumulativeSum =
                        0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum),
                      (r.dataPoints[l].y =
                        0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum))
                    : void 0 !== r.dataPoints[l].isIntermediateSum &&
                      !0 === r.dataPoints[l].isIntermediateSum
                    ? ((r.dataPointEOs[l].cumulativeSumYStartValue = c),
                      (r.dataPointEOs[l].cumulativeSum =
                        0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum),
                      (r.dataPoints[l].y = 0 === l ? 0 : e),
                      (c = 0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum),
                      (e = 0))
                    : ((i =
                        "number" != typeof r.dataPoints[l].y
                          ? 0
                          : r.dataPoints[l].y),
                      (r.dataPointEOs[l].cumulativeSumYStartValue =
                        0 === l ? 0 : r.dataPointEOs[l - 1].cumulativeSum),
                      (r.dataPointEOs[l].cumulativeSum =
                        0 === l ? i : r.dataPointEOs[l - 1].cumulativeSum + i),
                      (e += i));
                for (l = 0; l < r.dataPoints.length; l++)
                  if (
                    (void 0 === r.dataPoints[l].x &&
                      (r.dataPoints[l].x = l + (t.axisX.logarithmic ? 1 : 0)),
                    (e = r.dataPoints[l].x.getTime
                      ? ((n = !0), r.dataPoints[l].x.getTime())
                      : r.dataPoints[l].x),
                    (i = r.dataPoints[l].y),
                    e < s.min && (s.min = e),
                    e > s.max && (s.max = e),
                    r.dataPointEOs[l].cumulativeSum < a.min &&
                      (a.min = r.dataPointEOs[l].cumulativeSum),
                    r.dataPointEOs[l].cumulativeSum > a.max &&
                      (a.max = r.dataPointEOs[l].cumulativeSum),
                    0 < l &&
                      (t.axisX.logarithmic
                        ? ((c = e / r.dataPoints[l - 1].x) < 1 && (c = 1 / c),
                          s.minDiff > c && 1 !== c && (s.minDiff = c))
                        : ((c = e - r.dataPoints[l - 1].x) < 0 && (c *= -1),
                          s.minDiff > c && 0 !== c && (s.minDiff = c)),
                      null !== i &&
                        null !== r.dataPoints[l - 1].y &&
                        (t.axisY.logarithmic
                          ? ((i =
                              r.dataPointEOs[l].cumulativeSum /
                              r.dataPointEOs[l - 1].cumulativeSum) < 1 &&
                              (i = 1 / i),
                            a.minDiff > i && 1 !== i && (a.minDiff = i))
                          : ((i =
                              r.dataPointEOs[l].cumulativeSum -
                              r.dataPointEOs[l - 1].cumulativeSum) < 0 &&
                              (i *= -1),
                            a.minDiff > i && 0 !== i && (a.minDiff = i)))),
                    !(e < p) || h)
                  ) {
                    if (!h && ((h = !0), 0 < l)) {
                      l -= 2;
                      continue;
                    }
                    if (u < e && !d) d = !0;
                    else if (u < e && d) continue;
                    r.dataPoints[l].label &&
                      (t.axisX.labels[e] = r.dataPoints[l].label),
                      e < s.viewPortMin && (s.viewPortMin = e),
                      e > s.viewPortMax && (s.viewPortMax = e),
                      0 < l &&
                        (r.dataPointEOs[l - 1].cumulativeSum < a.viewPortMin &&
                          (a.viewPortMin = r.dataPointEOs[l - 1].cumulativeSum),
                        r.dataPointEOs[l - 1].cumulativeSum > a.viewPortMax &&
                          (a.viewPortMax =
                            r.dataPointEOs[l - 1].cumulativeSum)),
                      r.dataPointEOs[l].cumulativeSum < a.viewPortMin &&
                        (a.viewPortMin = r.dataPointEOs[l].cumulativeSum),
                      r.dataPointEOs[l].cumulativeSum > a.viewPortMax &&
                        (a.viewPortMax = r.dataPointEOs[l].cumulativeSum);
                  }
                r.axisX.valueType = r.xValueType = n ? "dateTime" : "number";
              }
          }),
          (r.prototype.calculateAutoBreaks = function () {
            function t(t) {
              if (t.dataSeriesIndexes && !(t.dataSeriesIndexes.length < 1)) {
                var e =
                    t.axisX.scaleBreaks &&
                    t.axisX.scaleBreaks.autoCalculate &&
                    1 <= t.axisX.scaleBreaks.maxNumberOfAutoBreaks,
                  i =
                    t.axisY.scaleBreaks &&
                    t.axisY.scaleBreaks.autoCalculate &&
                    1 <= t.axisY.scaleBreaks.maxNumberOfAutoBreaks;
                if (e || i)
                  for (
                    var a,
                      s,
                      n = t.axisY.dataInfo,
                      o = (d = t.axisX.dataInfo).min,
                      r = d.max,
                      l = n.min,
                      h = n.max,
                      d = d._dataRanges,
                      c = ((n = n._dataRanges), 0),
                      p = 0;
                    p < t.dataSeriesIndexes.length;
                    p++
                  ) {
                    var u = g.data[t.dataSeriesIndexes[p]];
                    if (!(u.dataPoints.length < 4))
                      for (c = 0; c < u.dataPoints.length; c++)
                        if (
                          (e &&
                            ((s =
                              ((r + 1 - o) *
                                Math.max(
                                  parseFloat(
                                    t.axisX.scaleBreaks.collapsibleThreshold
                                  ) || 10,
                                  10
                                )) /
                              100),
                            (a = u.dataPoints[c].x.getTime
                              ? u.dataPoints[c].x.getTime()
                              : u.dataPoints[c].x) <
                              d[(s = Math.floor((a - o) / s))].min &&
                              (d[s].min = a),
                            a > d[s].max && (d[s].max = a)),
                          i)
                        ) {
                          var x =
                            ((h + 1 - l) *
                              Math.max(
                                parseFloat(
                                  t.axisY.scaleBreaks.collapsibleThreshold
                                ) || 10,
                                10
                              )) /
                            100;
                          if (
                            (a =
                              "waterfall" === t.type
                                ? u.dataPointEOs[c].cumulativeSum
                                : u.dataPoints[c].y) &&
                            a.length
                          )
                            for (var m = 0; m < a.length; m++)
                              (s = Math.floor((a[m] - l) / x)),
                                a[m] < n[s].min && (n[s].min = a[m]),
                                a[m] > n[s].max && (n[s].max = a[m]);
                          else
                            U(a) ||
                              (a < n[(s = Math.floor((a - l) / x))].min &&
                                (n[s].min = a),
                              a > n[s].max && (n[s].max = a));
                        }
                  }
              }
            }
            function e(t) {
              if (
                t.dataSeriesIndexes &&
                !(t.dataSeriesIndexes.length < 1) &&
                t.axisX.scaleBreaks &&
                t.axisX.scaleBreaks.autoCalculate &&
                1 <= t.axisX.scaleBreaks.maxNumberOfAutoBreaks
              )
                for (
                  var e,
                    i = t.axisX.dataInfo,
                    a = i.min,
                    s = i.max,
                    n = i._dataRanges,
                    o = 0,
                    r = 0;
                  r < t.dataSeriesIndexes.length;
                  r++
                ) {
                  var l = g.data[t.dataSeriesIndexes[r]];
                  if (!(l.dataPoints.length < 4))
                    for (o = 0; o < l.dataPoints.length; o++)
                      (e =
                        ((s + 1 - a) *
                          Math.max(
                            parseFloat(
                              t.axisX.scaleBreaks.collapsibleThreshold
                            ) || 10,
                            10
                          )) /
                        100),
                        (i = l.dataPoints[o].x.getTime
                          ? l.dataPoints[o].x.getTime()
                          : l.dataPoints[o].x) <
                          n[(e = Math.floor((i - a) / e))].min &&
                          (n[e].min = i),
                        i > n[e].max && (n[e].max = i);
                }
            }
            for (var i, g = this, a = !1, s = 0; s < this._axes.length; s++)
              if (
                this._axes[s].scaleBreaks &&
                this._axes[s].scaleBreaks.autoCalculate &&
                1 <= this._axes[s].scaleBreaks.maxNumberOfAutoBreaks
              ) {
                (a = !0), (this._axes[s].dataInfo._dataRanges = []);
                for (
                  var n = 0;
                  n <
                  100 /
                    Math.max(
                      parseFloat(
                        this._axes[s].scaleBreaks.collapsibleThreshold
                      ) || 10,
                      10
                    );
                  n++
                )
                  this._axes[s].dataInfo._dataRanges.push({
                    min: 1 / 0,
                    max: -1 / 0,
                  });
              }
            if (a) {
              for (s = 0; s < this.plotInfo.plotTypes.length; s++)
                for (
                  a = this.plotInfo.plotTypes[s], n = 0;
                  n < a.plotUnits.length;
                  n++
                )
                  "line" === (i = a.plotUnits[n]).type ||
                  "stepLine" === i.type ||
                  "spline" === i.type ||
                  "column" === i.type ||
                  "area" === i.type ||
                  "stepArea" === i.type ||
                  "splineArea" === i.type ||
                  "bar" === i.type ||
                  "bubble" === i.type ||
                  "scatter" === i.type ||
                  "candlestick" === i.type ||
                  "ohlc" === i.type ||
                  "rangeColumn" === i.type ||
                  "rangeBar" === i.type ||
                  "rangeArea" === i.type ||
                  "rangeSplineArea" === i.type ||
                  "waterfall" === i.type ||
                  "error" === i.type ||
                  "boxAndWhisker" === i.type
                    ? t(i)
                    : 0 <= i.type.indexOf("stacked") && e(i);
              for (s = 0; s < this._axes.length; s++)
                if (this._axes[s].dataInfo._dataRanges) {
                  var o = this._axes[s].dataInfo.min;
                  i =
                    ((this._axes[s].dataInfo.max + 1 - o) *
                      Math.max(
                        parseFloat(
                          this._axes[s].scaleBreaks.collapsibleThreshold
                        ) || 10,
                        10
                      )) /
                    100;
                  var r,
                    l,
                    h = this._axes[s].dataInfo._dataRanges;
                  a = [];
                  if (this._axes[s].dataInfo.dataPointYPositiveSums) {
                    var d = this._axes[s].dataInfo.dataPointYPositiveSums;
                    for (n in ((r = h), d))
                      d.hasOwnProperty(n) &&
                        !isNaN(n) &&
                        (U((l = d[n])) ||
                          ((index = Math.floor((l - o) / i)),
                          l < r[index].min && (r[index].min = l),
                          l > r[index].max && (r[index].max = l)));
                    delete this._axes[s].dataInfo.dataPointYPositiveSums;
                  }
                  if (this._axes[s].dataInfo.dataPointYNegativeSums) {
                    for (n in ((r = h),
                    (d = this._axes[s].dataInfo.dataPointYNegativeSums)))
                      d.hasOwnProperty(n) &&
                        !isNaN(n) &&
                        (U((l = -1 * d[n])) ||
                          ((index = Math.floor((l - o) / i)),
                          l < r[index].min && (r[index].min = l),
                          l > r[index].max && (r[index].max = l)));
                    delete this._axes[s].dataInfo.dataPointYNegativeSums;
                  }
                  for (n = 0; n < h.length - 1; n++)
                    if (((r = h[n].max), isFinite(r)))
                      for (; n < h.length - 1; ) {
                        if (((o = h[n + 1].min), isFinite(o))) {
                          i < (l = o - r) &&
                            a.push({ diff: l, start: r, end: o });
                          break;
                        }
                        n++;
                      }
                  if (this._axes[s].scaleBreaks.customBreaks)
                    for (
                      n = 0;
                      n < this._axes[s].scaleBreaks.customBreaks.length;
                      n++
                    )
                      for (i = 0; i < a.length; i++)
                        ((this._axes[s].scaleBreaks.customBreaks[n]
                          .startValue <= a[i].start &&
                          a[i].start <=
                            this._axes[s].scaleBreaks.customBreaks[n]
                              .endValue) ||
                          (this._axes[s].scaleBreaks.customBreaks[n]
                            .startValue <= a[i].start &&
                            a[i].start <=
                              this._axes[s].scaleBreaks.customBreaks[n]
                                .endValue) ||
                          (a[i].start <=
                            this._axes[s].scaleBreaks.customBreaks[n]
                              .startValue &&
                            this._axes[s].scaleBreaks.customBreaks[n]
                              .startValue <= a[i].end) ||
                          (a[i].start <=
                            this._axes[s].scaleBreaks.customBreaks[n]
                              .endValue &&
                            this._axes[s].scaleBreaks.customBreaks[n]
                              .endValue <= a[i].end)) &&
                          (a.splice(i, 1), i--);
                  for (
                    a.sort(function (t, e) {
                      return e.diff - t.diff;
                    }),
                      n = 0;
                    n <
                    Math.min(
                      a.length,
                      this._axes[s].scaleBreaks.maxNumberOfAutoBreaks
                    );
                    n++
                  )
                    (c = a[n].start),
                      (p = a[n].end),
                      (u = this._axes[s].logarithmic
                        ? this._axes[s].dataInfo.max /
                          this._axes[s].dataInfo.min
                        : this._axes[s].dataInfo.max -
                          this._axes[s].dataInfo.min),
                      (i = this._axes[s].logarithmic
                        ? ((u = Math.pow(Math.min((u * c) / p, p / c), 0.2)) <=
                            1 &&
                            (u = Math.pow(
                              c < 1 ? 1 / c : Math.min(p / c, c),
                              0.25
                            )),
                          { startValue: c * u, endValue: p / u })
                        : ((u = 0.2 * Math.min(u - p + c, p - c)) <= 0 &&
                            (u = 0.25 * Math.min(p - c, Math.abs(c))),
                          { startValue: c + u, endValue: p - u })),
                      this._axes[s].scaleBreaks.autoBreaks.push(
                        new x(
                          this,
                          "autoBreaks",
                          i,
                          n,
                          ++this._eventManager.lastObjectId,
                          this._axes[s].scaleBreaks
                        )
                      ),
                      this._axes[s].scaleBreaks._appliedBreaks.push(
                        this._axes[s].scaleBreaks.autoBreaks[
                          this._axes[s].scaleBreaks.autoBreaks.length - 1
                        ]
                      );
                  this._axes[s].scaleBreaks._appliedBreaks.sort(function (
                    t,
                    e
                  ) {
                    return t.startValue - e.startValue;
                  });
                }
            }
            var c, p, u;
          }),
          (r.prototype.getDataPointAtXY = function (t, e, i) {
            i = i || !1;
            for (
              var a = [], s = this._dataInRenderedOrder.length - 1;
              0 <= s;
              s--
            ) {
              var n;
              (n = this._dataInRenderedOrder[s].getDataPointAtXY(t, e, i)) &&
                a.push(n);
            }
            for (t = null, e = !1, i = 0; i < a.length; i++)
              if (
                ("line" === a[i].dataSeries.type ||
                  "stepLine" === a[i].dataSeries.type ||
                  "area" === a[i].dataSeries.type ||
                  "stepArea" === a[i].dataSeries.type) &&
                ((s = C("markerSize", a[i].dataPoint, a[i].dataSeries) || 8),
                a[i].distance <= s / 2)
              ) {
                e = !0;
                break;
              }
            for (i = 0; i < a.length; i++)
              (e &&
                "line" !== a[i].dataSeries.type &&
                "stepLine" !== a[i].dataSeries.type &&
                "area" !== a[i].dataSeries.type &&
                "stepArea" !== a[i].dataSeries.type) ||
                (t ? a[i].distance <= t.distance && (t = a[i]) : (t = a[i]));
            return t;
          }),
          (r.prototype.getObjectAtXY = function (t, e, i) {
            var a = null;
            if ((i = this.getDataPointAtXY(t, e, i || !1)))
              a = i.dataSeries.dataPointIds[i.dataPointIndex];
            else if (Z) a = y(t, e, this._eventManager.ghostCtx);
            else
              for (i = 0; i < this.legend.items.length; i++) {
                var s = this.legend.items[i];
                t >= s.x1 && t <= s.x2 && e >= s.y1 && e <= s.y2 && (a = s.id);
              }
            return a;
          }),
          (r.prototype.getAutoFontSize = function (t, e, i) {
            return (
              (e = Math.min(this.width, this.height)),
              Math.max(
                "theme4" === this.theme ? 0 : 300 <= e ? 12 : 10,
                Math.round(e * (t / 400))
              )
            );
          }),
          (r.prototype.resetOverlayedCanvas = function () {
            this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);
          }),
          (r.prototype.clearCanvas = function () {
            this.ctx.clearRect(0, 0, this.width, this.height),
              this.backgroundColor &&
                ((this.ctx.fillStyle = this.backgroundColor),
                this.ctx.fillRect(0, 0, this.width, this.height));
          }),
          (r.prototype.attachEvent = function (t) {
            this._events.push(t);
          }),
          (r.prototype._touchEventHandler = function (t) {
            if (t.changedTouches && this.interactivityEnabled) {
              var e = [],
                i = t.changedTouches,
                a = i ? i[0] : t,
                s = null;
              switch (t.type) {
                case "touchstart":
                case "MSPointerDown":
                  (e = ["mousemove", "mousedown"]),
                    (this._lastTouchData = st(a)),
                    (this._lastTouchData.time = new Date());
                  break;
                case "touchmove":
                case "MSPointerMove":
                  e = ["mousemove"];
                  break;
                case "touchend":
                case "MSPointerUp":
                  var n =
                    this._lastTouchData && this._lastTouchData.time
                      ? new Date() - this._lastTouchData.time
                      : 0;
                  e =
                    "touchstart" === this._lastTouchEventType ||
                    "MSPointerDown" === this._lastTouchEventType ||
                    n < 300
                      ? ["mouseup", "click"]
                      : ["mouseup"];
                  break;
                default:
                  return;
              }
              if (!(i && 1 < i.length)) {
                (s = st(a)).time = new Date();
                try {
                  var o = s.y - this._lastTouchData.y;
                  n = s.time - this._lastTouchData.time;
                  if (
                    15 < Math.abs(o) &&
                    (this._lastTouchData.scroll || n < 300)
                  ) {
                    this._lastTouchData.scroll = !0;
                    var r = window.parent || window;
                    r && r.scrollBy && r.scrollBy(0, -o);
                  }
                } catch (t) {}
                if (
                  ((this._lastTouchEventType = t.type),
                  this._lastTouchData.scroll && this.zoomEnabled)
                )
                  this.isDrag && this.resetOverlayedCanvas(),
                    (this.isDrag = !1);
                else
                  for (i = 0; i < e.length; i++)
                    (s = e[i]),
                      (n = document.createEvent("MouseEvent")).initMouseEvent(
                        s,
                        !0,
                        !0,
                        window,
                        1,
                        a.screenX,
                        a.screenY,
                        a.clientX,
                        a.clientY,
                        !1,
                        !1,
                        !1,
                        !1,
                        0,
                        null
                      ),
                      a.target.dispatchEvent(n),
                      t.preventManipulation && t.preventManipulation(),
                      t.preventDefault && t.preventDefault();
              }
            }
          }),
          (r.prototype._dispatchRangeEvent = function (t, e) {
            var i = { chart: this };
            (i.type = t), (i.trigger = e);
            var a = [];
            this.axisX && 0 < this.axisX.length && a.push("axisX"),
              this.axisX2 && 0 < this.axisX2.length && a.push("axisX2"),
              this.axisY && 0 < this.axisY.length && a.push("axisY"),
              this.axisY2 && 0 < this.axisY2.length && a.push("axisY2");
            for (var s = 0; s < a.length; s++)
              if ((U(i[a[s]]) && (i[a[s]] = []), "axisY" === a[s]))
                for (var n = 0; n < this.axisY.length; n++)
                  i[a[s]].push({
                    viewportMinimum:
                      this[a[s]][n].sessionVariables.newViewportMinimum,
                    viewportMaximum:
                      this[a[s]][n].sessionVariables.newViewportMaximum,
                  });
              else if ("axisY2" === a[s])
                for (n = 0; n < this.axisY2.length; n++)
                  i[a[s]].push({
                    viewportMinimum:
                      this[a[s]][n].sessionVariables.newViewportMinimum,
                    viewportMaximum:
                      this[a[s]][n].sessionVariables.newViewportMaximum,
                  });
              else if ("axisX" === a[s])
                for (n = 0; n < this.axisX.length; n++)
                  i[a[s]].push({
                    viewportMinimum:
                      this[a[s]][n].sessionVariables.newViewportMinimum,
                    viewportMaximum:
                      this[a[s]][n].sessionVariables.newViewportMaximum,
                  });
              else if ("axisX2" === a[s])
                for (n = 0; n < this.axisX2.length; n++)
                  i[a[s]].push({
                    viewportMinimum:
                      this[a[s]][n].sessionVariables.newViewportMinimum,
                    viewportMaximum:
                      this[a[s]][n].sessionVariables.newViewportMaximum,
                  });
            this.dispatchEvent(t, i, this);
          }),
          (r.prototype._mouseEventHandler = function (t) {
            void 0 === t.target && t.srcElement && (t.target = t.srcElement);
            var e,
              i,
              a = st(t),
              s = t.type;
            if (
              (t.which ? (i = 3 == t.which) : t.button && (i = 2 == t.button),
              r.capturedEventParam &&
                ((e = r.capturedEventParam),
                "mouseup" === s &&
                  ((r.capturedEventParam = null),
                  e.chart.overlaidCanvas.releaseCapture
                    ? e.chart.overlaidCanvas.releaseCapture()
                    : document.documentElement.removeEventListener(
                        "mouseup",
                        e.chart._mouseEventHandler,
                        !1
                      )),
                e.hasOwnProperty(s) &&
                  ("mouseup" !== s || e.chart.overlaidCanvas.releaseCapture
                    ? (t.target !== e.chart.overlaidCanvas && Z) ||
                      e[s].call(e.context, a.x, a.y)
                    : t.target !== e.chart.overlaidCanvas &&
                      (e.chart.isDrag = !1))),
              this.interactivityEnabled)
            )
              if (this._ignoreNextEvent) this._ignoreNextEvent = !1;
              else if (
                (t.preventManipulation && t.preventManipulation(),
                t.preventDefault && t.preventDefault(),
                !i)
              ) {
                if (!r.capturedEventParam && this._events) {
                  for (var n = 0; n < this._events.length; n++)
                    if (this._events[n].hasOwnProperty(s)) {
                      if (
                        ((i = (e = this._events[n]).bounds),
                        a.x >= i.x1 &&
                          a.x <= i.x2 &&
                          a.y >= i.y1 &&
                          a.y <= i.y2)
                      ) {
                        e[s].call(e.context, a.x, a.y),
                          "mousedown" === s && !0 === e.capture
                            ? ((r.capturedEventParam = e),
                              this.overlaidCanvas.setCapture
                                ? this.overlaidCanvas.setCapture()
                                : document.documentElement.addEventListener(
                                    "mouseup",
                                    this._mouseEventHandler,
                                    !1
                                  ))
                            : "mouseup" === s &&
                              (e.chart.overlaidCanvas.releaseCapture
                                ? e.chart.overlaidCanvas.releaseCapture()
                                : document.documentElement.removeEventListener(
                                    "mouseup",
                                    this._mouseEventHandler,
                                    !1
                                  ));
                        break;
                      }
                      e = null;
                    }
                  t.target.style.cursor =
                    e && e.cursor ? e.cursor : this._defaultCursor;
                }
                (s = this.plotArea),
                  (a.x < s.x1 || a.x > s.x2 || a.y < s.y1 || a.y > s.y2) &&
                    (this.toolTip && this.toolTip.enabled
                      ? this.toolTip.hide()
                      : this.resetOverlayedCanvas()),
                  (this.isDrag && this.zoomEnabled) ||
                    !this._eventManager ||
                    this._eventManager.mouseEventHandler(t);
              }
          }),
          (r.prototype._plotAreaMouseDown = function (t, e) {
            (this.isDrag = !0), (this.dragStartPoint = { x: t, y: e });
          }),
          (r.prototype._plotAreaMouseUp = function (t, e) {
            if (
              ("normal" === this.plotInfo.axisPlacement ||
                "xySwapped" === this.plotInfo.axisPlacement) &&
              this.isDrag
            ) {
              var i = e - this.dragStartPoint.y,
                a = t - this.dragStartPoint.x,
                s = 0 <= this.zoomType.indexOf("x"),
                n = 0 <= this.zoomType.indexOf("y"),
                o = !1;
              if (
                (this.resetOverlayedCanvas(),
                "xySwapped" === this.plotInfo.axisPlacement)
              ) {
                var r = n;
                (n = s), (s = r);
              }
              if (this.panEnabled || this.zoomEnabled) {
                if (this.panEnabled)
                  for (s = n = 0; s < this._axes.length; s++)
                    (i = this._axes[s]).logarithmic
                      ? i.viewportMinimum < i.minimum
                        ? ((n = i.minimum / i.viewportMinimum),
                          (i.sessionVariables.newViewportMinimum =
                            i.viewportMinimum * n),
                          (i.sessionVariables.newViewportMaximum =
                            i.viewportMaximum * n),
                          (o = !0))
                        : i.viewportMaximum > i.maximum &&
                          ((n = i.viewportMaximum / i.maximum),
                          (i.sessionVariables.newViewportMinimum =
                            i.viewportMinimum / n),
                          (i.sessionVariables.newViewportMaximum =
                            i.viewportMaximum / n),
                          (o = !0))
                      : i.viewportMinimum < i.minimum
                      ? ((n = i.minimum - i.viewportMinimum),
                        (i.sessionVariables.newViewportMinimum =
                          i.viewportMinimum + n),
                        (i.sessionVariables.newViewportMaximum =
                          i.viewportMaximum + n),
                        (o = !0))
                      : i.viewportMaximum > i.maximum &&
                        ((n = i.viewportMaximum - i.maximum),
                        (i.sessionVariables.newViewportMinimum =
                          i.viewportMinimum - n),
                        (i.sessionVariables.newViewportMaximum =
                          i.viewportMaximum - n),
                        (o = !0));
                else if (
                  (!s || 2 < Math.abs(a)) &&
                  (!n || 2 < Math.abs(i)) &&
                  this.zoomEnabled
                ) {
                  if (!this.dragStartPoint) return;
                  (i = s ? this.dragStartPoint.x : this.plotArea.x1),
                    (a = n ? this.dragStartPoint.y : this.plotArea.y1),
                    (s = s ? t : this.plotArea.x2),
                    (n = n ? e : this.plotArea.y2),
                    2 < Math.abs(i - s) &&
                      2 < Math.abs(a - n) &&
                      this._zoomPanToSelectedRegion(i, a, s, n) &&
                      (o = !0);
                }
                o &&
                  ((this._ignoreNextEvent = !0),
                  this._dispatchRangeEvent("rangeChanging", "zoom"),
                  this.render(),
                  this._dispatchRangeEvent("rangeChanged", "zoom"),
                  o &&
                    this.zoomEnabled &&
                    "none" === this._zoomButton.style.display &&
                    (S(this._zoomButton, this._resetButton),
                    P(this, this._zoomButton, "pan"),
                    P(this, this._resetButton, "reset")));
              }
            }
            if (((this.isDrag = !1), "none" !== this.plotInfo.axisPlacement)) {
              if (
                (this.resetOverlayedCanvas(),
                this.axisX && 0 < this.axisX.length)
              )
                for (o = 0; o < this.axisX.length; o++)
                  this.axisX[o].crosshair &&
                    this.axisX[o].crosshair.enabled &&
                    this.axisX[o].renderCrosshair(t, e);
              if (this.axisX2 && 0 < this.axisX2.length)
                for (o = 0; o < this.axisX2.length; o++)
                  this.axisX2[o].crosshair &&
                    this.axisX2[o].crosshair.enabled &&
                    this.axisX2[o].renderCrosshair(t, e);
              if (this.axisY && 0 < this.axisY.length)
                for (o = 0; o < this.axisY.length; o++)
                  this.axisY[o].crosshair &&
                    this.axisY[o].crosshair.enabled &&
                    this.axisY[o].renderCrosshair(t, e);
              if (this.axisY2 && 0 < this.axisY2.length)
                for (o = 0; o < this.axisY2.length; o++)
                  this.axisY2[o].crosshair &&
                    this.axisY2[o].crosshair.enabled &&
                    this.axisY2[o].renderCrosshair(t, e);
            }
          }),
          (r.prototype._plotAreaMouseMove = function (t, e) {
            if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
              var i = 0,
                a = 0,
                s = (i = null),
                n =
                  ((s = 0 <= this.zoomType.indexOf("x")),
                  0 <= this.zoomType.indexOf("y")),
                o = this;
              if (
                ("xySwapped" === this.plotInfo.axisPlacement &&
                  ((i = n), (n = s), (s = i)),
                (i = this.dragStartPoint.x - t),
                (a = this.dragStartPoint.y - e),
                2 < Math.abs(i) &&
                Math.abs(i) < 8 &&
                (this.panEnabled || this.zoomEnabled)
                  ? this.toolTip.hide()
                  : this.panEnabled ||
                    this.zoomEnabled ||
                    this.toolTip.mouseMoveHandler(t, e),
                (!s || 2 < Math.abs(i) || !n || 2 < Math.abs(a)) &&
                  (this.panEnabled || this.zoomEnabled))
              )
                if (this.panEnabled)
                  (s = {
                    x1: s ? this.plotArea.x1 + i : this.plotArea.x1,
                    y1: n ? this.plotArea.y1 + a : this.plotArea.y1,
                    x2: s ? this.plotArea.x2 + i : this.plotArea.x2,
                    y2: n ? this.plotArea.y2 + a : this.plotArea.y2,
                  }),
                    clearTimeout(o._panTimerId),
                    (o._panTimerId = setTimeout(
                      ((d = s.x1),
                      (c = s.y1),
                      (p = s.x2),
                      (u = s.y2),
                      function () {
                        o._zoomPanToSelectedRegion(d, c, p, u, !0) &&
                          (o._dispatchRangeEvent("rangeChanging", "pan"),
                          o.render(),
                          o._dispatchRangeEvent("rangeChanged", "pan"),
                          (o.dragStartPoint.x = t),
                          (o.dragStartPoint.y = e));
                      }),
                      0
                    ));
                else if (this.zoomEnabled) {
                  this.resetOverlayedCanvas(),
                    (i = this.overlaidCanvasCtx.globalAlpha),
                    (this.overlaidCanvasCtx.fillStyle = "#A89896");
                  a = s ? this.dragStartPoint.x : this.plotArea.x1;
                  var r = n ? this.dragStartPoint.y : this.plotArea.y1,
                    l = s
                      ? t - this.dragStartPoint.x
                      : this.plotArea.x2 - this.plotArea.x1,
                    h = n
                      ? e - this.dragStartPoint.y
                      : this.plotArea.y2 - this.plotArea.y1;
                  this.validateRegion(
                    a,
                    r,
                    s ? t : this.plotArea.x2 - this.plotArea.x1,
                    n ? e : this.plotArea.y2 - this.plotArea.y1,
                    "xy" !== this.zoomType
                  ).isValid &&
                    (this.resetOverlayedCanvas(),
                    (this.overlaidCanvasCtx.fillStyle = "#99B2B5")),
                    (this.overlaidCanvasCtx.globalAlpha = 0.7),
                    this.overlaidCanvasCtx.fillRect(a, r, l, h),
                    (this.overlaidCanvasCtx.globalAlpha = i);
                }
            } else if (
              (this.toolTip.mouseMoveHandler(t, e),
              "none" !== this.plotInfo.axisPlacement)
            ) {
              if (this.axisX && 0 < this.axisX.length)
                for (s = 0; s < this.axisX.length; s++)
                  this.axisX[s].crosshair &&
                    this.axisX[s].crosshair.enabled &&
                    this.axisX[s].renderCrosshair(t, e);
              if (this.axisX2 && 0 < this.axisX2.length)
                for (s = 0; s < this.axisX2.length; s++)
                  this.axisX2[s].crosshair &&
                    this.axisX2[s].crosshair.enabled &&
                    this.axisX2[s].renderCrosshair(t, e);
              if (this.axisY && 0 < this.axisY.length)
                for (s = 0; s < this.axisY.length; s++)
                  this.axisY[s].crosshair &&
                    this.axisY[s].crosshair.enabled &&
                    this.axisY[s].renderCrosshair(t, e);
              if (this.axisY2 && 0 < this.axisY2.length)
                for (s = 0; s < this.axisY2.length; s++)
                  this.axisY2[s].crosshair &&
                    this.axisY2[s].crosshair.enabled &&
                    this.axisY2[s].renderCrosshair(t, e);
            }
            var d, c, p, u;
          }),
          (r.prototype._zoomPanToSelectedRegion = function (t, e, i, a, s) {
            if (
              ((e = (t = this.validateRegion(t, e, i, a, s))
                .axesWithValidRange),
              (i = t.axesRanges),
              t.isValid)
            )
              for (a = 0; a < e.length; a++)
                (s = i[a]), e[a].setViewPortRange(s.val1, s.val2);
            return t.isValid;
          }),
          (r.prototype.validateRegion = function (t, e, i, a, s) {
            s = s || !1;
            for (
              var n = 0 <= this.zoomType.indexOf("x"),
                o = 0 <= this.zoomType.indexOf("y"),
                r = !1,
                l = [],
                h = [],
                d = [],
                c = 0;
              c < this._axes.length;
              c++
            )
              (("axisX" === this._axes[c].type && n) ||
                ("axisY" === this._axes[c].type && o)) &&
                h.push(this._axes[c]);
            for (o = 0; o < h.length; o++) {
              n = !1;
              var p = (c = h[o]).convertPixelToValue({ x: t, y: e });
              if ((x = c.convertPixelToValue({ x: i, y: a })) < p) {
                var u = x,
                  x = p;
                p = u;
              }
              if (c.scaleBreaks)
                for (u = 0; !n && u < c.scaleBreaks._appliedBreaks.length; u++)
                  n =
                    c.scaleBreaks._appliedBreaks[u].startValue <= p &&
                    c.scaleBreaks._appliedBreaks[u].endValue >= x;
              if (isFinite(c.dataInfo.minDiff))
                if (
                  ((u = c.getApparentDifference(p, x, null, !0)),
                  n ||
                    (!(
                      this.panEnabled &&
                      c.scaleBreaks &&
                      c.scaleBreaks._appliedBreaks.length
                    ) &&
                      ((c.logarithmic && u < Math.pow(c.dataInfo.minDiff, 3)) ||
                        (!c.logarithmic &&
                          u < 3 * Math.abs(c.dataInfo.minDiff)))) ||
                    p < c.minimum ||
                    x > c.maximum)
                ) {
                  if (!s) {
                    r = !1;
                    break;
                  }
                } else l.push(c), d.push({ val1: p, val2: x }), (r = !0);
            }
            return { isValid: r, axesWithValidRange: l, axesRanges: d };
          }),
          (r.prototype.preparePlotArea = function () {
            var t = this.plotArea;
            if (
              (!Z && (0 < t.x1 || 0 < t.y1) && t.ctx.translate(t.x1, t.y1),
              (this.axisX[0] || this.axisX2[0]) &&
                (this.axisY[0] || this.axisY2[0]))
            ) {
              var e = this.axisX[0]
                ? this.axisX[0].lineCoordinates
                : this.axisX2[0].lineCoordinates;
              if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
                var i = this.axisY[0];
                (t.x1 = e.x1 < e.x2 ? e.x1 : i.lineCoordinates.x1),
                  (t.y1 =
                    e.y1 < i.lineCoordinates.y1 ? e.y1 : i.lineCoordinates.y1),
                  (t.x2 =
                    e.x2 > i.lineCoordinates.x2 ? e.x2 : i.lineCoordinates.x2),
                  (t.y2 = e.y2 > e.y1 ? e.y2 : i.lineCoordinates.y2),
                  (t.width = t.x2 - t.x1),
                  (t.height = t.y2 - t.y1);
              }
              this.axisY2 &&
                0 < this.axisY2.length &&
                this.axisY2[0] &&
                ((i = this.axisY2[0]),
                (t.x1 = e.x1 < e.x2 ? e.x1 : i.lineCoordinates.x1),
                (t.y1 =
                  e.y1 < i.lineCoordinates.y1 ? e.y1 : i.lineCoordinates.y1),
                (t.x2 =
                  e.x2 > i.lineCoordinates.x2 ? e.x2 : i.lineCoordinates.x2),
                (t.y2 = e.y2 > e.y1 ? e.y2 : i.lineCoordinates.y2),
                (t.width = t.x2 - t.x1),
                (t.height = t.y2 - t.y1));
            } else
              (e = this.layoutManager.getFreeSpace()),
                (t.x1 = e.x1),
                (t.x2 = e.x2),
                (t.y1 = e.y1),
                (t.y2 = e.y2),
                (t.width = e.width),
                (t.height = e.height);
            Z ||
              ((t.canvas.width = t.width),
              (t.canvas.height = t.height),
              (t.canvas.style.left = t.x1 + "px"),
              (t.canvas.style.top = t.y1 + "px"),
              (0 < t.x1 || 0 < t.y1) && t.ctx.translate(-t.x1, -t.y1)),
              (t.layoutManager = new D(t.x1, t.y1, t.x2, t.y2, 2));
          }),
          (r.prototype.renderIndexLabels = function (t) {
            var e = t || this.plotArea.ctx,
              i = this.plotArea,
              a = 0,
              s = 0,
              n = 0,
              o = 0,
              r = (a = o = s = n = 0),
              l = 0;
            for (t = 0; t < this._indexLabels.length; t++) {
              var h,
                d,
                c = this._indexLabels[t],
                p = c.chartType.toLowerCase();
              (r = C("indexLabelFontColor", c.dataPoint, c.dataSeries)),
                (l = C("indexLabelFontSize", c.dataPoint, c.dataSeries));
              (h = C("indexLabelFontFamily", c.dataPoint, c.dataSeries)),
                (d = C("indexLabelFontStyle", c.dataPoint, c.dataSeries));
              o = C("indexLabelFontWeight", c.dataPoint, c.dataSeries);
              var u = C("indexLabelBackgroundColor", c.dataPoint, c.dataSeries),
                x =
                  ((s = C("indexLabelMaxWidth", c.dataPoint, c.dataSeries)),
                  (n = C("indexLabelWrap", c.dataPoint, c.dataSeries)),
                  C("indexLabelLineDashType", c.dataPoint, c.dataSeries)),
                m = C("indexLabelLineColor", c.dataPoint, c.dataSeries),
                g = U(c.dataPoint.indexLabelLineThickness)
                  ? U(c.dataSeries.options.indexLabelLineThickness)
                    ? 0
                    : c.dataSeries.options.indexLabelLineThickness
                  : c.dataPoint.indexLabelLineThickness,
                b =
                  ((a =
                    0 < g
                      ? Math.min(
                          10,
                          ("normal" === this.plotInfo.axisPlacement
                            ? this.plotArea.height
                            : this.plotArea.width) << 0
                        )
                      : 0),
                  { percent: null, total: null }),
                v = null;
              (0 <= c.dataSeries.type.indexOf("stacked") ||
                "pie" === c.dataSeries.type ||
                "doughnut" === c.dataSeries.type) &&
                (b = this.getPercentAndTotal(c.dataSeries, c.dataPoint)),
                (c.dataSeries.indexLabelFormatter ||
                  c.dataPoint.indexLabelFormatter) &&
                  (v = {
                    chart: this,
                    dataSeries: c.dataSeries,
                    dataPoint: c.dataPoint,
                    index: c.indexKeyword,
                    total: b.total,
                    percent: b.percent,
                  });
              var f = c.dataPoint.indexLabelFormatter
                ? c.dataPoint.indexLabelFormatter(v)
                : c.dataPoint.indexLabel
                ? this.replaceKeywordsWithValue(
                    c.dataPoint.indexLabel,
                    c.dataPoint,
                    c.dataSeries,
                    null,
                    c.indexKeyword
                  )
                : c.dataSeries.indexLabelFormatter
                ? c.dataSeries.indexLabelFormatter(v)
                : c.dataSeries.indexLabel
                ? this.replaceKeywordsWithValue(
                    c.dataSeries.indexLabel,
                    c.dataPoint,
                    c.dataSeries,
                    null,
                    c.indexKeyword
                  )
                : null;
              if (null !== f && "" !== f) {
                (b = C("indexLabelPlacement", c.dataPoint, c.dataSeries)),
                  (v = C("indexLabelOrientation", c.dataPoint, c.dataSeries));
                var y = c.direction,
                  M = c.dataSeries.axisX,
                  k = c.dataSeries.axisY,
                  w = !1;
                if (
                  ((u = new Q(e, {
                    x: 0,
                    y: 0,
                    maxWidth: s || 0.5 * this.width,
                    maxHeight: n ? 5 * l : 1.5 * l,
                    angle: "horizontal" === v ? 0 : -90,
                    text: f,
                    padding: 0,
                    backgroundColor: u,
                    horizontalAlign: "left",
                    fontSize: l,
                    fontFamily: h,
                    fontWeight: o,
                    fontColor: r,
                    fontStyle: d,
                    textBaseline: "top",
                  })).measureText(),
                  (c.dataSeries.indexLabelMaxWidth = u.maxWidth),
                  "stackedarea100" === p)
                ) {
                  if (
                    c.point.x < i.x1 ||
                    c.point.x > i.x2 ||
                    c.point.y < i.y1 - 1 ||
                    c.point.y > i.y2 + 1
                  )
                    continue;
                } else if ("rangearea" === p || "rangesplinearea" === p) {
                  if (
                    c.dataPoint.x < M.viewportMinimum ||
                    c.dataPoint.x > M.viewportMaximum ||
                    Math.max.apply(null, c.dataPoint.y) < k.viewportMinimum ||
                    Math.min.apply(null, c.dataPoint.y) > k.viewportMaximum
                  )
                    continue;
                } else if (
                  0 <= p.indexOf("line") ||
                  0 <= p.indexOf("area") ||
                  0 <= p.indexOf("bubble") ||
                  0 <= p.indexOf("scatter")
                ) {
                  if (
                    c.dataPoint.x < M.viewportMinimum ||
                    c.dataPoint.x > M.viewportMaximum ||
                    c.dataPoint.y < k.viewportMinimum ||
                    c.dataPoint.y > k.viewportMaximum
                  )
                    continue;
                } else if (
                  0 <= p.indexOf("column") ||
                  "waterfall" === p ||
                  ("error" === p && !c.axisSwapped)
                ) {
                  if (
                    c.dataPoint.x < M.viewportMinimum ||
                    c.dataPoint.x > M.viewportMaximum ||
                    c.bounds.y1 > i.y2 ||
                    c.bounds.y2 < i.y1
                  )
                    continue;
                } else if (0 <= p.indexOf("bar") || "error" === p) {
                  if (
                    c.dataPoint.x < M.viewportMinimum ||
                    c.dataPoint.x > M.viewportMaximum ||
                    c.bounds.x1 > i.x2 ||
                    c.bounds.x2 < i.x1
                  )
                    continue;
                } else if ("candlestick" === p || "ohlc" === p) {
                  if (
                    c.dataPoint.x < M.viewportMinimum ||
                    c.dataPoint.x > M.viewportMaximum ||
                    Math.max.apply(null, c.dataPoint.y) < k.viewportMinimum ||
                    Math.min.apply(null, c.dataPoint.y) > k.viewportMaximum
                  )
                    continue;
                } else if (
                  c.dataPoint.x < M.viewportMinimum ||
                  c.dataPoint.x > M.viewportMaximum
                )
                  continue;
                (s = o = 2),
                  "horizontal" === v
                    ? ((r = u.width), (l = u.height))
                    : ((l = u.width), (r = u.height)),
                  "normal" === this.plotInfo.axisPlacement
                    ? (0 <= p.indexOf("line") || 0 <= p.indexOf("area")
                        ? ((b = "auto"), (o = 4))
                        : 0 <= p.indexOf("stacked")
                        ? "auto" === b && (b = "inside")
                        : ("bubble" !== p && "scatter" !== p) || (b = "inside"),
                      (h = c.point.x - r / 2),
                      "inside" !== b
                        ? ((s = i.y1),
                          (n = i.y2),
                          0 < y
                            ? (d = c.point.y - l - o - a) < s &&
                              (w =
                                (d =
                                  "auto" === b
                                    ? Math.max(c.point.y, s) + o + a
                                    : s + o + a) +
                                  l >
                                c.point.y)
                            : n - l - o - a < (d = c.point.y + o + a) &&
                              (w =
                                (d =
                                  "auto" === b
                                    ? Math.min(c.point.y, n) - l - o - a
                                    : n - l - o - a) < c.point.y))
                        : ((s = Math.max(c.bounds.y1, i.y1)),
                          (n = Math.min(c.bounds.y2, i.y2)),
                          (a =
                            0 <= p.indexOf("range") || "error" === p
                              ? 0 < y
                                ? Math.max(c.bounds.y1, i.y1) + l / 2 + o
                                : Math.min(c.bounds.y2, i.y2) - l / 2 - o
                              : (Math.max(c.bounds.y1, i.y1) +
                                  Math.min(c.bounds.y2, i.y2)) /
                                2),
                          0 < y
                            ? (d = Math.max(c.point.y, a) - l / 2) < s &&
                              ("bubble" === p || "scatter" === p) &&
                              (d = Math.max(c.point.y - l - o, i.y1 + o))
                            : n - l - o <
                                (d = Math.min(c.point.y, a) - l / 2) &&
                              ("bubble" === p || "scatter" === p) &&
                              (d = Math.min(c.point.y + o, i.y2 - l - o)),
                          (d = Math.min(d, n - l))))
                    : (0 <= p.indexOf("line") ||
                      0 <= p.indexOf("area") ||
                      0 <= p.indexOf("scatter")
                        ? ((b = "auto"), (s = 4))
                        : 0 <= p.indexOf("stacked")
                        ? "auto" === b && (b = "inside")
                        : "bubble" === p && (b = "inside"),
                      (d = c.point.y - l / 2),
                      "inside" !== b
                        ? ((o = i.x1),
                          (n = i.x2),
                          y < 0
                            ? (h = c.point.x - r - s - a) < o &&
                              (w =
                                (h =
                                  "auto" === b
                                    ? Math.max(c.point.x, o) + s + a
                                    : o + s + a) +
                                  r >
                                c.point.x)
                            : n - r - s - a < (h = c.point.x + s + a) &&
                              (w =
                                (h =
                                  "auto" === b
                                    ? Math.min(c.point.x, n) - r - s - a
                                    : n - r - s - a) < c.point.x))
                        : ((o = Math.max(c.bounds.x1, i.x1)),
                          Math.min(c.bounds.x2, i.x2),
                          (a =
                            0 <= p.indexOf("range") || "error" === p
                              ? y < 0
                                ? Math.max(c.bounds.x1, i.x1) + r / 2 + s
                                : Math.min(c.bounds.x2, i.x2) - r / 2 - s
                              : (Math.max(c.bounds.x1, i.x1) +
                                  Math.min(c.bounds.x2, i.x2)) /
                                2),
                          (h =
                            y < 0
                              ? Math.max(c.point.x, a) - r / 2
                              : Math.min(c.point.x, a) - r / 2),
                          (h = Math.max(h, o)))),
                  "vertical" === v && (d += l),
                  (u.x = h),
                  (u.y = d),
                  u.render(!0),
                  g &&
                    "inside" !== b &&
                    ((p.indexOf("bar") < 0 &&
                      ("error" !== p || !c.axisSwapped) &&
                      c.point.x > i.x1 &&
                      c.point.x < i.x2) ||
                      !w) &&
                    ((p.indexOf("column") < 0 &&
                      ("error" !== p || c.axisSwapped) &&
                      c.point.y > i.y1 &&
                      c.point.y < i.y2) ||
                      !w) &&
                    ((e.lineWidth = g),
                    (e.strokeStyle = m || "gray"),
                    e.setLineDash && e.setLineDash(K(x, g)),
                    e.beginPath(),
                    e.moveTo(c.point.x, c.point.y),
                    0 <= p.indexOf("bar") || ("error" === p && c.axisSwapped)
                      ? e.lineTo(
                          h + (0 < c.direction ? 0 : r),
                          d + ("horizontal" === v ? l : -l) / 2
                        )
                      : 0 <= p.indexOf("column") ||
                        ("error" === p && !c.axisSwapped)
                      ? e.lineTo(
                          h + r / 2,
                          d +
                            ((0 < c.direction ? l : -l) +
                              ("horizontal" === v ? l : -l)) /
                              2
                        )
                      : e.lineTo(
                          h + r / 2,
                          d +
                            ((d < c.point.y ? l : -l) +
                              ("horizontal" === v ? l : -l)) /
                              2
                        ),
                    e.stroke());
              }
            }
            for (
              e = {
                source: e,
                dest: this.plotArea.ctx,
                animationCallback: j.fadeInAnimation,
                easingFunction: j.easing.easeInQuad,
                animationBase: 0,
                startTimePercent: 0.7,
              },
                t = 0;
              t < this._indexLabels.length;
              t++
            )
              (u = C(
                "indexLabelBackgroundColor",
                (c = this._indexLabels[t]).dataPoint,
                c.dataSeries
              )),
                (c.dataSeries.indexLabelBackgroundColor = U(u)
                  ? Z
                    ? "transparent"
                    : null
                  : u);
            return e;
          }),
          (r.prototype.renderLine = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a = this._eventManager.ghostCtx;
              i.save();
              var s = this.plotArea;
              i.beginPath(), i.rect(s.x1, s.y1, s.width, s.height), i.clip();
              for (var n, o = [], r = 0; r < t.dataSeriesIndexes.length; r++) {
                var l = t.dataSeriesIndexes[r],
                  h = this.data[l];
                i.lineWidth = h.lineThickness;
                var d = h.dataPoints,
                  c = "solid";
                if (i.setLineDash) {
                  var p = K(h.nullDataLineDashType, h.lineThickness),
                    u = K((c = h.lineDashType), h.lineThickness);
                  i.setLineDash(u);
                }
                var x = h.id;
                (this._eventManager.objectMap[x] = {
                  objectType: "dataSeries",
                  dataSeriesIndex: l,
                }),
                  (x = N(x)),
                  (a.strokeStyle = x),
                  (a.lineWidth =
                    0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0);
                x = h._colorSet;
                var m =
                  (x =
                  h.lineColor =
                    h.options.lineColor ? h.options.lineColor : x[0]);
                i.strokeStyle = x;
                var g,
                  b,
                  v = !0,
                  f = 0;
                if ((i.beginPath(), 0 < d.length)) {
                  var y = !1;
                  for (f = 0; f < d.length; f++)
                    if (
                      !(
                        (g = d[f].x.getTime ? d[f].x.getTime() : d[f].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        (g > t.axisX.dataInfo.viewPortMax &&
                          (!h.connectNullData || !y))
                      )
                    )
                      if ("number" != typeof d[f].y)
                        0 < f &&
                          !(h.connectNullData || y || v) &&
                          (i.stroke(), Z && a.stroke()),
                          (y = !0);
                      else {
                        (g = t.axisX.convertValueToPixel(g)),
                          (b = t.axisY.convertValueToPixel(d[f].y));
                        var M = h.dataPointIds[f];
                        if (
                          ((this._eventManager.objectMap[M] = {
                            id: M,
                            objectType: "dataPoint",
                            dataSeriesIndex: l,
                            dataPointIndex: f,
                            x1: g,
                            y1: b,
                          }),
                          v || y
                            ? (!v && h.connectNullData
                                ? (i.setLineDash &&
                                    (h.options.nullDataLineDashType ||
                                      (c === h.lineDashType &&
                                        h.lineDashType !==
                                          h.nullDataLineDashType)) &&
                                    (i.stroke(),
                                    i.beginPath(),
                                    i.moveTo(n.x, n.y),
                                    (c = h.nullDataLineDashType),
                                    i.setLineDash(p)),
                                  i.lineTo(g, b),
                                  Z && a.lineTo(g, b))
                                : (i.beginPath(),
                                  i.moveTo(g, b),
                                  Z && (a.beginPath(), a.moveTo(g, b))),
                              (y = v = !1))
                            : (i.lineTo(g, b),
                              Z && a.lineTo(g, b),
                              0 == f % 500 &&
                                (i.stroke(),
                                i.beginPath(),
                                i.moveTo(g, b),
                                Z &&
                                  (a.stroke(), a.beginPath(), a.moveTo(g, b)))),
                          (n = { x: g, y: b }),
                          f < d.length - 1 &&
                            (m !== (d[f].lineColor || x) ||
                              c !== (d[f].lineDashType || h.lineDashType)) &&
                            (i.stroke(),
                            i.beginPath(),
                            i.moveTo(g, b),
                            (m = d[f].lineColor || x),
                            (i.strokeStyle = m),
                            i.setLineDash &&
                              (d[f].lineDashType
                                ? ((c = d[f].lineDashType),
                                  i.setLineDash(K(c, h.lineThickness)))
                                : ((c = h.lineDashType), i.setLineDash(u)))),
                          0 < d[f].markerSize || 0 < h.markerSize)
                        ) {
                          var k = h.getMarkerProperties(f, g, b, i);
                          o.push(k),
                            (M = N(M)),
                            Z &&
                              o.push({
                                x: g,
                                y: b,
                                ctx: a,
                                type: k.type,
                                size: k.size,
                                color: M,
                                borderColor: M,
                                borderThickness: k.borderThickness,
                              });
                        }
                        (d[f].indexLabel ||
                          h.indexLabel ||
                          d[f].indexLabelFormatter ||
                          h.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "line",
                            dataPoint: d[f],
                            dataSeries: h,
                            point: { x: g, y: b },
                            direction: d[f].y < 0 === t.axisY.reversed ? 1 : -1,
                            color: x,
                          });
                      }
                  i.stroke(), Z && a.stroke();
                }
              }
              return (
                I.drawMarkers(o),
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(s.x1, s.y1, s.width, s.height),
                  a.beginPath()),
                i.restore(),
                i.beginPath(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderStepLine = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a = this._eventManager.ghostCtx;
              i.save();
              var s = this.plotArea;
              i.beginPath(), i.rect(s.x1, s.y1, s.width, s.height), i.clip();
              for (var n, o = [], r = 0; r < t.dataSeriesIndexes.length; r++) {
                var l = t.dataSeriesIndexes[r],
                  h = this.data[l];
                i.lineWidth = h.lineThickness;
                var d = h.dataPoints,
                  c = "solid";
                if (i.setLineDash) {
                  var p = K(h.nullDataLineDashType, h.lineThickness),
                    u = K((c = h.lineDashType), h.lineThickness);
                  i.setLineDash(u);
                }
                var x = h.id;
                (this._eventManager.objectMap[x] = {
                  objectType: "dataSeries",
                  dataSeriesIndex: l,
                }),
                  (x = N(x)),
                  (a.strokeStyle = x),
                  (a.lineWidth =
                    0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0);
                x = h._colorSet;
                var m =
                  (x =
                  h.lineColor =
                    h.options.lineColor ? h.options.lineColor : x[0]);
                i.strokeStyle = x;
                var g,
                  b,
                  v = !0,
                  f = 0;
                if ((i.beginPath(), 0 < d.length)) {
                  var y = !1;
                  for (f = 0; f < d.length; f++)
                    if (
                      !(
                        (g = d[f].getTime ? d[f].x.getTime() : d[f].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        (g > t.axisX.dataInfo.viewPortMax &&
                          (!h.connectNullData || !y))
                      )
                    )
                      if ("number" != typeof d[f].y)
                        0 < f &&
                          !(h.connectNullData || y || v) &&
                          (i.stroke(), Z && a.stroke()),
                          (y = !0);
                      else {
                        var M = b;
                        (g = t.axisX.convertValueToPixel(g)),
                          (b = t.axisY.convertValueToPixel(d[f].y));
                        var k = h.dataPointIds[f];
                        (this._eventManager.objectMap[k] = {
                          id: k,
                          objectType: "dataPoint",
                          dataSeriesIndex: l,
                          dataPointIndex: f,
                          x1: g,
                          y1: b,
                        }),
                          v || y
                            ? (!v && h.connectNullData
                                ? (i.setLineDash &&
                                    (h.options.nullDataLineDashType ||
                                      (c === h.lineDashType &&
                                        h.lineDashType !==
                                          h.nullDataLineDashType)) &&
                                    (i.stroke(),
                                    i.beginPath(),
                                    i.moveTo(n.x, n.y),
                                    (c = h.nullDataLineDashType),
                                    i.setLineDash(p)),
                                  i.lineTo(g, M),
                                  i.lineTo(g, b),
                                  Z && (a.lineTo(g, M), a.lineTo(g, b)))
                                : (i.beginPath(),
                                  i.moveTo(g, b),
                                  Z && (a.beginPath(), a.moveTo(g, b))),
                              (y = v = !1))
                            : (i.lineTo(g, M),
                              Z && a.lineTo(g, M),
                              i.lineTo(g, b),
                              Z && a.lineTo(g, b),
                              0 == f % 500 &&
                                (i.stroke(),
                                i.beginPath(),
                                i.moveTo(g, b),
                                Z &&
                                  (a.stroke(), a.beginPath(), a.moveTo(g, b)))),
                          (n = { x: g, y: b }),
                          f < d.length - 1 &&
                            (m !== (d[f].lineColor || x) ||
                              c !== (d[f].lineDashType || h.lineDashType)) &&
                            (i.stroke(),
                            i.beginPath(),
                            i.moveTo(g, b),
                            (m = d[f].lineColor || x),
                            (i.strokeStyle = m),
                            i.setLineDash &&
                              (d[f].lineDashType
                                ? ((c = d[f].lineDashType),
                                  i.setLineDash(K(c, h.lineThickness)))
                                : ((c = h.lineDashType), i.setLineDash(u)))),
                          (0 < d[f].markerSize || 0 < h.markerSize) &&
                            ((M = h.getMarkerProperties(f, g, b, i)),
                            o.push(M),
                            (k = N(k)),
                            Z &&
                              o.push({
                                x: g,
                                y: b,
                                ctx: a,
                                type: M.type,
                                size: M.size,
                                color: k,
                                borderColor: k,
                                borderThickness: M.borderThickness,
                              })),
                          (d[f].indexLabel ||
                            h.indexLabel ||
                            d[f].indexLabelFormatter ||
                            h.indexLabelFormatter) &&
                            this._indexLabels.push({
                              chartType: "stepLine",
                              dataPoint: d[f],
                              dataSeries: h,
                              point: { x: g, y: b },
                              direction:
                                d[f].y < 0 === t.axisY.reversed ? 1 : -1,
                              color: x,
                            });
                      }
                  i.stroke(), Z && a.stroke();
                }
              }
              return (
                I.drawMarkers(o),
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(s.x1, s.y1, s.width, s.height),
                  a.beginPath()),
                i.restore(),
                i.beginPath(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderSpline = function (t) {
            function e(t) {
              if (0 < (t = A(t, 2)).length) {
                a.beginPath(),
                  Z && s.beginPath(),
                  a.moveTo(t[0].x, t[0].y),
                  t[0].newStrokeStyle && (a.strokeStyle = t[0].newStrokeStyle),
                  t[0].newLineDashArray && a.setLineDash(t[0].newLineDashArray),
                  Z && s.moveTo(t[0].x, t[0].y);
                for (var e = 0; e < t.length - 3; e += 3)
                  a.bezierCurveTo(
                    t[e + 1].x,
                    t[e + 1].y,
                    t[e + 2].x,
                    t[e + 2].y,
                    t[e + 3].x,
                    t[e + 3].y
                  ),
                    Z &&
                      s.bezierCurveTo(
                        t[e + 1].x,
                        t[e + 1].y,
                        t[e + 2].x,
                        t[e + 2].y,
                        t[e + 3].x,
                        t[e + 3].y
                      ),
                    ((0 < e && 0 == e % 3e3) ||
                      t[e + 3].newStrokeStyle ||
                      t[e + 3].newLineDashArray) &&
                      (a.stroke(),
                      a.beginPath(),
                      a.moveTo(t[e + 3].x, t[e + 3].y),
                      t[e + 3].newStrokeStyle &&
                        (a.strokeStyle = t[e + 3].newStrokeStyle),
                      t[e + 3].newLineDashArray &&
                        a.setLineDash(t[e + 3].newLineDashArray),
                      Z &&
                        (s.stroke(),
                        s.beginPath(),
                        s.moveTo(t[e + 3].x, t[e + 3].y)));
                a.stroke(), Z && s.stroke();
              }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
              a = Z ? this._preRenderCtx : i;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var s = this._eventManager.ghostCtx;
              a.save();
              var n = this.plotArea;
              a.beginPath(), a.rect(n.x1, n.y1, n.width, n.height), a.clip();
              for (var o = [], r = 0; r < t.dataSeriesIndexes.length; r++) {
                var l = t.dataSeriesIndexes[r],
                  h = this.data[l];
                a.lineWidth = h.lineThickness;
                var d = h.dataPoints,
                  c = "solid";
                if (a.setLineDash) {
                  var p = K(h.nullDataLineDashType, h.lineThickness),
                    u = K((c = h.lineDashType), h.lineThickness);
                  a.setLineDash(u);
                }
                var x = h.id;
                (this._eventManager.objectMap[x] = {
                  objectType: "dataSeries",
                  dataSeriesIndex: l,
                }),
                  (x = N(x)),
                  (s.strokeStyle = x),
                  (s.lineWidth =
                    0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0);
                x = h._colorSet;
                var m =
                  (x =
                  h.lineColor =
                    h.options.lineColor ? h.options.lineColor : x[0]);
                a.strokeStyle = x;
                var g,
                  b,
                  v = 0,
                  f = [];
                if ((a.beginPath(), 0 < d.length))
                  for (b = !1, v = 0; v < d.length; v++)
                    if (
                      !(
                        (g = d[v].getTime ? d[v].x.getTime() : d[v].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        (g > t.axisX.dataInfo.viewPortMax &&
                          (!h.connectNullData || !b))
                      )
                    )
                      if ("number" != typeof d[v].y)
                        0 < v &&
                          !b &&
                          (h.connectNullData
                            ? a.setLineDash &&
                              0 < f.length &&
                              (h.options.nullDataLineDashType ||
                                !d[v - 1].lineDashType) &&
                              ((f[f.length - 1].newLineDashArray = p),
                              (c = h.nullDataLineDashType))
                            : (e(f), (f = []))),
                          (b = !0);
                      else {
                        (g = t.axisX.convertValueToPixel(g)),
                          (b = t.axisY.convertValueToPixel(d[v].y));
                        var y = h.dataPointIds[v];
                        if (
                          ((this._eventManager.objectMap[y] = {
                            id: y,
                            objectType: "dataPoint",
                            dataSeriesIndex: l,
                            dataPointIndex: v,
                            x1: g,
                            y1: b,
                          }),
                          (f[f.length] = { x: g, y: b }),
                          v < d.length - 1 &&
                            (m !== (d[v].lineColor || x) ||
                              c !== (d[v].lineDashType || h.lineDashType)) &&
                            ((m = d[v].lineColor || x),
                            (f[f.length - 1].newStrokeStyle = m),
                            a.setLineDash &&
                              (d[v].lineDashType
                                ? ((c = d[v].lineDashType),
                                  (f[f.length - 1].newLineDashArray = K(
                                    c,
                                    h.lineThickness
                                  )))
                                : ((c = h.lineDashType),
                                  (f[f.length - 1].newLineDashArray = u)))),
                          0 < d[v].markerSize || 0 < h.markerSize)
                        ) {
                          var M = h.getMarkerProperties(v, g, b, a);
                          o.push(M),
                            (y = N(y)),
                            Z &&
                              o.push({
                                x: g,
                                y: b,
                                ctx: s,
                                type: M.type,
                                size: M.size,
                                color: y,
                                borderColor: y,
                                borderThickness: M.borderThickness,
                              });
                        }
                        (d[v].indexLabel ||
                          h.indexLabel ||
                          d[v].indexLabelFormatter ||
                          h.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "spline",
                            dataPoint: d[v],
                            dataSeries: h,
                            point: { x: g, y: b },
                            direction: d[v].y < 0 === t.axisY.reversed ? 1 : -1,
                            color: x,
                          }),
                          (b = !1);
                      }
                e(f);
              }
              return (
                I.drawMarkers(o),
                Z &&
                  (i.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (a.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    a.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    a.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  a.clearRect(n.x1, n.y1, n.width, n.height),
                  s.beginPath()),
                a.restore(),
                a.beginPath(),
                {
                  source: i,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          });
        var R = function (t, e, i, a, s, n, o, r, l, h, d, c, p) {
          void 0 === p && (p = 1), (o = o || 0), (r = r || "black");
          var u = 15 < a - e && 15 < s - i ? 8 : 0.35 * Math.min(a - e, s - i);
          t.beginPath(),
            t.moveTo(e, i),
            t.save(),
            (t.fillStyle = n),
            (t.globalAlpha = p),
            t.fillRect(e, i, a - e, s - i),
            (t.globalAlpha = 1),
            0 < o &&
              ((p = 0 == o % 2 ? 0 : 0.5),
              t.beginPath(),
              (t.lineWidth = o),
              (t.strokeStyle = r),
              t.moveTo(e, i),
              t.rect(e - p, i - p, a - e + 2 * p, s - i + 2 * p),
              t.stroke()),
            t.restore(),
            !0 === l &&
              (t.save(),
              t.beginPath(),
              t.moveTo(e, i),
              t.lineTo(e + u, i + u),
              t.lineTo(a - u, i + u),
              t.lineTo(a, i),
              t.closePath(),
              (o = t.createLinearGradient(
                (a + e) / 2,
                i + u,
                (a + e) / 2,
                i
              )).addColorStop(0, n),
              o.addColorStop(1, "rgba(255, 255, 255, .4)"),
              (t.fillStyle = o),
              t.fill(),
              t.restore()),
            !0 === h &&
              (t.save(),
              t.beginPath(),
              t.moveTo(e, s),
              t.lineTo(e + u, s - u),
              t.lineTo(a - u, s - u),
              t.lineTo(a, s),
              t.closePath(),
              (o = t.createLinearGradient(
                (a + e) / 2,
                s - u,
                (a + e) / 2,
                s
              )).addColorStop(0, n),
              o.addColorStop(1, "rgba(255, 255, 255, .4)"),
              (t.fillStyle = o),
              t.fill(),
              t.restore()),
            !0 === d &&
              (t.save(),
              t.beginPath(),
              t.moveTo(e, i),
              t.lineTo(e + u, i + u),
              t.lineTo(e + u, s - u),
              t.lineTo(e, s),
              t.closePath(),
              (o = t.createLinearGradient(
                e + u,
                (s + i) / 2,
                e,
                (s + i) / 2
              )).addColorStop(0, n),
              o.addColorStop(1, "rgba(255, 255, 255, 0.1)"),
              (t.fillStyle = o),
              t.fill(),
              t.restore()),
            !0 === c &&
              (t.save(),
              t.beginPath(),
              t.moveTo(a, i),
              t.lineTo(a - u, i + u),
              t.lineTo(a - u, s - u),
              t.lineTo(a, s),
              (o = t.createLinearGradient(
                a - u,
                (s + i) / 2,
                a,
                (s + i) / 2
              )).addColorStop(0, n),
              o.addColorStop(1, "rgba(255, 255, 255, 0.1)"),
              (t.fillStyle = o).addColorStop(0, n),
              o.addColorStop(1, "rgba(255, 255, 255, 0.1)"),
              (t.fillStyle = o),
              t.fill(),
              t.closePath(),
              t.restore());
        };
        (r.prototype.renderColumn = function (t) {
          var e = t.targetCanvasCtx || this.plotArea.ctx,
            i = Z ? this._preRenderCtx : e;
          if (!(t.dataSeriesIndexes.length <= 0)) {
            var a,
              s,
              n,
              o = null,
              r = this.plotArea,
              l = 0,
              h = t.axisY.convertValueToPixel(
                t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
              ),
              d =
                ((l = this.options.dataPointMinWidth
                  ? this.dataPointMinWidth
                  : this.options.dataPointWidth
                  ? this.dataPointWidth
                  : 1),
                this.options.dataPointMaxWidth
                  ? this.dataPointMaxWidth
                  : this.options.dataPointWidth
                  ? this.dataPointWidth
                  : Math.min(
                      0.15 * this.width,
                      (this.plotArea.width / t.plotType.totalDataSeries) * 0.9
                    ) << 0),
              c = t.axisX.dataInfo.minDiff;
            for (
              isFinite(c) || (c = 0.3 * Math.abs(t.axisX.range)),
                c = this.dataPointWidth =
                  this.options.dataPointWidth
                    ? this.dataPointWidth
                    : (((r.width *
                        (t.axisX.logarithmic
                          ? Math.log(c) / Math.log(t.axisX.range)
                          : Math.abs(c) / Math.abs(t.axisX.range))) /
                        t.plotType.totalDataSeries) *
                        0.9) <<
                      0,
                this.dataPointMaxWidth &&
                  d < l &&
                  (l = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    d
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  d < l &&
                  (d = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    l
                  )),
                c < l && (c = l),
                d < c && (c = d),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(r.x1, r.y1, r.width, r.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    r.x1,
                    r.y1,
                    r.width,
                    r.height
                  ),
                  this._eventManager.ghostCtx.clip()),
                d = 0;
              d < t.dataSeriesIndexes.length;
              d++
            ) {
              var p = t.dataSeriesIndexes[d],
                u = this.data[p],
                x = u.dataPoints;
              if (0 < x.length) {
                var m = !!(5 < c && u.bevelEnabled);
                for (l = 0; l < x.length; l++)
                  if (
                    !(
                      (n = x[l].getTime ? x[l].x.getTime() : x[l].x) <
                        t.axisX.dataInfo.viewPortMin ||
                      n > t.axisX.dataInfo.viewPortMax
                    ) &&
                    "number" == typeof x[l].y
                  ) {
                    (a = t.axisX.convertValueToPixel(n)),
                      (s = t.axisY.convertValueToPixel(x[l].y)),
                      (a = t.axisX.reversed
                        ? (a +
                            (t.plotType.totalDataSeries * c) / 2 -
                            (t.previousDataSeriesCount + d) * c) <<
                          0
                        : (a -
                            (t.plotType.totalDataSeries * c) / 2 +
                            (t.previousDataSeriesCount + d) * c) <<
                          0);
                    var g,
                      b = t.axisX.reversed ? (a - c) << 0 : (a + c) << 0;
                    0 <= x[l].y ? (g = h) : ((g = s), (s = h)),
                      g < s && ((o = s), (s = g), (g = o)),
                      (o = x[l].color
                        ? x[l].color
                        : u._colorSet[l % u._colorSet.length]),
                      R(
                        i,
                        a,
                        s,
                        b,
                        g,
                        o,
                        0,
                        null,
                        m && 0 <= x[l].y,
                        x[l].y < 0 && m,
                        !1,
                        !1,
                        u.fillOpacity
                      ),
                      (o = u.dataPointIds[l]),
                      (this._eventManager.objectMap[o] = {
                        id: o,
                        objectType: "dataPoint",
                        dataSeriesIndex: p,
                        dataPointIndex: l,
                        x1: a,
                        y1: s,
                        x2: b,
                        y2: g,
                      }),
                      (o = N(o)),
                      Z &&
                        R(
                          this._eventManager.ghostCtx,
                          a,
                          s,
                          b,
                          g,
                          o,
                          0,
                          null,
                          !1,
                          !1,
                          !1,
                          !1
                        ),
                      (x[l].indexLabel ||
                        u.indexLabel ||
                        x[l].indexLabelFormatter ||
                        u.indexLabelFormatter) &&
                        this._indexLabels.push({
                          chartType: "column",
                          dataPoint: x[l],
                          dataSeries: u,
                          point: {
                            x: a + (b - a) / 2,
                            y: x[l].y < 0 === t.axisY.reversed ? s : g,
                          },
                          direction: x[l].y < 0 === t.axisY.reversed ? 1 : -1,
                          bounds: {
                            x1: a,
                            y1: Math.min(s, g),
                            x2: b,
                            y2: Math.max(s, g),
                          },
                          color: o,
                        });
                  }
              }
            }
            return (
              Z &&
                (e.drawImage(
                  this._preRenderCanvas,
                  0,
                  0,
                  this.width,
                  this.height
                ),
                (i.globalCompositeOperation = "source-atop"),
                t.axisX.maskCanvas &&
                  i.drawImage(
                    t.axisX.maskCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                t.axisY.maskCanvas &&
                  i.drawImage(
                    t.axisY.maskCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                this._breaksCanvasCtx &&
                  this._breaksCanvasCtx.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                i.clearRect(r.x1, r.y1, r.width, r.height),
                this._eventManager.ghostCtx.restore()),
              i.restore(),
              {
                source: e,
                dest: this.plotArea.ctx,
                animationCallback: j.yScaleAnimation,
                easingFunction: j.easing.easeOutQuart,
                animationBase:
                  h < t.axisY.bounds.y1
                    ? t.axisY.bounds.y1
                    : h > t.axisY.bounds.y2
                    ? t.axisY.bounds.y2
                    : h,
              }
            );
          }
        }),
          (r.prototype.renderStackedColumn = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n = null,
                o = this.plotArea,
                r = [],
                l = [],
                h = [],
                d = [],
                c = 0,
                p = t.axisY.convertValueToPixel(
                  t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                );
              c = this.options.dataPointMinWidth
                ? this.dataPointMinWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : 1;
              a = this.options.dataPointMaxWidth
                ? this.dataPointMaxWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : (0.15 * this.width) << 0;
              var u = t.axisX.dataInfo.minDiff;
              isFinite(u) || (u = 0.3 * Math.abs(t.axisX.range)),
                (u = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (((o.width *
                      (t.axisX.logarithmic
                        ? Math.log(u) / Math.log(t.axisX.range)
                        : Math.abs(u) / Math.abs(t.axisX.range))) /
                      t.plotType.plotUnits.length) *
                      0.9) <<
                    0),
                this.dataPointMaxWidth &&
                  a < c &&
                  (c = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    a
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  a < c &&
                  (a = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    c
                  )),
                u < c && (u = c),
                a < u && (u = a),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(o.x1, o.y1, o.width, o.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    o.x1,
                    o.y1,
                    o.width,
                    o.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var x = 0; x < t.dataSeriesIndexes.length; x++) {
                var m = t.dataSeriesIndexes[x],
                  g = this.data[m],
                  b = g.dataPoints;
                if (0 < b.length) {
                  var v = !!(5 < u && g.bevelEnabled);
                  for (i.strokeStyle = "#4572A7 ", c = 0; c < b.length; c++)
                    if (
                      !(
                        (n = b[c].x.getTime ? b[c].x.getTime() : b[c].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        n > t.axisX.dataInfo.viewPortMax
                      ) &&
                      "number" == typeof b[c].y
                    ) {
                      var f,
                        y =
                          ((a = t.axisX.convertValueToPixel(n)) -
                            (t.plotType.plotUnits.length * u) / 2 +
                            t.index * u) <<
                          0,
                        M = (y + u) << 0;
                      if (
                        t.axisY.logarithmic ||
                        (t.axisY.scaleBreaks &&
                          0 < t.axisY.scaleBreaks._appliedBreaks.length &&
                          0 < b[c].y)
                      )
                        (h[n] = b[c].y + (h[n] ? h[n] : 0)),
                          0 < h[n] &&
                            ((s = t.axisY.convertValueToPixel(h[n])),
                            (f = void 0 !== r[n] ? r[n] : p),
                            (r[n] = s));
                      else if (
                        t.axisY.scaleBreaks &&
                        0 < t.axisY.scaleBreaks._appliedBreaks.length &&
                        b[c].y <= 0
                      )
                        (d[n] = b[c].y + (d[n] ? d[n] : 0)),
                          (f = t.axisY.convertValueToPixel(d[n])),
                          (s = void 0 !== l[n] ? l[n] : p),
                          (l[n] = f);
                      else if (
                        ((s = t.axisY.convertValueToPixel(b[c].y)), 0 <= b[c].y)
                      ) {
                        var k = void 0 !== r[n] ? r[n] : 0;
                        (s -= k), (f = p - k), (r[n] = k + (f - s));
                      } else
                        (f = s + (k = l[n] ? l[n] : 0)),
                          (s = p + k),
                          (l[n] = k + (f - s));
                      (n = b[c].color
                        ? b[c].color
                        : g._colorSet[c % g._colorSet.length]),
                        R(
                          i,
                          y,
                          s,
                          M,
                          f,
                          n,
                          0,
                          null,
                          v && 0 <= b[c].y,
                          b[c].y < 0 && v,
                          !1,
                          !1,
                          g.fillOpacity
                        ),
                        (n = g.dataPointIds[c]),
                        (this._eventManager.objectMap[n] = {
                          id: n,
                          objectType: "dataPoint",
                          dataSeriesIndex: m,
                          dataPointIndex: c,
                          x1: y,
                          y1: s,
                          x2: M,
                          y2: f,
                        }),
                        (n = N(n)),
                        Z &&
                          R(
                            this._eventManager.ghostCtx,
                            y,
                            s,
                            M,
                            f,
                            n,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          ),
                        (b[c].indexLabel ||
                          g.indexLabel ||
                          b[c].indexLabelFormatter ||
                          g.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "stackedColumn",
                            dataPoint: b[c],
                            dataSeries: g,
                            point: { x: a, y: 0 <= b[c].y ? s : f },
                            direction: b[c].y < 0 === t.axisY.reversed ? 1 : -1,
                            bounds: {
                              x1: y,
                              y1: Math.min(s, f),
                              x2: M,
                              y2: Math.max(s, f),
                            },
                            color: n,
                          });
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(o.x1, o.y1, o.width, o.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.yScaleAnimation,
                  easingFunction: j.easing.easeOutQuart,
                  animationBase:
                    p < t.axisY.bounds.y1
                      ? t.axisY.bounds.y1
                      : p > t.axisY.bounds.y2
                      ? t.axisY.bounds.y2
                      : p,
                }
              );
            }
          }),
          (r.prototype.renderStackedColumn100 = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n = null,
                o = this.plotArea,
                r = [],
                l = [],
                h = [],
                d = [],
                c = 0,
                p = t.axisY.convertValueToPixel(
                  t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                );
              c = this.options.dataPointMinWidth
                ? this.dataPointMinWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : 1;
              a = this.options.dataPointMaxWidth
                ? this.dataPointMaxWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : (0.15 * this.width) << 0;
              var u = t.axisX.dataInfo.minDiff;
              isFinite(u) || (u = 0.3 * Math.abs(t.axisX.range)),
                (u = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (((o.width *
                      (t.axisX.logarithmic
                        ? Math.log(u) / Math.log(t.axisX.range)
                        : Math.abs(u) / Math.abs(t.axisX.range))) /
                      t.plotType.plotUnits.length) *
                      0.9) <<
                    0),
                this.dataPointMaxWidth &&
                  a < c &&
                  (c = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    a
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  a < c &&
                  (a = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    c
                  )),
                u < c && (u = c),
                a < u && (u = a),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(o.x1, o.y1, o.width, o.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    o.x1,
                    o.y1,
                    o.width,
                    o.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var x = 0; x < t.dataSeriesIndexes.length; x++) {
                var m = t.dataSeriesIndexes[x],
                  g = this.data[m],
                  b = g.dataPoints;
                if (0 < b.length) {
                  var v = !!(5 < u && g.bevelEnabled);
                  for (c = 0; c < b.length; c++)
                    if (
                      !(
                        (n = b[c].x.getTime ? b[c].x.getTime() : b[c].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        n > t.axisX.dataInfo.viewPortMax
                      ) &&
                      "number" == typeof b[c].y
                    ) {
                      (a = t.axisX.convertValueToPixel(n)),
                        (s =
                          0 !== t.dataPointYSums[n]
                            ? (b[c].y / t.dataPointYSums[n]) * 100
                            : 0);
                      var f,
                        y =
                          (a -
                            (t.plotType.plotUnits.length * u) / 2 +
                            t.index * u) <<
                          0,
                        M = (y + u) << 0;
                      if (
                        t.axisY.logarithmic ||
                        (t.axisY.scaleBreaks &&
                          0 < t.axisY.scaleBreaks._appliedBreaks.length &&
                          0 < b[c].y)
                      ) {
                        if (
                          ((h[n] = s + (void 0 !== h[n] ? h[n] : 0)), h[n] <= 0)
                        )
                          continue;
                        (s = t.axisY.convertValueToPixel(h[n])),
                          (f = r[n] ? r[n] : p),
                          (r[n] = s);
                      } else if (
                        t.axisY.scaleBreaks &&
                        0 < t.axisY.scaleBreaks._appliedBreaks.length &&
                        b[c].y <= 0
                      )
                        (d[n] = s + (void 0 !== d[n] ? d[n] : 0)),
                          (f = t.axisY.convertValueToPixel(d[n])),
                          (s = l[n] ? l[n] : p),
                          (l[n] = f);
                      else if (
                        ((s = t.axisY.convertValueToPixel(s)), 0 <= b[c].y)
                      ) {
                        var k = void 0 !== r[n] ? r[n] : 0;
                        (s -= k),
                          (f = p - k),
                          t.dataSeriesIndexes.length - 1 === x &&
                            Math.abs(o.y1 - s) <= 1 &&
                            (s = o.y1),
                          (r[n] = k + (f - s));
                      } else
                        (f = s + (k = void 0 !== l[n] ? l[n] : 0)),
                          (s = p + k),
                          t.dataSeriesIndexes.length - 1 === x &&
                            Math.abs(o.y2 - f) <= 1 &&
                            (f = o.y2),
                          (l[n] = k + (f - s));
                      (n = b[c].color
                        ? b[c].color
                        : g._colorSet[c % g._colorSet.length]),
                        R(
                          i,
                          y,
                          s,
                          M,
                          f,
                          n,
                          0,
                          null,
                          v && 0 <= b[c].y,
                          b[c].y < 0 && v,
                          !1,
                          !1,
                          g.fillOpacity
                        ),
                        (n = g.dataPointIds[c]),
                        (this._eventManager.objectMap[n] = {
                          id: n,
                          objectType: "dataPoint",
                          dataSeriesIndex: m,
                          dataPointIndex: c,
                          x1: y,
                          y1: s,
                          x2: M,
                          y2: f,
                        }),
                        (n = N(n)),
                        Z &&
                          R(
                            this._eventManager.ghostCtx,
                            y,
                            s,
                            M,
                            f,
                            n,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          ),
                        (b[c].indexLabel ||
                          g.indexLabel ||
                          b[c].indexLabelFormatter ||
                          g.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "stackedColumn100",
                            dataPoint: b[c],
                            dataSeries: g,
                            point: { x: a, y: 0 <= b[c].y ? s : f },
                            direction: b[c].y < 0 === t.axisY.reversed ? 1 : -1,
                            bounds: {
                              x1: y,
                              y1: Math.min(s, f),
                              x2: M,
                              y2: Math.max(s, f),
                            },
                            color: n,
                          });
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(o.x1, o.y1, o.width, o.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.yScaleAnimation,
                  easingFunction: j.easing.easeOutQuart,
                  animationBase:
                    p < t.axisY.bounds.y1
                      ? t.axisY.bounds.y1
                      : p > t.axisY.bounds.y2
                      ? t.axisY.bounds.y2
                      : p,
                }
              );
            }
          }),
          (r.prototype.renderBar = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n,
                o = null,
                r = this.plotArea,
                l = 0,
                h = t.axisY.convertValueToPixel(
                  t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                ),
                d =
                  ((l = this.options.dataPointMinWidth
                    ? this.dataPointMinWidth
                    : this.options.dataPointWidth
                    ? this.dataPointWidth
                    : 1),
                  this.options.dataPointMaxWidth
                    ? this.dataPointMaxWidth
                    : this.options.dataPointWidth
                    ? this.dataPointWidth
                    : Math.min(
                        0.15 * this.height,
                        (this.plotArea.height / t.plotType.totalDataSeries) *
                          0.9
                      ) << 0),
                c = t.axisX.dataInfo.minDiff;
              for (
                isFinite(c) || (c = 0.3 * Math.abs(t.axisX.range)),
                  c = this.options.dataPointWidth
                    ? this.dataPointWidth
                    : (((r.height *
                        (t.axisX.logarithmic
                          ? Math.log(c) / Math.log(t.axisX.range)
                          : Math.abs(c) / Math.abs(t.axisX.range))) /
                        t.plotType.totalDataSeries) *
                        0.9) <<
                      0,
                  this.dataPointMaxWidth &&
                    d < l &&
                    (l = Math.min(
                      this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                      d
                    )),
                  !this.dataPointMaxWidth &&
                    this.dataPointMinWidth &&
                    d < l &&
                    (d = Math.max(
                      this.options.dataPointWidth
                        ? this.dataPointWidth
                        : -1 / 0,
                      l
                    )),
                  c < l && (c = l),
                  d < c && (c = d),
                  i.save(),
                  Z && this._eventManager.ghostCtx.save(),
                  i.beginPath(),
                  i.rect(r.x1, r.y1, r.width, r.height),
                  i.clip(),
                  Z &&
                    (this._eventManager.ghostCtx.beginPath(),
                    this._eventManager.ghostCtx.rect(
                      r.x1,
                      r.y1,
                      r.width,
                      r.height
                    ),
                    this._eventManager.ghostCtx.clip()),
                  d = 0;
                d < t.dataSeriesIndexes.length;
                d++
              ) {
                var p = t.dataSeriesIndexes[d],
                  u = this.data[p],
                  x = u.dataPoints;
                if (0 < x.length) {
                  var m = !!(5 < c && u.bevelEnabled);
                  for (i.strokeStyle = "#4572A7 ", l = 0; l < x.length; l++)
                    if (
                      !(
                        (n = x[l].getTime ? x[l].x.getTime() : x[l].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        n > t.axisX.dataInfo.viewPortMax
                      ) &&
                      "number" == typeof x[l].y
                    ) {
                      (s = t.axisX.convertValueToPixel(n)),
                        (a = t.axisY.convertValueToPixel(x[l].y)),
                        (s = t.axisX.reversed
                          ? (s +
                              (t.plotType.totalDataSeries * c) / 2 -
                              (t.previousDataSeriesCount + d) * c) <<
                            0
                          : (s -
                              (t.plotType.totalDataSeries * c) / 2 +
                              (t.previousDataSeriesCount + d) * c) <<
                            0);
                      var g,
                        b = t.axisX.reversed ? (s - c) << 0 : (s + c) << 0;
                      0 <= x[l].y ? (g = h) : ((g = a), (a = h)),
                        (o = x[l].color
                          ? x[l].color
                          : u._colorSet[l % u._colorSet.length]),
                        R(
                          i,
                          g,
                          s,
                          a,
                          b,
                          o,
                          0,
                          null,
                          m,
                          !1,
                          !1,
                          !1,
                          u.fillOpacity
                        ),
                        (o = u.dataPointIds[l]),
                        (this._eventManager.objectMap[o] = {
                          id: o,
                          objectType: "dataPoint",
                          dataSeriesIndex: p,
                          dataPointIndex: l,
                          x1: g,
                          y1: s,
                          x2: a,
                          y2: b,
                        }),
                        (o = N(o)),
                        Z &&
                          R(
                            this._eventManager.ghostCtx,
                            g,
                            s,
                            a,
                            b,
                            o,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          ),
                        (x[l].indexLabel ||
                          u.indexLabel ||
                          x[l].indexLabelFormatter ||
                          u.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "bar",
                            dataPoint: x[l],
                            dataSeries: u,
                            point: {
                              x: 0 <= x[l].y ? a : g,
                              y: s + (b - s) / 2,
                            },
                            direction: x[l].y < 0 === t.axisY.reversed ? 1 : -1,
                            bounds: {
                              x1: Math.min(g, a),
                              y1: s,
                              x2: Math.max(g, a),
                              y2: b,
                            },
                            color: o,
                          });
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(r.x1, r.y1, r.width, r.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xScaleAnimation,
                  easingFunction: j.easing.easeOutQuart,
                  animationBase:
                    h < t.axisY.bounds.x1
                      ? t.axisY.bounds.x1
                      : h > t.axisY.bounds.x2
                      ? t.axisY.bounds.x2
                      : h,
                }
              );
            }
          }),
          (r.prototype.renderStackedBar = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n = null,
                o = this.plotArea,
                r = [],
                l = [],
                h = [],
                d = [],
                c = 0,
                p = t.axisY.convertValueToPixel(
                  t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                );
              c = this.options.dataPointMinWidth
                ? this.dataPointMinWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : 1;
              s = this.options.dataPointMaxWidth
                ? this.dataPointMaxWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : (0.15 * this.height) << 0;
              var u = t.axisX.dataInfo.minDiff;
              isFinite(u) || (u = 0.3 * Math.abs(t.axisX.range)),
                (u = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (((o.height *
                      (t.axisX.logarithmic
                        ? Math.log(u) / Math.log(t.axisX.range)
                        : Math.abs(u) / Math.abs(t.axisX.range))) /
                      t.plotType.plotUnits.length) *
                      0.9) <<
                    0),
                this.dataPointMaxWidth &&
                  s < c &&
                  (c = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    s
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  s < c &&
                  (s = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    c
                  )),
                u < c && (u = c),
                s < u && (u = s),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(o.x1, o.y1, o.width, o.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    o.x1,
                    o.y1,
                    o.width,
                    o.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var x = 0; x < t.dataSeriesIndexes.length; x++) {
                var m = t.dataSeriesIndexes[x],
                  g = this.data[m],
                  b = g.dataPoints;
                if (0 < b.length) {
                  var v = !!(5 < u && g.bevelEnabled);
                  for (i.strokeStyle = "#4572A7 ", c = 0; c < b.length; c++)
                    if (
                      !(
                        (n = b[c].x.getTime ? b[c].x.getTime() : b[c].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        n > t.axisX.dataInfo.viewPortMax
                      ) &&
                      "number" == typeof b[c].y
                    ) {
                      var f,
                        y =
                          ((s = t.axisX.convertValueToPixel(n)) -
                            (t.plotType.plotUnits.length * u) / 2 +
                            t.index * u) <<
                          0,
                        M = (y + u) << 0;
                      if (
                        t.axisY.logarithmic ||
                        (t.axisY.scaleBreaks &&
                          0 < t.axisY.scaleBreaks._appliedBreaks.length &&
                          0 < b[c].y)
                      )
                        (h[n] = b[c].y + (h[n] ? h[n] : 0)),
                          0 < h[n] &&
                            ((f = r[n] ? r[n] : p),
                            (r[n] = a = t.axisY.convertValueToPixel(h[n])));
                      else if (
                        t.axisY.scaleBreaks &&
                        0 < t.axisY.scaleBreaks._appliedBreaks.length &&
                        b[c].y <= 0
                      )
                        (d[n] = b[c].y + (d[n] ? d[n] : 0)),
                          (a = l[n] ? l[n] : p),
                          (l[n] = f = t.axisY.convertValueToPixel(d[n]));
                      else if (
                        ((a = t.axisY.convertValueToPixel(b[c].y)), 0 <= b[c].y)
                      ) {
                        var k = r[n] ? r[n] : 0;
                        (f = p + k), (a += k), (r[n] = k + (a - f));
                      } else
                        (f = a - (k = l[n] ? l[n] : 0)),
                          (a = p - k),
                          (l[n] = k + (a - f));
                      (n = b[c].color
                        ? b[c].color
                        : g._colorSet[c % g._colorSet.length]),
                        R(
                          i,
                          f,
                          y,
                          a,
                          M,
                          n,
                          0,
                          null,
                          v,
                          !1,
                          !1,
                          !1,
                          g.fillOpacity
                        ),
                        (n = g.dataPointIds[c]),
                        (this._eventManager.objectMap[n] = {
                          id: n,
                          objectType: "dataPoint",
                          dataSeriesIndex: m,
                          dataPointIndex: c,
                          x1: f,
                          y1: y,
                          x2: a,
                          y2: M,
                        }),
                        (n = N(n)),
                        Z &&
                          R(
                            this._eventManager.ghostCtx,
                            f,
                            y,
                            a,
                            M,
                            n,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          ),
                        (b[c].indexLabel ||
                          g.indexLabel ||
                          b[c].indexLabelFormatter ||
                          g.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "stackedBar",
                            dataPoint: b[c],
                            dataSeries: g,
                            point: { x: 0 <= b[c].y ? a : f, y: s },
                            direction: b[c].y < 0 === t.axisY.reversed ? 1 : -1,
                            bounds: {
                              x1: Math.min(f, a),
                              y1: y,
                              x2: Math.max(f, a),
                              y2: M,
                            },
                            color: n,
                          });
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(o.x1, o.y1, o.width, o.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xScaleAnimation,
                  easingFunction: j.easing.easeOutQuart,
                  animationBase:
                    p < t.axisY.bounds.x1
                      ? t.axisY.bounds.x1
                      : p > t.axisY.bounds.x2
                      ? t.axisY.bounds.x2
                      : p,
                }
              );
            }
          }),
          (r.prototype.renderStackedBar100 = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n = null,
                o = this.plotArea,
                r = [],
                l = [],
                h = [],
                d = [],
                c = 0,
                p = t.axisY.convertValueToPixel(
                  t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                );
              c = this.options.dataPointMinWidth
                ? this.dataPointMinWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : 1;
              s = this.options.dataPointMaxWidth
                ? this.dataPointMaxWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : (0.15 * this.height) << 0;
              var u = t.axisX.dataInfo.minDiff;
              isFinite(u) || (u = 0.3 * Math.abs(t.axisX.range)),
                (u = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (((o.height *
                      (t.axisX.logarithmic
                        ? Math.log(u) / Math.log(t.axisX.range)
                        : Math.abs(u) / Math.abs(t.axisX.range))) /
                      t.plotType.plotUnits.length) *
                      0.9) <<
                    0),
                this.dataPointMaxWidth &&
                  s < c &&
                  (c = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    s
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  s < c &&
                  (s = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    c
                  )),
                u < c && (u = c),
                s < u && (u = s),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(o.x1, o.y1, o.width, o.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    o.x1,
                    o.y1,
                    o.width,
                    o.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var x = 0; x < t.dataSeriesIndexes.length; x++) {
                var m = t.dataSeriesIndexes[x],
                  g = this.data[m],
                  b = g.dataPoints;
                if (0 < b.length) {
                  var v = !!(5 < u && g.bevelEnabled);
                  for (i.strokeStyle = "#4572A7 ", c = 0; c < b.length; c++)
                    if (
                      !(
                        (n = b[c].x.getTime ? b[c].x.getTime() : b[c].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        n > t.axisX.dataInfo.viewPortMax
                      ) &&
                      "number" == typeof b[c].y
                    ) {
                      var f;
                      (s = t.axisX.convertValueToPixel(n)),
                        (f =
                          0 !== t.dataPointYSums[n]
                            ? (b[c].y / t.dataPointYSums[n]) * 100
                            : 0);
                      var y =
                          (s -
                            (t.plotType.plotUnits.length * u) / 2 +
                            t.index * u) <<
                          0,
                        M = (y + u) << 0;
                      if (
                        t.axisY.logarithmic ||
                        (t.axisY.scaleBreaks &&
                          0 < t.axisY.scaleBreaks._appliedBreaks.length &&
                          0 < b[c].y)
                      ) {
                        if (((h[n] = f + (h[n] ? h[n] : 0)), h[n] <= 0))
                          continue;
                        (f = r[n] ? r[n] : p),
                          (r[n] = a = t.axisY.convertValueToPixel(h[n]));
                      } else if (
                        t.axisY.scaleBreaks &&
                        0 < t.axisY.scaleBreaks._appliedBreaks.length &&
                        b[c].y <= 0
                      )
                        (d[n] = f + (d[n] ? d[n] : 0)),
                          (a = l[n] ? l[n] : p),
                          (l[n] = f = t.axisY.convertValueToPixel(d[n]));
                      else if (
                        ((a = t.axisY.convertValueToPixel(f)), 0 <= b[c].y)
                      ) {
                        var k = r[n] ? r[n] : 0;
                        (f = p + k),
                          (a += k),
                          t.dataSeriesIndexes.length - 1 === x &&
                            Math.abs(o.x2 - a) <= 1 &&
                            (a = o.x2),
                          (r[n] = k + (a - f));
                      } else
                        (f = a - (k = l[n] ? l[n] : 0)),
                          (a = p - k),
                          t.dataSeriesIndexes.length - 1 === x &&
                            Math.abs(o.x1 - f) <= 1 &&
                            (f = o.x1),
                          (l[n] = k + (a - f));
                      (n = b[c].color
                        ? b[c].color
                        : g._colorSet[c % g._colorSet.length]),
                        R(
                          i,
                          f,
                          y,
                          a,
                          M,
                          n,
                          0,
                          null,
                          v,
                          !1,
                          !1,
                          !1,
                          g.fillOpacity
                        ),
                        (n = g.dataPointIds[c]),
                        (this._eventManager.objectMap[n] = {
                          id: n,
                          objectType: "dataPoint",
                          dataSeriesIndex: m,
                          dataPointIndex: c,
                          x1: f,
                          y1: y,
                          x2: a,
                          y2: M,
                        }),
                        (n = N(n)),
                        Z &&
                          R(
                            this._eventManager.ghostCtx,
                            f,
                            y,
                            a,
                            M,
                            n,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          ),
                        (b[c].indexLabel ||
                          g.indexLabel ||
                          b[c].indexLabelFormatter ||
                          g.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "stackedBar100",
                            dataPoint: b[c],
                            dataSeries: g,
                            point: { x: 0 <= b[c].y ? a : f, y: s },
                            direction: b[c].y < 0 === t.axisY.reversed ? 1 : -1,
                            bounds: {
                              x1: Math.min(f, a),
                              y1: y,
                              x2: Math.max(f, a),
                              y2: M,
                            },
                            color: n,
                          });
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(o.x1, o.y1, o.width, o.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xScaleAnimation,
                  easingFunction: j.easing.easeOutQuart,
                  animationBase:
                    p < t.axisY.bounds.x1
                      ? t.axisY.bounds.x1
                      : p > t.axisY.bounds.x2
                      ? t.axisY.bounds.x2
                      : p,
                }
              );
            }
          }),
          (r.prototype.renderArea = function (t) {
            var e, i;
            function a() {
              k &&
                (0 < x.lineThickness && n.stroke(),
                t.axisY.logarithmic ||
                (t.axisY.viewportMinimum <= 0 && 0 <= t.axisY.viewportMaximum)
                  ? (f = M)
                  : t.axisY.viewportMaximum < 0
                  ? (f = h.y1)
                  : 0 < t.axisY.viewportMinimum && (f = l.y2),
                n.lineTo(g, f),
                n.lineTo(k.x, f),
                n.closePath(),
                (n.globalAlpha = x.fillOpacity),
                n.fill(),
                (n.globalAlpha = 1),
                Z &&
                  (r.lineTo(g, f), r.lineTo(k.x, f), r.closePath(), r.fill()),
                n.beginPath(),
                n.moveTo(g, b),
                r.beginPath(),
                r.moveTo(g, b),
                (k = { x: g, y: b }));
            }
            var s = t.targetCanvasCtx || this.plotArea.ctx,
              n = Z ? this._preRenderCtx : s;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var o,
                r = this._eventManager.ghostCtx,
                l = t.axisX.lineCoordinates,
                h = t.axisY.lineCoordinates,
                d = [],
                c = this.plotArea;
              n.save(),
                Z && r.save(),
                n.beginPath(),
                n.rect(c.x1, c.y1, c.width, c.height),
                n.clip(),
                Z &&
                  (r.beginPath(),
                  r.rect(c.x1, c.y1, c.width, c.height),
                  r.clip());
              for (var p = 0; p < t.dataSeriesIndexes.length; p++) {
                var u = t.dataSeriesIndexes[p],
                  x = this.data[u],
                  m = x.dataPoints;
                d = x.id;
                (this._eventManager.objectMap[d] = {
                  objectType: "dataSeries",
                  dataSeriesIndex: u,
                }),
                  (d = N(d)),
                  (r.fillStyle = d),
                  (d = []),
                  (e = !0);
                var g,
                  b,
                  v,
                  f,
                  y = 0,
                  M = t.axisY.convertValueToPixel(
                    t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                  ),
                  k = null;
                if (0 < m.length) {
                  var w = x._colorSet[y % x._colorSet.length],
                    T = (x.lineColor = x.options.lineColor || w),
                    C = T;
                  if (
                    ((n.fillStyle = w),
                    (n.strokeStyle = T),
                    (n.lineWidth = x.lineThickness),
                    (i = "solid"),
                    n.setLineDash)
                  ) {
                    var P = K(x.nullDataLineDashType, x.lineThickness),
                      S = K((i = x.lineDashType), x.lineThickness);
                    n.setLineDash(S);
                  }
                  for (var A = !0; y < m.length; y++)
                    if (
                      !(
                        (v = m[y].x.getTime ? m[y].x.getTime() : m[y].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        (v > t.axisX.dataInfo.viewPortMax &&
                          (!x.connectNullData || !A))
                      )
                    )
                      if ("number" != typeof m[y].y)
                        x.connectNullData || A || e || a(), (A = !0);
                      else {
                        (g = t.axisX.convertValueToPixel(v)),
                          (b = t.axisY.convertValueToPixel(m[y].y)),
                          e || A
                            ? (!e && x.connectNullData
                                ? (n.setLineDash &&
                                    (x.options.nullDataLineDashType ||
                                      (i === x.lineDashType &&
                                        x.lineDashType !==
                                          x.nullDataLineDashType)) &&
                                    ((e = g),
                                    (i = b),
                                    (g = o.x),
                                    (b = o.y),
                                    a(),
                                    n.moveTo(o.x, o.y),
                                    (g = e),
                                    (b = i),
                                    (k = o),
                                    (i = x.nullDataLineDashType),
                                    n.setLineDash(P)),
                                  n.lineTo(g, b),
                                  Z && r.lineTo(g, b))
                                : (n.beginPath(),
                                  n.moveTo(g, b),
                                  Z && (r.beginPath(), r.moveTo(g, b)),
                                  (k = { x: g, y: b })),
                              (A = e = !1))
                            : (n.lineTo(g, b),
                              Z && r.lineTo(g, b),
                              0 == y % 250 && a()),
                          (o = { x: g, y: b }),
                          y < m.length - 1 &&
                            (C !== (m[y].lineColor || T) ||
                              i !== (m[y].lineDashType || x.lineDashType)) &&
                            (a(),
                            (C = m[y].lineColor || T),
                            (n.strokeStyle = C),
                            n.setLineDash &&
                              (m[y].lineDashType
                                ? ((i = m[y].lineDashType),
                                  n.setLineDash(K(i, x.lineThickness)))
                                : ((i = x.lineDashType), n.setLineDash(S))));
                        var _ = x.dataPointIds[y];
                        (this._eventManager.objectMap[_] = {
                          id: _,
                          objectType: "dataPoint",
                          dataSeriesIndex: u,
                          dataPointIndex: y,
                          x1: g,
                          y1: b,
                        }),
                          0 !== m[y].markerSize &&
                            (0 < m[y].markerSize || 0 < x.markerSize) &&
                            ((v = x.getMarkerProperties(y, g, b, n)),
                            d.push(v),
                            (_ = N(_)),
                            Z &&
                              d.push({
                                x: g,
                                y: b,
                                ctx: r,
                                type: v.type,
                                size: v.size,
                                color: _,
                                borderColor: _,
                                borderThickness: v.borderThickness,
                              })),
                          (m[y].indexLabel ||
                            x.indexLabel ||
                            m[y].indexLabelFormatter ||
                            x.indexLabelFormatter) &&
                            this._indexLabels.push({
                              chartType: "area",
                              dataPoint: m[y],
                              dataSeries: x,
                              point: { x: g, y: b },
                              direction:
                                m[y].y < 0 === t.axisY.reversed ? 1 : -1,
                              color: w,
                            });
                      }
                  a(), I.drawMarkers(d);
                }
              }
              return (
                Z &&
                  (s.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (n.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    n.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    n.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  n.clearRect(c.x1, c.y1, c.width, c.height),
                  this._eventManager.ghostCtx.restore()),
                n.restore(),
                {
                  source: s,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderSplineArea = function (i) {
            function t() {
              var t = A(f, 2);
              if (0 < t.length) {
                if (0 < c.lineThickness) {
                  a.beginPath(),
                    a.moveTo(t[0].x, t[0].y),
                    t[0].newStrokeStyle &&
                      (a.strokeStyle = t[0].newStrokeStyle),
                    t[0].newLineDashArray &&
                      a.setLineDash(t[0].newLineDashArray);
                  for (var e = 0; e < t.length - 3; e += 3)
                    a.bezierCurveTo(
                      t[e + 1].x,
                      t[e + 1].y,
                      t[e + 2].x,
                      t[e + 2].y,
                      t[e + 3].x,
                      t[e + 3].y
                    ),
                      Z &&
                        s.bezierCurveTo(
                          t[e + 1].x,
                          t[e + 1].y,
                          t[e + 2].x,
                          t[e + 2].y,
                          t[e + 3].x,
                          t[e + 3].y
                        ),
                      (t[e + 3].newStrokeStyle || t[e + 3].newLineDashArray) &&
                        (a.stroke(),
                        a.beginPath(),
                        a.moveTo(t[e + 3].x, t[e + 3].y),
                        t[e + 3].newStrokeStyle &&
                          (a.strokeStyle = t[e + 3].newStrokeStyle),
                        t[e + 3].newLineDashArray &&
                          a.setLineDash(t[e + 3].newLineDashArray));
                  a.stroke();
                }
                for (
                  a.beginPath(),
                    a.moveTo(t[0].x, t[0].y),
                    Z && (s.beginPath(), s.moveTo(t[0].x, t[0].y)),
                    e = 0;
                  e < t.length - 3;
                  e += 3
                )
                  a.bezierCurveTo(
                    t[e + 1].x,
                    t[e + 1].y,
                    t[e + 2].x,
                    t[e + 2].y,
                    t[e + 3].x,
                    t[e + 3].y
                  ),
                    Z &&
                      s.bezierCurveTo(
                        t[e + 1].x,
                        t[e + 1].y,
                        t[e + 2].x,
                        t[e + 2].y,
                        t[e + 3].x,
                        t[e + 3].y
                      );
                i.axisY.logarithmic ||
                (i.axisY.viewportMinimum <= 0 && 0 <= i.axisY.viewportMaximum)
                  ? (m = b)
                  : i.axisY.viewportMaximum < 0
                  ? (m = o.y1)
                  : 0 < i.axisY.viewportMinimum && (m = n.y2),
                  (v = { x: t[0].x, y: t[0].y }),
                  a.lineTo(t[t.length - 1].x, m),
                  a.lineTo(v.x, m),
                  a.closePath(),
                  (a.globalAlpha = c.fillOpacity),
                  a.fill(),
                  (a.globalAlpha = 1),
                  Z &&
                    (s.lineTo(t[t.length - 1].x, m),
                    s.lineTo(v.x, m),
                    s.closePath(),
                    s.fill());
              }
            }
            var e = i.targetCanvasCtx || this.plotArea.ctx,
              a = Z ? this._preRenderCtx : e;
            if (!(i.dataSeriesIndexes.length <= 0)) {
              var s = this._eventManager.ghostCtx,
                n = i.axisX.lineCoordinates,
                o = i.axisY.lineCoordinates,
                r = [],
                l = this.plotArea;
              a.save(),
                Z && s.save(),
                a.beginPath(),
                a.rect(l.x1, l.y1, l.width, l.height),
                a.clip(),
                Z &&
                  (s.beginPath(),
                  s.rect(l.x1, l.y1, l.width, l.height),
                  s.clip());
              for (var h = 0; h < i.dataSeriesIndexes.length; h++) {
                var d = i.dataSeriesIndexes[h],
                  c = this.data[d],
                  p = c.dataPoints;
                r = c.id;
                (this._eventManager.objectMap[r] = {
                  objectType: "dataSeries",
                  dataSeriesIndex: d,
                }),
                  (r = N(r)),
                  (s.fillStyle = r);
                r = [];
                var u,
                  x,
                  m,
                  g = 0,
                  b = i.axisY.convertValueToPixel(
                    i.axisY.logarithmic ? i.axisY.viewportMinimum : 0
                  ),
                  v = null,
                  f = [];
                if (0 < p.length) {
                  var y = c._colorSet[g % c._colorSet.length],
                    M = (c.lineColor = c.options.lineColor || y),
                    k = M;
                  (a.fillStyle = y),
                    (a.strokeStyle = M),
                    (a.lineWidth = c.lineThickness);
                  var w = "solid";
                  if (a.setLineDash) {
                    var T = K(c.nullDataLineDashType, c.lineThickness),
                      C = K((w = c.lineDashType), c.lineThickness);
                    a.setLineDash(C);
                  }
                  for (x = !1; g < p.length; g++)
                    if (
                      !(
                        (u = p[g].x.getTime ? p[g].x.getTime() : p[g].x) <
                          i.axisX.dataInfo.viewPortMin ||
                        (u > i.axisX.dataInfo.viewPortMax &&
                          (!c.connectNullData || !x))
                      )
                    )
                      if ("number" != typeof p[g].y)
                        0 < g &&
                          !x &&
                          (c.connectNullData
                            ? a.setLineDash &&
                              0 < f.length &&
                              (c.options.nullDataLineDashType ||
                                !p[g - 1].lineDashType) &&
                              ((f[f.length - 1].newLineDashArray = T),
                              (w = c.nullDataLineDashType))
                            : (t(), (f = []))),
                          (x = !0);
                      else {
                        (u = i.axisX.convertValueToPixel(u)),
                          (x = i.axisY.convertValueToPixel(p[g].y));
                        var P = c.dataPointIds[g];
                        if (
                          ((this._eventManager.objectMap[P] = {
                            id: P,
                            objectType: "dataPoint",
                            dataSeriesIndex: d,
                            dataPointIndex: g,
                            x1: u,
                            y1: x,
                          }),
                          (f[f.length] = { x: u, y: x }),
                          g < p.length - 1 &&
                            (k !== (p[g].lineColor || M) ||
                              w !== (p[g].lineDashType || c.lineDashType)) &&
                            ((k = p[g].lineColor || M),
                            (f[f.length - 1].newStrokeStyle = k),
                            a.setLineDash &&
                              (p[g].lineDashType
                                ? ((w = p[g].lineDashType),
                                  (f[f.length - 1].newLineDashArray = K(
                                    w,
                                    c.lineThickness
                                  )))
                                : ((w = c.lineDashType),
                                  (f[f.length - 1].newLineDashArray = C)))),
                          0 !== p[g].markerSize &&
                            (0 < p[g].markerSize || 0 < c.markerSize))
                        ) {
                          var S = c.getMarkerProperties(g, u, x, a);
                          r.push(S),
                            (P = N(P)),
                            Z &&
                              r.push({
                                x: u,
                                y: x,
                                ctx: s,
                                type: S.type,
                                size: S.size,
                                color: P,
                                borderColor: P,
                                borderThickness: S.borderThickness,
                              });
                        }
                        (p[g].indexLabel ||
                          c.indexLabel ||
                          p[g].indexLabelFormatter ||
                          c.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "splineArea",
                            dataPoint: p[g],
                            dataSeries: c,
                            point: { x: u, y: x },
                            direction: p[g].y < 0 === i.axisY.reversed ? 1 : -1,
                            color: y,
                          }),
                          (x = !1);
                      }
                  t(), I.drawMarkers(r);
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (a.globalCompositeOperation = "source-atop"),
                  i.axisX.maskCanvas &&
                    a.drawImage(
                      i.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.axisY.maskCanvas &&
                    a.drawImage(
                      i.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  a.clearRect(l.x1, l.y1, l.width, l.height),
                  this._eventManager.ghostCtx.restore()),
                a.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderStepArea = function (t) {
            var e, i;
            function a() {
              k &&
                (0 < x.lineThickness && n.stroke(),
                t.axisY.logarithmic ||
                (t.axisY.viewportMinimum <= 0 && 0 <= t.axisY.viewportMaximum)
                  ? (f = M)
                  : t.axisY.viewportMaximum < 0
                  ? (f = h.y1)
                  : 0 < t.axisY.viewportMinimum && (f = l.y2),
                n.lineTo(g, f),
                n.lineTo(k.x, f),
                n.closePath(),
                (n.globalAlpha = x.fillOpacity),
                n.fill(),
                (n.globalAlpha = 1),
                Z &&
                  (r.lineTo(g, f), r.lineTo(k.x, f), r.closePath(), r.fill()),
                n.beginPath(),
                n.moveTo(g, b),
                r.beginPath(),
                r.moveTo(g, b),
                (k = { x: g, y: b }));
            }
            var s = t.targetCanvasCtx || this.plotArea.ctx,
              n = Z ? this._preRenderCtx : s;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var o,
                r = this._eventManager.ghostCtx,
                l = t.axisX.lineCoordinates,
                h = t.axisY.lineCoordinates,
                d = [],
                c = this.plotArea;
              n.save(),
                Z && r.save(),
                n.beginPath(),
                n.rect(c.x1, c.y1, c.width, c.height),
                n.clip(),
                Z &&
                  (r.beginPath(),
                  r.rect(c.x1, c.y1, c.width, c.height),
                  r.clip());
              for (var p = 0; p < t.dataSeriesIndexes.length; p++) {
                var u = t.dataSeriesIndexes[p],
                  x = this.data[u],
                  m = x.dataPoints;
                d = x.id;
                (this._eventManager.objectMap[d] = {
                  objectType: "dataSeries",
                  dataSeriesIndex: u,
                }),
                  (d = N(d)),
                  (r.fillStyle = d),
                  (d = []),
                  (e = !0);
                var g,
                  b,
                  v,
                  f,
                  y = 0,
                  M = t.axisY.convertValueToPixel(
                    t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                  ),
                  k = null;
                if (((i = !1), 0 < m.length)) {
                  var w = x._colorSet[y % x._colorSet.length],
                    T = (x.lineColor = x.options.lineColor || w),
                    C = T;
                  (n.fillStyle = w),
                    (n.strokeStyle = T),
                    (n.lineWidth = x.lineThickness);
                  var P = "solid";
                  if (n.setLineDash) {
                    var S = K(x.nullDataLineDashType, x.lineThickness),
                      A = K((P = x.lineDashType), x.lineThickness);
                    n.setLineDash(A);
                  }
                  for (; y < m.length; y++)
                    if (
                      !(
                        (v = m[y].x.getTime ? m[y].x.getTime() : m[y].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        (v > t.axisX.dataInfo.viewPortMax &&
                          (!x.connectNullData || !i))
                      )
                    ) {
                      var _ = b;
                      "number" != typeof m[y].y
                        ? (x.connectNullData || i || e || a(), (i = !0))
                        : ((g = t.axisX.convertValueToPixel(v)),
                          (b = t.axisY.convertValueToPixel(m[y].y)),
                          e || i
                            ? (!e && x.connectNullData
                                ? (n.setLineDash &&
                                    (x.options.nullDataLineDashType ||
                                      (P === x.lineDashType &&
                                        x.lineDashType !==
                                          x.nullDataLineDashType)) &&
                                    ((e = g),
                                    (i = b),
                                    (g = o.x),
                                    (b = o.y),
                                    a(),
                                    n.moveTo(o.x, o.y),
                                    (g = e),
                                    (b = i),
                                    (k = o),
                                    (P = x.nullDataLineDashType),
                                    n.setLineDash(S)),
                                  n.lineTo(g, _),
                                  n.lineTo(g, b),
                                  Z && (r.lineTo(g, _), r.lineTo(g, b)))
                                : (n.beginPath(),
                                  n.moveTo(g, b),
                                  Z && (r.beginPath(), r.moveTo(g, b)),
                                  (k = { x: g, y: b })),
                              (i = e = !1))
                            : (n.lineTo(g, _),
                              Z && r.lineTo(g, _),
                              n.lineTo(g, b),
                              Z && r.lineTo(g, b),
                              0 == y % 250 && a()),
                          (o = { x: g, y: b }),
                          y < m.length - 1 &&
                            (C !== (m[y].lineColor || T) ||
                              P !== (m[y].lineDashType || x.lineDashType)) &&
                            (a(),
                            (C = m[y].lineColor || T),
                            (n.strokeStyle = C),
                            n.setLineDash &&
                              (m[y].lineDashType
                                ? ((P = m[y].lineDashType),
                                  n.setLineDash(K(P, x.lineThickness)))
                                : ((P = x.lineDashType), n.setLineDash(A)))),
                          (v = x.dataPointIds[y]),
                          (this._eventManager.objectMap[v] = {
                            id: v,
                            objectType: "dataPoint",
                            dataSeriesIndex: u,
                            dataPointIndex: y,
                            x1: g,
                            y1: b,
                          }),
                          0 !== m[y].markerSize &&
                            (0 < m[y].markerSize || 0 < x.markerSize) &&
                            ((_ = x.getMarkerProperties(y, g, b, n)),
                            d.push(_),
                            (v = N(v)),
                            Z &&
                              d.push({
                                x: g,
                                y: b,
                                ctx: r,
                                type: _.type,
                                size: _.size,
                                color: v,
                                borderColor: v,
                                borderThickness: _.borderThickness,
                              })),
                          (m[y].indexLabel ||
                            x.indexLabel ||
                            m[y].indexLabelFormatter ||
                            x.indexLabelFormatter) &&
                            this._indexLabels.push({
                              chartType: "stepArea",
                              dataPoint: m[y],
                              dataSeries: x,
                              point: { x: g, y: b },
                              direction:
                                m[y].y < 0 === t.axisY.reversed ? 1 : -1,
                              color: w,
                            }));
                    }
                  a(), I.drawMarkers(d);
                }
              }
              return (
                Z &&
                  (s.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (n.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    n.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    n.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  n.clearRect(c.x1, c.y1, c.width, c.height),
                  this._eventManager.ghostCtx.restore()),
                n.restore(),
                {
                  source: s,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderStackedArea = function (t) {
            function e() {
              if (!(x.length < 1)) {
                for (0 < k.lineThickness && a.stroke(); 0 < x.length; ) {
                  var t = x.pop();
                  a.lineTo(t.x, t.y), Z && f.lineTo(t.x, t.y);
                }
                a.closePath(),
                  (a.globalAlpha = k.fillOpacity),
                  a.fill(),
                  (a.globalAlpha = 1),
                  a.beginPath(),
                  Z && (f.closePath(), f.fill(), f.beginPath()),
                  (x = []);
              }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
              a = Z ? this._preRenderCtx : i;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var s,
                n,
                o,
                r,
                l,
                h,
                d = null,
                c = [],
                p = this.plotArea,
                u = [],
                x = [],
                m = [],
                g = [],
                b = 0,
                v = t.axisY.convertValueToPixel(
                  t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                ),
                f = this._eventManager.ghostCtx;
              Z && f.beginPath(),
                a.save(),
                Z && f.save(),
                a.beginPath(),
                a.rect(p.x1, p.y1, p.width, p.height),
                a.clip(),
                Z &&
                  (f.beginPath(),
                  f.rect(p.x1, p.y1, p.width, p.height),
                  f.clip());
              d = [];
              for (var y = 0; y < t.dataSeriesIndexes.length; y++) {
                var M = t.dataSeriesIndexes[y],
                  k = this.data[M],
                  w = k.dataPoints;
                for (k.dataPointIndexes = [], b = 0; b < w.length; b++)
                  (M = w[b].x.getTime ? w[b].x.getTime() : w[b].x),
                    (k.dataPointIndexes[M] = b),
                    d[M] || (m.push(M), (d[M] = !0));
                m.sort(E);
              }
              for (y = 0; y < t.dataSeriesIndexes.length; y++) {
                if (
                  ((M = t.dataSeriesIndexes[y]),
                  (w = (k = this.data[M]).dataPoints),
                  (l = !0),
                  (x = []),
                  (b = k.id),
                  (this._eventManager.objectMap[b] = {
                    objectType: "dataSeries",
                    dataSeriesIndex: M,
                  }),
                  (b = N(b)),
                  (f.fillStyle = b),
                  0 < m.length)
                ) {
                  d = k._colorSet[0];
                  var T = (k.lineColor = k.options.lineColor || d),
                    C = T;
                  if (
                    ((a.fillStyle = d),
                    (a.strokeStyle = T),
                    (a.lineWidth = k.lineThickness),
                    (h = "solid"),
                    a.setLineDash)
                  ) {
                    var P = K(k.nullDataLineDashType, k.lineThickness),
                      S = K((h = k.lineDashType), k.lineThickness);
                    a.setLineDash(S);
                  }
                  var A = !0;
                  for (b = 0; b < m.length; b++) {
                    o = m[b];
                    var _ =
                      0 <= k.dataPointIndexes[o]
                        ? w[k.dataPointIndexes[o]]
                        : { x: o, y: null };
                    if (
                      !(
                        o < t.axisX.dataInfo.viewPortMin ||
                        (o > t.axisX.dataInfo.viewPortMax &&
                          (!k.connectNullData || !A))
                      )
                    )
                      if ("number" != typeof _.y)
                        k.connectNullData || A || l || e(), (A = !0);
                      else {
                        s = t.axisX.convertValueToPixel(o);
                        var B = u[o] ? u[o] : 0;
                        if (
                          t.axisY.logarithmic ||
                          (t.axisY.scaleBreaks &&
                            0 < t.axisY.scaleBreaks._appliedBreaks.length)
                        ) {
                          if (
                            ((g[o] = _.y + (g[o] ? g[o] : 0)),
                            g[o] <= 0 && t.axisY.logarithmic)
                          )
                            continue;
                          n = t.axisY.convertValueToPixel(g[o]);
                        } else (n = t.axisY.convertValueToPixel(_.y)), (n -= B);
                        if (
                          (x.push({ x: s, y: v - B }),
                          (u[o] = v - n),
                          l || A
                            ? (!l && k.connectNullData
                                ? (a.setLineDash &&
                                    (k.options.nullDataLineDashType ||
                                      (h === k.lineDashType &&
                                        k.lineDashType !==
                                          k.nullDataLineDashType)) &&
                                    ((l = x.pop()),
                                    (h = x[x.length - 1]),
                                    e(),
                                    a.moveTo(r.x, r.y),
                                    x.push(h),
                                    x.push(l),
                                    (h = k.nullDataLineDashType),
                                    a.setLineDash(P)),
                                  a.lineTo(s, n),
                                  Z && f.lineTo(s, n))
                                : (a.beginPath(),
                                  a.moveTo(s, n),
                                  Z && (f.beginPath(), f.moveTo(s, n))),
                              (A = l = !1))
                            : (a.lineTo(s, n),
                              Z && f.lineTo(s, n),
                              0 == b % 250 &&
                                (e(),
                                a.moveTo(s, n),
                                Z && f.moveTo(s, n),
                                x.push({ x: s, y: v - B }))),
                          (r = { x: s, y: n }),
                          b < w.length - 1 &&
                            (C !== (w[b].lineColor || T) ||
                              h !== (w[b].lineDashType || k.lineDashType)) &&
                            (e(),
                            a.beginPath(),
                            a.moveTo(s, n),
                            x.push({ x: s, y: v - B }),
                            (C = w[b].lineColor || T),
                            (a.strokeStyle = C),
                            a.setLineDash &&
                              (w[b].lineDashType
                                ? ((h = w[b].lineDashType),
                                  a.setLineDash(K(h, k.lineThickness)))
                                : ((h = k.lineDashType), a.setLineDash(S)))),
                          0 <= k.dataPointIndexes[o])
                        ) {
                          var F = k.dataPointIds[k.dataPointIndexes[o]];
                          this._eventManager.objectMap[F] = {
                            id: F,
                            objectType: "dataPoint",
                            dataSeriesIndex: M,
                            dataPointIndex: k.dataPointIndexes[o],
                            x1: s,
                            y1: n,
                          };
                        }
                        0 <= k.dataPointIndexes[o] &&
                          0 !== _.markerSize &&
                          (0 < _.markerSize || 0 < k.markerSize) &&
                          ((o = k.getMarkerProperties(
                            k.dataPointIndexes[o],
                            s,
                            n,
                            a
                          )),
                          c.push(o),
                          (markerColor = N(F)),
                          Z &&
                            c.push({
                              x: s,
                              y: n,
                              ctx: f,
                              type: o.type,
                              size: o.size,
                              color: markerColor,
                              borderColor: markerColor,
                              borderThickness: o.borderThickness,
                            })),
                          (_.indexLabel ||
                            k.indexLabel ||
                            _.indexLabelFormatter ||
                            k.indexLabelFormatter) &&
                            this._indexLabels.push({
                              chartType: "stackedArea",
                              dataPoint: _,
                              dataSeries: k,
                              point: { x: s, y: n },
                              direction:
                                w[b].y < 0 === t.axisY.reversed ? 1 : -1,
                              color: d,
                            });
                      }
                  }
                  e(), a.moveTo(s, n), Z && f.moveTo(s, n);
                }
                delete k.dataPointIndexes;
              }
              return (
                I.drawMarkers(c),
                Z &&
                  (i.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (a.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    a.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    a.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  a.clearRect(p.x1, p.y1, p.width, p.height),
                  f.restore()),
                a.restore(),
                {
                  source: i,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderStackedArea100 = function (t) {
            function e() {
              for (0 < k.lineThickness && a.stroke(); 0 < x.length; ) {
                var t = x.pop();
                a.lineTo(t.x, t.y), Z && f.lineTo(t.x, t.y);
              }
              a.closePath(),
                (a.globalAlpha = k.fillOpacity),
                a.fill(),
                (a.globalAlpha = 1),
                a.beginPath(),
                Z && (f.closePath(), f.fill(), f.beginPath()),
                (x = []);
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
              a = Z ? this._preRenderCtx : i;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var s,
                n,
                o,
                r,
                l,
                h,
                d = null,
                c = this.plotArea,
                p = [],
                u = [],
                x = [],
                m = [],
                g = [],
                b = 0,
                v = t.axisY.convertValueToPixel(
                  t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                ),
                f = this._eventManager.ghostCtx;
              a.save(),
                Z && f.save(),
                a.beginPath(),
                a.rect(c.x1, c.y1, c.width, c.height),
                a.clip(),
                Z &&
                  (f.beginPath(),
                  f.rect(c.x1, c.y1, c.width, c.height),
                  f.clip());
              d = [];
              for (var y = 0; y < t.dataSeriesIndexes.length; y++) {
                var M = t.dataSeriesIndexes[y],
                  k = this.data[M],
                  w = k.dataPoints;
                for (k.dataPointIndexes = [], b = 0; b < w.length; b++)
                  (M = w[b].x.getTime ? w[b].x.getTime() : w[b].x),
                    (k.dataPointIndexes[M] = b),
                    d[M] || (m.push(M), (d[M] = !0));
                m.sort(E);
              }
              for (y = 0; y < t.dataSeriesIndexes.length; y++) {
                if (
                  ((M = t.dataSeriesIndexes[y]),
                  (w = (k = this.data[M]).dataPoints),
                  (l = !0),
                  (d = k.id),
                  (this._eventManager.objectMap[d] = {
                    objectType: "dataSeries",
                    dataSeriesIndex: M,
                  }),
                  (d = N(d)),
                  (f.fillStyle = d),
                  (x = []),
                  0 < m.length)
                ) {
                  d = k._colorSet[b % k._colorSet.length];
                  var T = (k.lineColor = k.options.lineColor || d),
                    C = T;
                  if (
                    ((a.fillStyle = d),
                    (a.strokeStyle = T),
                    (a.lineWidth = k.lineThickness),
                    (h = "solid"),
                    a.setLineDash)
                  ) {
                    var P = K(k.nullDataLineDashType, k.lineThickness),
                      S = K((h = k.lineDashType), k.lineThickness);
                    a.setLineDash(S);
                  }
                  var A = !0;
                  for (b = 0; b < m.length; b++) {
                    o = m[b];
                    var _ =
                      0 <= k.dataPointIndexes[o]
                        ? w[k.dataPointIndexes[o]]
                        : { x: o, y: null };
                    if (
                      !(
                        o < t.axisX.dataInfo.viewPortMin ||
                        (o > t.axisX.dataInfo.viewPortMax &&
                          (!k.connectNullData || !A))
                      )
                    )
                      if ("number" != typeof _.y)
                        k.connectNullData || A || l || e(), (A = !0);
                      else {
                        var B;
                        (B =
                          0 !== t.dataPointYSums[o]
                            ? (_.y / t.dataPointYSums[o]) * 100
                            : 0),
                          (s = t.axisX.convertValueToPixel(o));
                        var F = u[o] ? u[o] : 0;
                        if (
                          t.axisY.logarithmic ||
                          (t.axisY.scaleBreaks &&
                            0 < t.axisY.scaleBreaks._appliedBreaks.length)
                        ) {
                          if (
                            ((g[o] = B + (g[o] ? g[o] : 0)),
                            g[o] <= 0 && t.axisY.logarithmic)
                          )
                            continue;
                          n = t.axisY.convertValueToPixel(g[o]);
                        } else (n = t.axisY.convertValueToPixel(B)), (n -= F);
                        if (
                          (x.push({ x: s, y: v - F }),
                          (u[o] = v - n),
                          l || A
                            ? (!l && k.connectNullData
                                ? (a.setLineDash &&
                                    (k.options.nullDataLineDashType ||
                                      (h === k.lineDashType &&
                                        k.lineDashType !==
                                          k.nullDataLineDashType)) &&
                                    ((l = x.pop()),
                                    (h = x[x.length - 1]),
                                    e(),
                                    a.moveTo(r.x, r.y),
                                    x.push(h),
                                    x.push(l),
                                    (h = k.nullDataLineDashType),
                                    a.setLineDash(P)),
                                  a.lineTo(s, n),
                                  Z && f.lineTo(s, n))
                                : (a.beginPath(),
                                  a.moveTo(s, n),
                                  Z && (f.beginPath(), f.moveTo(s, n))),
                              (A = l = !1))
                            : (a.lineTo(s, n),
                              Z && f.lineTo(s, n),
                              0 == b % 250 &&
                                (e(),
                                a.moveTo(s, n),
                                Z && f.moveTo(s, n),
                                x.push({ x: s, y: v - F }))),
                          (r = { x: s, y: n }),
                          b < w.length - 1 &&
                            (C !== (w[b].lineColor || T) ||
                              h !== (w[b].lineDashType || k.lineDashType)) &&
                            (e(),
                            a.beginPath(),
                            a.moveTo(s, n),
                            x.push({ x: s, y: v - F }),
                            (C = w[b].lineColor || T),
                            (a.strokeStyle = C),
                            a.setLineDash &&
                              (w[b].lineDashType
                                ? ((h = w[b].lineDashType),
                                  a.setLineDash(K(h, k.lineThickness)))
                                : ((h = k.lineDashType), a.setLineDash(S)))),
                          0 <= k.dataPointIndexes[o])
                        ) {
                          var L = k.dataPointIds[k.dataPointIndexes[o]];
                          this._eventManager.objectMap[L] = {
                            id: L,
                            objectType: "dataPoint",
                            dataSeriesIndex: M,
                            dataPointIndex: k.dataPointIndexes[o],
                            x1: s,
                            y1: n,
                          };
                        }
                        0 <= k.dataPointIndexes[o] &&
                          0 !== _.markerSize &&
                          (0 < _.markerSize || 0 < k.markerSize) &&
                          ((o = k.getMarkerProperties(b, s, n, a)),
                          p.push(o),
                          (markerColor = N(L)),
                          Z &&
                            p.push({
                              x: s,
                              y: n,
                              ctx: f,
                              type: o.type,
                              size: o.size,
                              color: markerColor,
                              borderColor: markerColor,
                              borderThickness: o.borderThickness,
                            })),
                          (_.indexLabel ||
                            k.indexLabel ||
                            _.indexLabelFormatter ||
                            k.indexLabelFormatter) &&
                            this._indexLabels.push({
                              chartType: "stackedArea100",
                              dataPoint: _,
                              dataSeries: k,
                              point: { x: s, y: n },
                              direction:
                                w[b].y < 0 === t.axisY.reversed ? 1 : -1,
                              color: d,
                            });
                      }
                  }
                  e(), a.moveTo(s, n), Z && f.moveTo(s, n);
                }
                delete k.dataPointIndexes;
              }
              return (
                I.drawMarkers(p),
                Z &&
                  (i.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (a.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    a.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    a.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  a.clearRect(c.x1, c.y1, c.width, c.height),
                  f.restore()),
                a.restore(),
                {
                  source: i,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderBubble = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n = this.plotArea,
                o = 0;
              i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(n.x1, n.y1, n.width, n.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    n.x1,
                    n.y1,
                    n.width,
                    n.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (
                var r = -1 / 0, l = 1 / 0, h = 0;
                h < t.dataSeriesIndexes.length;
                h++
              ) {
                var d = t.dataSeriesIndexes[h],
                  c = this.data[d],
                  p = c.dataPoints,
                  u = 0;
                for (o = 0; o < p.length; o++)
                  (a = a = p[o].getTime ? p[o].x.getTime() : p[o].x) <
                    t.axisX.dataInfo.viewPortMin ||
                    a > t.axisX.dataInfo.viewPortMax ||
                    void 0 === p[o].z ||
                    (r < (u = p[o].z) && (r = u), u < l && (l = u));
              }
              var x = 25 * Math.PI,
                m = Math.max(
                  Math.pow((0.25 * Math.min(n.height, n.width)) / 2, 2) *
                    Math.PI,
                  x
                );
              for (h = 0; h < t.dataSeriesIndexes.length; h++)
                if (
                  ((d = t.dataSeriesIndexes[h]),
                  0 < (p = (c = this.data[d]).dataPoints).length)
                )
                  for (i.strokeStyle = "#4572A7 ", o = 0; o < p.length; o++)
                    if (
                      !(
                        (a = a = p[o].getTime ? p[o].x.getTime() : p[o].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        a > t.axisX.dataInfo.viewPortMax
                      ) &&
                      "number" == typeof p[o].y
                    ) {
                      (a = t.axisX.convertValueToPixel(a)),
                        (s = t.axisY.convertValueToPixel(p[o].y));
                      u = p[o].z;
                      var g =
                        2 *
                        Math.max(
                          Math.sqrt(
                            (r === l
                              ? m / 2
                              : x + ((m - x) / (r - l)) * (u - l)) / Math.PI
                          ) << 0,
                          1
                        );
                      ((u = c.getMarkerProperties(o, i)).size = g),
                        (i.globalAlpha = c.fillOpacity),
                        I.drawMarker(
                          a,
                          s,
                          i,
                          u.type,
                          u.size,
                          u.color,
                          u.borderColor,
                          u.borderThickness
                        ),
                        (i.globalAlpha = 1);
                      var b = c.dataPointIds[o];
                      (this._eventManager.objectMap[b] = {
                        id: b,
                        objectType: "dataPoint",
                        dataSeriesIndex: d,
                        dataPointIndex: o,
                        x1: a,
                        y1: s,
                        size: g,
                      }),
                        (g = N(b)),
                        Z &&
                          I.drawMarker(
                            a,
                            s,
                            this._eventManager.ghostCtx,
                            u.type,
                            u.size,
                            g,
                            g,
                            u.borderThickness
                          ),
                        (p[o].indexLabel ||
                          c.indexLabel ||
                          p[o].indexLabelFormatter ||
                          c.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "bubble",
                            dataPoint: p[o],
                            dataSeries: c,
                            point: { x: a, y: s },
                            direction: 1,
                            bounds: {
                              x1: a - u.size / 2,
                              y1: s - u.size / 2,
                              x2: a + u.size / 2,
                              y2: s + u.size / 2,
                            },
                            color: null,
                          });
                    }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(n.x1, n.y1, n.width, n.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderScatter = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n = this.plotArea,
                o = 0;
              i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(n.x1, n.y1, n.width, n.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    n.x1,
                    n.y1,
                    n.width,
                    n.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var r = 0; r < t.dataSeriesIndexes.length; r++) {
                var l = t.dataSeriesIndexes[r],
                  h = this.data[l],
                  d = h.dataPoints;
                if (0 < d.length) {
                  (i.strokeStyle = "#4572A7 "),
                    Math.pow((0.3 * Math.min(n.height, n.width)) / 2, 2);
                  var c = 0,
                    p = 0;
                  for (o = 0; o < d.length; o++)
                    if (
                      !(
                        (a = a = d[o].getTime ? d[o].x.getTime() : d[o].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        a > t.axisX.dataInfo.viewPortMax
                      ) &&
                      "number" == typeof d[o].y
                    ) {
                      (a = t.axisX.convertValueToPixel(a)),
                        (s = t.axisY.convertValueToPixel(d[o].y));
                      var u = h.getMarkerProperties(o, a, s, i);
                      (i.globalAlpha = h.fillOpacity),
                        I.drawMarker(
                          u.x,
                          u.y,
                          u.ctx,
                          u.type,
                          u.size,
                          u.color,
                          u.borderColor,
                          u.borderThickness
                        ),
                        (i.globalAlpha = 1),
                        (Math.sqrt((c - a) * (c - a) + (p - s) * (p - s)) <
                          Math.min(u.size, 5) &&
                          d.length >
                            Math.min(
                              this.plotArea.width,
                              this.plotArea.height
                            )) ||
                          ((c = h.dataPointIds[o]),
                          (this._eventManager.objectMap[c] = {
                            id: c,
                            objectType: "dataPoint",
                            dataSeriesIndex: l,
                            dataPointIndex: o,
                            x1: a,
                            y1: s,
                          }),
                          (c = N(c)),
                          Z &&
                            I.drawMarker(
                              u.x,
                              u.y,
                              this._eventManager.ghostCtx,
                              u.type,
                              u.size,
                              c,
                              c,
                              u.borderThickness
                            ),
                          (d[o].indexLabel ||
                            h.indexLabel ||
                            d[o].indexLabelFormatter ||
                            h.indexLabelFormatter) &&
                            this._indexLabels.push({
                              chartType: "scatter",
                              dataPoint: d[o],
                              dataSeries: h,
                              point: { x: a, y: s },
                              direction: 1,
                              bounds: {
                                x1: a - u.size / 2,
                                y1: s - u.size / 2,
                                x2: a + u.size / 2,
                                y2: s + u.size / 2,
                              },
                              color: null,
                            }),
                          (c = a),
                          (p = s));
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(n.x1, n.y1, n.width, n.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderCandlestick = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e,
              a = this._eventManager.ghostCtx;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var s,
                n,
                o,
                r,
                l,
                h,
                d = null,
                c = null,
                p = this.plotArea,
                u = 0,
                x =
                  ((d = this.options.dataPointMinWidth
                    ? this.dataPointMinWidth
                    : this.options.dataPointWidth
                    ? this.dataPointWidth
                    : 1),
                  (c = this.options.dataPointMaxWidth
                    ? this.dataPointMaxWidth
                    : this.options.dataPointWidth
                    ? this.dataPointWidth
                    : 0.015 * this.width),
                  t.axisX.dataInfo.minDiff);
              isFinite(x) || (x = 0.3 * Math.abs(t.axisX.range)),
                (x = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (0.7 *
                      p.width *
                      (t.axisX.logarithmic
                        ? Math.log(x) / Math.log(t.axisX.range)
                        : Math.abs(x) / Math.abs(t.axisX.range))) <<
                    0),
                this.dataPointMaxWidth &&
                  c < d &&
                  (d = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    c
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  c < d &&
                  (c = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    d
                  )),
                x < d && (x = d),
                c < x && (x = c),
                i.save(),
                Z && a.save(),
                i.beginPath(),
                i.rect(p.x1, p.y1, p.width, p.height),
                i.clip(),
                Z &&
                  (a.beginPath(),
                  a.rect(p.x1, p.y1, p.width, p.height),
                  a.clip());
              for (var m = 0; m < t.dataSeriesIndexes.length; m++) {
                var g = t.dataSeriesIndexes[m],
                  b = this.data[g],
                  v = b.dataPoints;
                if (0 < v.length) {
                  var f = !!(5 < x && b.bevelEnabled);
                  for (u = 0; u < v.length; u++)
                    if (
                      !(
                        (h = v[u].getTime ? v[u].x.getTime() : v[u].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        h > t.axisX.dataInfo.viewPortMax
                      ) &&
                      !U(v[u].y) &&
                      v[u].y.length &&
                      "number" == typeof v[u].y[0] &&
                      "number" == typeof v[u].y[1] &&
                      "number" == typeof v[u].y[2] &&
                      "number" == typeof v[u].y[3]
                    ) {
                      (s = t.axisX.convertValueToPixel(h)),
                        (n = t.axisY.convertValueToPixel(v[u].y[0])),
                        (o = t.axisY.convertValueToPixel(v[u].y[1])),
                        (r = t.axisY.convertValueToPixel(v[u].y[2])),
                        (l = t.axisY.convertValueToPixel(v[u].y[3]));
                      var y = (s - x / 2) << 0,
                        M = (y + x) << 0,
                        k =
                          ((c = b.options.fallingColor
                            ? b.fallingColor
                            : b._colorSet[0]),
                          (d = v[u].color ? v[u].color : b._colorSet[0]),
                          Math.round(Math.max(1, 0.15 * x))),
                        w = 0 == k % 2 ? 0 : 0.5,
                        T = b.dataPointIds[u];
                      (this._eventManager.objectMap[T] = {
                        id: T,
                        objectType: "dataPoint",
                        dataSeriesIndex: g,
                        dataPointIndex: u,
                        x1: y,
                        y1: n,
                        x2: M,
                        y2: o,
                        x3: s,
                        y3: r,
                        x4: s,
                        y4: l,
                        borderThickness: k,
                        color: d,
                      }),
                        (i.strokeStyle = d),
                        i.beginPath(),
                        (i.lineWidth = k),
                        (a.lineWidth = Math.max(k, 4)),
                        "candlestick" === b.type
                          ? (i.moveTo(s - w, o),
                            i.lineTo(s - w, Math.min(n, l)),
                            i.stroke(),
                            i.moveTo(s - w, Math.max(n, l)),
                            i.lineTo(s - w, r),
                            i.stroke(),
                            R(
                              i,
                              y,
                              Math.min(n, l),
                              M,
                              Math.max(n, l),
                              v[u].y[0] <= v[u].y[3] ? b.risingColor : c,
                              k,
                              d,
                              f,
                              f,
                              !1,
                              !1,
                              b.fillOpacity
                            ),
                            Z &&
                              ((d = N(T)),
                              (a.strokeStyle = d),
                              a.moveTo(s - w, o),
                              a.lineTo(s - w, Math.min(n, l)),
                              a.stroke(),
                              a.moveTo(s - w, Math.max(n, l)),
                              a.lineTo(s - w, r),
                              a.stroke(),
                              R(
                                a,
                                y,
                                Math.min(n, l),
                                M,
                                Math.max(n, l),
                                d,
                                0,
                                null,
                                !1,
                                !1,
                                !1,
                                !1
                              )))
                          : "ohlc" === b.type &&
                            (i.moveTo(s - w, o),
                            i.lineTo(s - w, r),
                            i.stroke(),
                            i.beginPath(),
                            i.moveTo(s, n),
                            i.lineTo(y, n),
                            i.stroke(),
                            i.beginPath(),
                            i.moveTo(s, l),
                            i.lineTo(M, l),
                            i.stroke(),
                            Z &&
                              ((d = N(T)),
                              (a.strokeStyle = d),
                              a.moveTo(s - w, o),
                              a.lineTo(s - w, r),
                              a.stroke(),
                              a.beginPath(),
                              a.moveTo(s, n),
                              a.lineTo(y, n),
                              a.stroke(),
                              a.beginPath(),
                              a.moveTo(s, l),
                              a.lineTo(M, l),
                              a.stroke())),
                        (v[u].indexLabel ||
                          b.indexLabel ||
                          v[u].indexLabelFormatter ||
                          b.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: b.type,
                            dataPoint: v[u],
                            dataSeries: b,
                            point: {
                              x: y + (M - y) / 2,
                              y: t.axisY.reversed ? r : o,
                            },
                            direction: 1,
                            bounds: {
                              x1: y,
                              y1: Math.min(o, r),
                              x2: M,
                              y2: Math.max(o, r),
                            },
                            color: d,
                          });
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(p.x1, p.y1, p.width, p.height),
                  a.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderBoxAndWhisker = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e,
              a = this._eventManager.ghostCtx;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var s,
                n,
                o,
                r,
                l,
                h,
                d,
                c = null,
                p = this.plotArea,
                u = 0,
                x =
                  ((c = this.options.dataPointMinWidth
                    ? this.dataPointMinWidth
                    : this.options.dataPointWidth
                    ? this.dataPointWidth
                    : 1),
                  (u = this.options.dataPointMaxWidth
                    ? this.dataPointMaxWidth
                    : this.options.dataPointWidth
                    ? this.dataPointWidth
                    : 0.015 * this.width),
                  t.axisX.dataInfo.minDiff);
              isFinite(x) || (x = 0.3 * Math.abs(t.axisX.range)),
                (x = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (0.7 *
                      p.width *
                      (t.axisX.logarithmic
                        ? Math.log(x) / Math.log(t.axisX.range)
                        : Math.abs(x) / Math.abs(t.axisX.range))) <<
                    0),
                this.dataPointMaxWidth &&
                  u < c &&
                  (c = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    u
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  u < c &&
                  (u = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    c
                  )),
                x < c && (x = c),
                u < x && (x = u),
                i.save(),
                Z && a.save(),
                i.beginPath(),
                i.rect(p.x1, p.y1, p.width, p.height),
                i.clip(),
                Z &&
                  (a.beginPath(),
                  a.rect(p.x1, p.y1, p.width, p.height),
                  a.clip());
              for (
                var m = !!t.axisY.reversed, g = 0;
                g < t.dataSeriesIndexes.length;
                g++
              ) {
                var b = t.dataSeriesIndexes[g],
                  v = this.data[b],
                  f = v.dataPoints;
                if (0 < f.length) {
                  var y = !!(5 < x && v.bevelEnabled);
                  for (u = 0; u < f.length; u++)
                    if (
                      !(
                        (d = f[u].getTime ? f[u].x.getTime() : f[u].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        d > t.axisX.dataInfo.viewPortMax
                      ) &&
                      !U(f[u].y) &&
                      f[u].y.length &&
                      "number" == typeof f[u].y[0] &&
                      "number" == typeof f[u].y[1] &&
                      "number" == typeof f[u].y[2] &&
                      "number" == typeof f[u].y[3] &&
                      "number" == typeof f[u].y[4] &&
                      5 === f[u].y.length
                    ) {
                      (s = t.axisX.convertValueToPixel(d)),
                        (n = t.axisY.convertValueToPixel(f[u].y[0])),
                        (o = t.axisY.convertValueToPixel(f[u].y[1])),
                        (r = t.axisY.convertValueToPixel(f[u].y[2])),
                        (l = t.axisY.convertValueToPixel(f[u].y[3])),
                        (h = t.axisY.convertValueToPixel(f[u].y[4]));
                      var M = (s - x / 2) << 0,
                        k = (s + x / 2) << 0,
                        w =
                          ((c = f[u].color ? f[u].color : v._colorSet[0]),
                          Math.round(Math.max(1, 0.15 * x))),
                        T = 0 == w % 2 ? 0 : 0.5,
                        C = f[u].whiskerColor
                          ? f[u].whiskerColor
                          : f[u].color
                          ? v.whiskerColor
                            ? v.whiskerColor
                            : f[u].color
                          : v.whiskerColor
                          ? v.whiskerColor
                          : c,
                        P =
                          "number" == typeof f[u].whiskerThickness
                            ? f[u].whiskerThickness
                            : "number" == typeof v.options.whiskerThickness
                            ? v.whiskerThickness
                            : w,
                        S = f[u].whiskerDashType
                          ? f[u].whiskerDashType
                          : v.whiskerDashType,
                        A =
                          "number" ==
                          typeof (A = U(f[u].whiskerLength)
                            ? U(v.options.whiskerLength)
                              ? x
                              : v.whiskerLength
                            : f[u].whiskerLength)
                            ? A <= 0
                              ? 0
                              : x <= A
                              ? x
                              : A
                            : "string" == typeof A
                            ? (parseInt(A) * x) / 100 > x
                              ? x
                              : (parseInt(A) * x) / 100
                            : x,
                        _ = 1 == Math.round(P) % 2 ? 0.5 : 0,
                        B = f[u].stemColor
                          ? f[u].stemColor
                          : f[u].color
                          ? v.stemColor
                            ? v.stemColor
                            : f[u].color
                          : v.stemColor
                          ? v.stemColor
                          : c,
                        F =
                          "number" == typeof f[u].stemThickness
                            ? f[u].stemThickness
                            : "number" == typeof v.options.stemThickness
                            ? v.stemThickness
                            : w,
                        L = 1 == Math.round(F) % 2 ? 0.5 : 0,
                        I = f[u].stemDashType
                          ? f[u].stemDashType
                          : v.stemDashType,
                        E = f[u].lineColor
                          ? f[u].lineColor
                          : f[u].color
                          ? v.lineColor
                            ? v.lineColor
                            : f[u].color
                          : v.lineColor
                          ? v.lineColor
                          : c,
                        D =
                          "number" == typeof f[u].lineThickness
                            ? f[u].lineThickness
                            : "number" == typeof v.options.lineThickness
                            ? v.lineThickness
                            : w,
                        V = f[u].lineDashType
                          ? f[u].lineDashType
                          : v.lineDashType,
                        z = 1 == Math.round(D) % 2 ? 0.5 : 0,
                        W = v.upperBoxColor,
                        X = v.lowerBoxColor,
                        Y = U(v.options.fillOpacity) ? 1 : v.fillOpacity,
                        O = v.dataPointIds[u];
                      (this._eventManager.objectMap[O] = {
                        id: O,
                        objectType: "dataPoint",
                        dataSeriesIndex: b,
                        dataPointIndex: u,
                        x1: M,
                        y1: n,
                        x2: k,
                        y2: o,
                        x3: s,
                        y3: r,
                        x4: s,
                        y4: l,
                        y5: h,
                        borderThickness: w,
                        color: c,
                        stemThickness: F,
                        stemColor: B,
                        whiskerThickness: P,
                        whiskerLength: A,
                        whiskerColor: C,
                        lineThickness: D,
                        lineColor: E,
                      }),
                        i.save(),
                        0 < F &&
                          (i.beginPath(),
                          (i.strokeStyle = B),
                          (i.lineWidth = F),
                          i.setLineDash && i.setLineDash(K(I, F)),
                          i.moveTo(s - L, o),
                          i.lineTo(s - L, n),
                          i.stroke(),
                          i.moveTo(s - L, l),
                          i.lineTo(s - L, r),
                          i.stroke()),
                        i.restore(),
                        (a.lineWidth = Math.max(w, 4)),
                        i.beginPath(),
                        R(
                          i,
                          M,
                          Math.min(h, o),
                          k,
                          Math.max(o, h),
                          X,
                          0,
                          c,
                          !!m && y,
                          !m && y,
                          !1,
                          !1,
                          Y
                        ),
                        i.beginPath(),
                        R(
                          i,
                          M,
                          Math.min(r, h),
                          k,
                          Math.max(h, r),
                          W,
                          0,
                          c,
                          !m && y,
                          !!m && y,
                          !1,
                          !1,
                          Y
                        ),
                        i.beginPath(),
                        (i.lineWidth = w),
                        (i.strokeStyle = c),
                        i.rect(
                          M - T,
                          Math.min(o, r) - T,
                          k - M + 2 * T,
                          Math.max(o, r) - Math.min(o, r) + 2 * T
                        ),
                        i.stroke(),
                        i.save(),
                        0 < D &&
                          (i.beginPath(),
                          (i.globalAlpha = 1),
                          i.setLineDash && i.setLineDash(K(V, D)),
                          (i.strokeStyle = E),
                          (i.lineWidth = D),
                          i.moveTo(M, h - z),
                          i.lineTo(k, h - z),
                          i.stroke()),
                        i.restore(),
                        i.save(),
                        0 < P &&
                          (i.beginPath(),
                          i.setLineDash && i.setLineDash(K(S, P)),
                          (i.strokeStyle = C),
                          (i.lineWidth = P),
                          i.moveTo((s - A / 2) << 0, l - _),
                          i.lineTo((s + A / 2) << 0, l - _),
                          i.stroke(),
                          i.moveTo((s - A / 2) << 0, n + _),
                          i.lineTo((s + A / 2) << 0, n + _),
                          i.stroke()),
                        i.restore(),
                        Z &&
                          ((c = N(O)),
                          (a.strokeStyle = c),
                          0 < (a.lineWidth = F) &&
                            (a.moveTo(s - T - L, o),
                            a.lineTo(s - T - L, Math.max(n, l)),
                            a.stroke(),
                            a.moveTo(s - T - L, Math.min(n, l)),
                            a.lineTo(s - T - L, r),
                            a.stroke()),
                          R(
                            a,
                            M,
                            Math.max(o, r),
                            k,
                            Math.min(o, r),
                            c,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          ),
                          0 < P &&
                            (a.beginPath(),
                            (a.lineWidth = P),
                            a.moveTo(s + A / 2, l - _),
                            a.lineTo(s - A / 2, l - _),
                            a.stroke(),
                            a.moveTo(s + A / 2, n + _),
                            a.lineTo(s - A / 2, n + _),
                            a.stroke())),
                        (f[u].indexLabel ||
                          v.indexLabel ||
                          f[u].indexLabelFormatter ||
                          v.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: v.type,
                            dataPoint: f[u],
                            dataSeries: v,
                            point: {
                              x: M + (k - M) / 2,
                              y: t.axisY.reversed ? n : l,
                            },
                            direction: 1,
                            bounds: {
                              x1: M,
                              y1: Math.min(n, l),
                              x2: k,
                              y2: Math.max(n, l),
                            },
                            color: c,
                          });
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(p.x1, p.y1, p.width, p.height),
                  a.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderRangeColumn = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n,
                o = null,
                r = this.plotArea,
                l = 0;
              l = this.options.dataPointMinWidth
                ? this.dataPointMinWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : 1;
              a = this.options.dataPointMaxWidth
                ? this.dataPointMaxWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : 0.03 * this.width;
              var h = t.axisX.dataInfo.minDiff;
              isFinite(h) || (h = 0.3 * Math.abs(t.axisX.range)),
                (h = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (((r.width *
                      (t.axisX.logarithmic
                        ? Math.log(h) / Math.log(t.axisX.range)
                        : Math.abs(h) / Math.abs(t.axisX.range))) /
                      t.plotType.totalDataSeries) *
                      0.9) <<
                    0),
                this.dataPointMaxWidth &&
                  a < l &&
                  (l = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    a
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  a < l &&
                  (a = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    l
                  )),
                h < l && (h = l),
                a < h && (h = a),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(r.x1, r.y1, r.width, r.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    r.x1,
                    r.y1,
                    r.width,
                    r.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var d = 0; d < t.dataSeriesIndexes.length; d++) {
                var c = t.dataSeriesIndexes[d],
                  p = this.data[c],
                  u = p.dataPoints;
                if (0 < u.length) {
                  var x = !!(5 < h && p.bevelEnabled);
                  for (l = 0; l < u.length; l++)
                    if (
                      !(
                        (n = u[l].getTime ? u[l].x.getTime() : u[l].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        n > t.axisX.dataInfo.viewPortMax
                      ) &&
                      !U(u[l].y) &&
                      u[l].y.length &&
                      "number" == typeof u[l].y[0] &&
                      "number" == typeof u[l].y[1]
                    ) {
                      (o = t.axisX.convertValueToPixel(n)),
                        (a = t.axisY.convertValueToPixel(u[l].y[0])),
                        (s = t.axisY.convertValueToPixel(u[l].y[1]));
                      var m = t.axisX.reversed
                          ? (o +
                              (t.plotType.totalDataSeries * h) / 2 -
                              (t.previousDataSeriesCount + d) * h) <<
                            0
                          : (o -
                              (t.plotType.totalDataSeries * h) / 2 +
                              (t.previousDataSeriesCount + d) * h) <<
                            0,
                        g = t.axisX.reversed ? (m - h) << 0 : (m + h) << 0;
                      o = u[l].color
                        ? u[l].color
                        : p._colorSet[l % p._colorSet.length];
                      if (s < a) {
                        var b = a;
                        (a = s), (s = b);
                      }
                      (b = p.dataPointIds[l]),
                        (this._eventManager.objectMap[b] = {
                          id: b,
                          objectType: "dataPoint",
                          dataSeriesIndex: c,
                          dataPointIndex: l,
                          x1: m,
                          y1: a,
                          x2: g,
                          y2: s,
                        }),
                        R(i, m, a, g, s, o, 0, o, x, x, !1, !1, p.fillOpacity),
                        (o = N(b)),
                        Z &&
                          R(
                            this._eventManager.ghostCtx,
                            m,
                            a,
                            g,
                            s,
                            o,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          ),
                        (u[l].indexLabel ||
                          p.indexLabel ||
                          u[l].indexLabelFormatter ||
                          p.indexLabelFormatter) &&
                          (this._indexLabels.push({
                            chartType: "rangeColumn",
                            dataPoint: u[l],
                            dataSeries: p,
                            indexKeyword: 0,
                            point: {
                              x: m + (g - m) / 2,
                              y: u[l].y[1] >= u[l].y[0] ? s : a,
                            },
                            direction: u[l].y[1] >= u[l].y[0] ? -1 : 1,
                            bounds: {
                              x1: m,
                              y1: Math.min(a, s),
                              x2: g,
                              y2: Math.max(a, s),
                            },
                            color: o,
                          }),
                          this._indexLabels.push({
                            chartType: "rangeColumn",
                            dataPoint: u[l],
                            dataSeries: p,
                            indexKeyword: 1,
                            point: {
                              x: m + (g - m) / 2,
                              y: u[l].y[1] >= u[l].y[0] ? a : s,
                            },
                            direction: u[l].y[1] >= u[l].y[0] ? 1 : -1,
                            bounds: {
                              x1: m,
                              y1: Math.min(a, s),
                              x2: g,
                              y2: Math.max(a, s),
                            },
                            color: o,
                          }));
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(r.x1, r.y1, r.width, r.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderError = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e,
              a =
                !!t.axisY._position &&
                "left" !== t.axisY._position &&
                "right" !== t.axisY._position;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var s,
                n,
                o,
                r,
                l,
                h,
                d,
                c = null,
                p = !1,
                u = this.plotArea,
                x = 0,
                m = t.axisX.dataInfo.minDiff;
              isFinite(m) || (m = 0.3 * Math.abs(t.axisX.range)),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(u.x1, u.y1, u.width, u.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    u.x1,
                    u.y1,
                    u.width,
                    u.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var g = 0, b = 0; b < this.data.length; b++)
                !this.data[b].type.match(/(bar|column)/gi) ||
                  !this.data[b].visible ||
                  (this.data[b].type.match(/(stacked)/gi) && g) ||
                  g++;
              for (var v = 0; v < t.dataSeriesIndexes.length; v++) {
                var f = t.dataSeriesIndexes[v],
                  y = this.data[f],
                  M = y.dataPoints,
                  k =
                    !U(y._linkedSeries) &&
                    !(
                      !y._linkedSeries.type.match(/(bar|column)/gi) ||
                      !y._linkedSeries.visible
                    ),
                  w = 0;
                if (k)
                  for (c = y._linkedSeries.id, b = 0; b < c; b++)
                    !this.data[b].type.match(/(bar|column)/gi) ||
                      !this.data[b].visible ||
                      (this.data[b].type.match(/(stacked)/gi) && w) ||
                      (this.data[b].type.match(/(range)/gi) && (p = !0), w++);
                if (
                  ((c = this.options.dataPointMinWidth
                    ? this.dataPointMinWidth
                    : this.options.dataPointWidth
                    ? this.dataPointWidth
                    : 1),
                  (x = this.options.dataPointMaxWidth
                    ? this.dataPointMaxWidth
                    : this.options.dataPointWidth
                    ? this.dataPointWidth
                    : a
                    ? Math.min(
                        0.15 * this.height,
                        (this.plotArea.height / (k ? g : 1)) * 0.9
                      ) << 0
                    : 0.3 * this.width),
                  p &&
                    (x = this.options.dataPointMaxWidth
                      ? this.dataPointMaxWidth
                      : this.options.dataPointWidth
                      ? this.dataPointWidth
                      : a
                      ? Math.min(
                          0.15 * this.height,
                          (this.plotArea.height / (k ? g : 1)) * 0.9
                        ) << 0
                      : 0.03 * this.width),
                  (b = this.options.dataPointWidth
                    ? this.dataPointWidth
                    : ((((a ? u.height : u.width) *
                        (t.axisX.logarithmic
                          ? Math.log(m) / Math.log(t.axisX.range)
                          : Math.abs(m) / Math.abs(t.axisX.range))) /
                        (k ? g : 1)) *
                        0.9) <<
                      0),
                  this.dataPointMaxWidth &&
                    x < c &&
                    (c = Math.min(
                      this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                      x
                    )),
                  !this.dataPointMaxWidth &&
                    this.dataPointMinWidth &&
                    x < c &&
                    (x = Math.max(
                      this.options.dataPointWidth
                        ? this.dataPointWidth
                        : -1 / 0,
                      c
                    )),
                  b < c && (b = c),
                  x < b && (b = x),
                  0 < M.length)
                ) {
                  var T = y._colorSet;
                  for (x = 0; x < M.length; x++) {
                    c = y.lineColor = y.options.color ? y.options.color : T[0];
                    var C = {
                      color: M[x].whiskerColor
                        ? M[x].whiskerColor
                        : M[x].color
                        ? y.whiskerColor
                          ? y.whiskerColor
                          : M[x].color
                        : y.whiskerColor
                        ? y.whiskerColor
                        : c,
                      thickness: U(M[x].whiskerThickness)
                        ? y.whiskerThickness
                        : M[x].whiskerThickness,
                      dashType: M[x].whiskerDashType
                        ? M[x].whiskerDashType
                        : y.whiskerDashType,
                      length: U(M[x].whiskerLength)
                        ? U(y.options.whiskerLength)
                          ? b
                          : y.options.whiskerLength
                        : M[x].whiskerLength,
                      trimLength:
                        U(M[x].whiskerLength) && U(y.options.whiskerLength)
                          ? 50
                          : 0,
                    };
                    (C.length =
                      "number" == typeof C.length
                        ? C.length <= 0
                          ? 0
                          : C.length >= b
                          ? b
                          : C.length
                        : "string" == typeof C.length
                        ? (parseInt(C.length) * b) / 100 > b
                          ? b
                          : (parseInt(C.length) * b) / 100 > b
                        : b),
                      (C.thickness =
                        "number" == typeof C.thickness
                          ? C.thickness < 0
                            ? 0
                            : Math.round(C.thickness)
                          : 2);
                    var P = {
                      color: M[x].stemColor
                        ? M[x].stemColor
                        : M[x].color
                        ? y.stemColor
                          ? y.stemColor
                          : M[x].color
                        : y.stemColor
                        ? y.stemColor
                        : c,
                      thickness: M[x].stemThickness
                        ? M[x].stemThickness
                        : y.stemThickness,
                      dashType: M[x].stemDashType
                        ? M[x].stemDashType
                        : y.stemDashType,
                    };
                    if (
                      ((P.thickness =
                        "number" == typeof P.thickness
                          ? P.thickness < 0
                            ? 0
                            : Math.round(P.thickness)
                          : 2),
                      !(
                        (d = M[x].getTime ? M[x].x.getTime() : M[x].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        d > t.axisX.dataInfo.viewPortMax
                      ) &&
                        !U(M[x].y) &&
                        M[x].y.length &&
                        "number" == typeof M[x].y[0] &&
                        "number" == typeof M[x].y[1])
                    ) {
                      var S = t.axisX.convertValueToPixel(d);
                      a ? (n = S) : (s = S),
                        (S = t.axisY.convertValueToPixel(M[x].y[0])),
                        a ? (o = S) : (l = S),
                        (S = t.axisY.convertValueToPixel(M[x].y[1])),
                        a ? (r = S) : (h = S),
                        a
                          ? ((l = t.axisX.reversed
                              ? (n +
                                  ((k ? g : 1) * b) / 2 -
                                  (k ? w - 1 : 0) * b) <<
                                0
                              : (n -
                                  ((k ? g : 1) * b) / 2 +
                                  (k ? w - 1 : 0) * b) <<
                                0),
                            (h = t.axisX.reversed
                              ? (l - b) << 0
                              : (l + b) << 0))
                          : ((o = t.axisX.reversed
                              ? (s +
                                  ((k ? g : 1) * b) / 2 -
                                  (k ? w - 1 : 0) * b) <<
                                0
                              : (s -
                                  ((k ? g : 1) * b) / 2 +
                                  (k ? w - 1 : 0) * b) <<
                                0),
                            (r = t.axisX.reversed
                              ? (o - b) << 0
                              : (o + b) << 0)),
                        !a && h < l && ((S = l), (l = h), (h = S)),
                        a && r < o && ((S = o), (o = r), (r = S)),
                        (S = y.dataPointIds[x]),
                        (this._eventManager.objectMap[S] = {
                          id: S,
                          objectType: "dataPoint",
                          dataSeriesIndex: f,
                          dataPointIndex: x,
                          x1: Math.min(o, r),
                          y1: Math.min(l, h),
                          x2: Math.max(r, o),
                          y2: Math.max(h, l),
                          isXYSwapped: a,
                          stemProperties: P,
                          whiskerProperties: C,
                        }),
                        _(
                          i,
                          Math.min(o, r),
                          Math.min(l, h),
                          Math.max(r, o),
                          Math.max(h, l),
                          c,
                          C,
                          P,
                          a
                        ),
                        Z &&
                          _(
                            this._eventManager.ghostCtx,
                            o,
                            l,
                            r,
                            h,
                            c,
                            C,
                            P,
                            a
                          ),
                        (M[x].indexLabel ||
                          y.indexLabel ||
                          M[x].indexLabelFormatter ||
                          y.indexLabelFormatter) &&
                          (this._indexLabels.push({
                            chartType: "error",
                            dataPoint: M[x],
                            dataSeries: y,
                            indexKeyword: 0,
                            point: {
                              x: a
                                ? M[x].y[1] >= M[x].y[0]
                                  ? o
                                  : r
                                : o + (r - o) / 2,
                              y: a
                                ? l + (h - l) / 2
                                : M[x].y[1] >= M[x].y[0]
                                ? h
                                : l,
                            },
                            direction: M[x].y[1] >= M[x].y[0] ? -1 : 1,
                            bounds: {
                              x1: a ? Math.min(o, r) : o,
                              y1: a ? l : Math.min(l, h),
                              x2: a ? Math.max(o, r) : r,
                              y2: a ? h : Math.max(l, h),
                            },
                            color: c,
                            axisSwapped: a,
                          }),
                          this._indexLabels.push({
                            chartType: "error",
                            dataPoint: M[x],
                            dataSeries: y,
                            indexKeyword: 1,
                            point: {
                              x: a
                                ? M[x].y[1] >= M[x].y[0]
                                  ? r
                                  : o
                                : o + (r - o) / 2,
                              y: a
                                ? l + (h - l) / 2
                                : M[x].y[1] >= M[x].y[0]
                                ? l
                                : h,
                            },
                            direction: M[x].y[1] >= M[x].y[0] ? 1 : -1,
                            bounds: {
                              x1: a ? Math.min(o, r) : o,
                              y1: a ? l : Math.min(l, h),
                              x2: a ? Math.max(o, r) : r,
                              y2: a ? h : Math.max(l, h),
                            },
                            color: c,
                            axisSwapped: a,
                          }));
                    }
                  }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(u.x1, u.y1, u.width, u.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderRangeBar = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n,
                o,
                r = null,
                l = this.plotArea,
                h = 0;
              h = this.options.dataPointMinWidth
                ? this.dataPointMinWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : 1;
              a = this.options.dataPointMaxWidth
                ? this.dataPointMaxWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : Math.min(
                    0.15 * this.height,
                    (this.plotArea.height / t.plotType.totalDataSeries) * 0.9
                  ) << 0;
              var d = t.axisX.dataInfo.minDiff;
              isFinite(d) || (d = 0.3 * Math.abs(t.axisX.range)),
                (d = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (((l.height *
                      (t.axisX.logarithmic
                        ? Math.log(d) / Math.log(t.axisX.range)
                        : Math.abs(d) / Math.abs(t.axisX.range))) /
                      t.plotType.totalDataSeries) *
                      0.9) <<
                    0),
                this.dataPointMaxWidth &&
                  a < h &&
                  (h = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    a
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  a < h &&
                  (a = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    h
                  )),
                d < h && (d = h),
                a < d && (d = a),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(l.x1, l.y1, l.width, l.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    l.x1,
                    l.y1,
                    l.width,
                    l.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var c = 0; c < t.dataSeriesIndexes.length; c++) {
                var p = t.dataSeriesIndexes[c],
                  u = this.data[p],
                  x = u.dataPoints;
                if (0 < x.length) {
                  var m = !!(5 < d && u.bevelEnabled);
                  for (i.strokeStyle = "#4572A7 ", h = 0; h < x.length; h++)
                    if (
                      !(
                        (o = x[h].getTime ? x[h].x.getTime() : x[h].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        o > t.axisX.dataInfo.viewPortMax
                      ) &&
                      !U(x[h].y) &&
                      x[h].y.length &&
                      "number" == typeof x[h].y[0] &&
                      "number" == typeof x[h].y[1]
                    ) {
                      (a = t.axisY.convertValueToPixel(x[h].y[0])),
                        (s = t.axisY.convertValueToPixel(x[h].y[1])),
                        (n = t.axisX.convertValueToPixel(o)),
                        (n = t.axisX.reversed
                          ? (n +
                              (t.plotType.totalDataSeries * d) / 2 -
                              (t.previousDataSeriesCount + c) * d) <<
                            0
                          : (n -
                              (t.plotType.totalDataSeries * d) / 2 +
                              (t.previousDataSeriesCount + c) * d) <<
                            0);
                      var g = t.axisX.reversed ? (n - d) << 0 : (n + d) << 0;
                      s < a && ((r = a), (a = s), (s = r)),
                        (r = x[h].color
                          ? x[h].color
                          : u._colorSet[h % u._colorSet.length]),
                        R(
                          i,
                          a,
                          n,
                          s,
                          g,
                          r,
                          0,
                          null,
                          m,
                          !1,
                          !1,
                          !1,
                          u.fillOpacity
                        ),
                        (r = u.dataPointIds[h]),
                        (this._eventManager.objectMap[r] = {
                          id: r,
                          objectType: "dataPoint",
                          dataSeriesIndex: p,
                          dataPointIndex: h,
                          x1: a,
                          y1: n,
                          x2: s,
                          y2: g,
                        }),
                        (r = N(r)),
                        Z &&
                          R(
                            this._eventManager.ghostCtx,
                            a,
                            n,
                            s,
                            g,
                            r,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          ),
                        (x[h].indexLabel ||
                          u.indexLabel ||
                          x[h].indexLabelFormatter ||
                          u.indexLabelFormatter) &&
                          (this._indexLabels.push({
                            chartType: "rangeBar",
                            dataPoint: x[h],
                            dataSeries: u,
                            indexKeyword: 0,
                            point: {
                              x: x[h].y[1] >= x[h].y[0] ? a : s,
                              y: n + (g - n) / 2,
                            },
                            direction: x[h].y[1] >= x[h].y[0] ? -1 : 1,
                            bounds: {
                              x1: Math.min(a, s),
                              y1: n,
                              x2: Math.max(a, s),
                              y2: g,
                            },
                            color: r,
                          }),
                          this._indexLabels.push({
                            chartType: "rangeBar",
                            dataPoint: x[h],
                            dataSeries: u,
                            indexKeyword: 1,
                            point: {
                              x: x[h].y[1] >= x[h].y[0] ? s : a,
                              y: n + (g - n) / 2,
                            },
                            direction: x[h].y[1] >= x[h].y[0] ? 1 : -1,
                            bounds: {
                              x1: Math.min(a, s),
                              y1: n,
                              x2: Math.max(a, s),
                              y2: g,
                            },
                            color: r,
                          }));
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(l.x1, l.y1, l.width, l.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderRangeArea = function (t) {
            function e() {
              if (v) {
                var t = null;
                0 < d.lineThickness && a.stroke();
                for (var e = l.length - 1; 0 <= e; e--)
                  (t = l[e]), a.lineTo(t.x, t.y), s.lineTo(t.x, t.y);
                if (
                  (a.closePath(),
                  (a.globalAlpha = d.fillOpacity),
                  a.fill(),
                  (a.globalAlpha = 1),
                  s.fill(),
                  0 < d.lineThickness)
                ) {
                  for (
                    a.beginPath(), a.moveTo(t.x, t.y), e = 0;
                    e < l.length;
                    e++
                  )
                    (t = l[e]), a.lineTo(t.x, t.y);
                  a.stroke();
                }
                a.beginPath(),
                  a.moveTo(p, u),
                  s.beginPath(),
                  s.moveTo(p, u),
                  (v = { x: p, y: u }),
                  (l = []).push({ x: p, y: x });
              }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
              a = Z ? this._preRenderCtx : i;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var s = this._eventManager.ghostCtx,
                n = [],
                o = this.plotArea;
              a.save(),
                Z && s.save(),
                a.beginPath(),
                a.rect(o.x1, o.y1, o.width, o.height),
                a.clip(),
                Z &&
                  (s.beginPath(),
                  s.rect(o.x1, o.y1, o.width, o.height),
                  s.clip());
              for (var r = 0; r < t.dataSeriesIndexes.length; r++) {
                var l = [],
                  h = t.dataSeriesIndexes[r],
                  d = this.data[h],
                  c = d.dataPoints;
                n = d.id;
                (this._eventManager.objectMap[n] = {
                  objectType: "dataSeries",
                  dataSeriesIndex: h,
                }),
                  (n = N(n)),
                  (s.fillStyle = n);
                n = [];
                var p,
                  u,
                  x,
                  m,
                  g = !0,
                  b = 0,
                  v = null;
                if (0 < c.length) {
                  var f = d._colorSet[b % d._colorSet.length],
                    y = (d.lineColor = d.options.lineColor || f),
                    M = y;
                  (a.fillStyle = f),
                    (a.strokeStyle = y),
                    (a.lineWidth = d.lineThickness);
                  var k = "solid";
                  if (a.setLineDash) {
                    var w = K(d.nullDataLineDashType, d.lineThickness),
                      T = K((k = d.lineDashType), d.lineThickness);
                    a.setLineDash(T);
                  }
                  for (var C = !0; b < c.length; b++)
                    if (
                      !(
                        (m = c[b].x.getTime ? c[b].x.getTime() : c[b].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        (m > t.axisX.dataInfo.viewPortMax &&
                          (!d.connectNullData || !C))
                      )
                    )
                      if (
                        null !== c[b].y &&
                        c[b].y.length &&
                        "number" == typeof c[b].y[0] &&
                        "number" == typeof c[b].y[1]
                      ) {
                        if (
                          ((p = t.axisX.convertValueToPixel(m)),
                          (u = t.axisY.convertValueToPixel(c[b].y[0])),
                          (x = t.axisY.convertValueToPixel(c[b].y[1])),
                          g || C
                            ? (d.connectNullData && !g
                                ? (a.setLineDash &&
                                    (d.options.nullDataLineDashType ||
                                      (k === d.lineDashType &&
                                        d.lineDashType !==
                                          d.nullDataLineDashType)) &&
                                    ((l[l.length - 1].newLineDashArray = T),
                                    (k = d.nullDataLineDashType),
                                    a.setLineDash(w)),
                                  a.lineTo(p, u),
                                  Z && s.lineTo(p, u),
                                  l.push({ x: p, y: x }))
                                : (a.beginPath(),
                                  a.moveTo(p, u),
                                  (v = { x: p, y: u }),
                                  (l = []).push({ x: p, y: x }),
                                  Z && (s.beginPath(), s.moveTo(p, u))),
                              (C = g = !1))
                            : (a.lineTo(p, u),
                              l.push({ x: p, y: x }),
                              Z && s.lineTo(p, u),
                              0 == b % 250 && e()),
                          (m = d.dataPointIds[b]),
                          (this._eventManager.objectMap[m] = {
                            id: m,
                            objectType: "dataPoint",
                            dataSeriesIndex: h,
                            dataPointIndex: b,
                            x1: p,
                            y1: u,
                            y2: x,
                          }),
                          b < c.length - 1 &&
                            (M !== (c[b].lineColor || y) ||
                              k !== (c[b].lineDashType || d.lineDashType)) &&
                            (e(),
                            (M = c[b].lineColor || y),
                            (l[l.length - 1].newStrokeStyle = M),
                            (a.strokeStyle = M),
                            a.setLineDash &&
                              (c[b].lineDashType
                                ? ((k = c[b].lineDashType),
                                  (l[l.length - 1].newLineDashArray = K(
                                    k,
                                    d.lineThickness
                                  )),
                                  a.setLineDash(
                                    l[l.length - 1].newLineDashArray
                                  ))
                                : ((k = d.lineDashType),
                                  (l[l.length - 1].newLineDashArray = T),
                                  a.setLineDash(T)))),
                          0 !== c[b].markerSize &&
                            (0 < c[b].markerSize || 0 < d.markerSize))
                        ) {
                          var P = d.getMarkerProperties(b, p, x, a);
                          n.push(P);
                          var S = N(m);
                          Z &&
                            n.push({
                              x: p,
                              y: x,
                              ctx: s,
                              type: P.type,
                              size: P.size,
                              color: S,
                              borderColor: S,
                              borderThickness: P.borderThickness,
                            }),
                            (P = d.getMarkerProperties(b, p, u, a)),
                            n.push(P),
                            (S = N(m)),
                            Z &&
                              n.push({
                                x: p,
                                y: u,
                                ctx: s,
                                type: P.type,
                                size: P.size,
                                color: S,
                                borderColor: S,
                                borderThickness: P.borderThickness,
                              });
                        }
                        (c[b].indexLabel ||
                          d.indexLabel ||
                          c[b].indexLabelFormatter ||
                          d.indexLabelFormatter) &&
                          (this._indexLabels.push({
                            chartType: "rangeArea",
                            dataPoint: c[b],
                            dataSeries: d,
                            indexKeyword: 0,
                            point: { x: p, y: u },
                            direction:
                              c[b].y[0] > c[b].y[1] === t.axisY.reversed
                                ? -1
                                : 1,
                            color: f,
                          }),
                          this._indexLabels.push({
                            chartType: "rangeArea",
                            dataPoint: c[b],
                            dataSeries: d,
                            indexKeyword: 1,
                            point: { x: p, y: x },
                            direction:
                              c[b].y[0] > c[b].y[1] === t.axisY.reversed
                                ? 1
                                : -1,
                            color: f,
                          }));
                      } else C || g || e(), (C = !0);
                  e(), I.drawMarkers(n);
                }
              }
              return (
                Z &&
                  (i.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (a.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    a.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    a.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  a.clearRect(o.x1, o.y1, o.width, o.height),
                  this._eventManager.ghostCtx.restore()),
                a.restore(),
                {
                  source: i,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderRangeSplineArea = function (t) {
            function e(t, e) {
              var i = A(m, 2);
              if (0 < i.length) {
                if (0 < h.lineThickness) {
                  (n.strokeStyle = e),
                    n.setLineDash && n.setLineDash(t),
                    n.beginPath(),
                    n.moveTo(i[0].x, i[0].y);
                  for (var a = 0; a < i.length - 3; a += 3)
                    (i[a].newStrokeStyle || i[a].newLineDashArray) &&
                      (n.stroke(),
                      n.beginPath(),
                      n.moveTo(i[a].x, i[a].y),
                      i[a].newStrokeStyle &&
                        (n.strokeStyle = i[a].newStrokeStyle),
                      i[a].newLineDashArray &&
                        n.setLineDash(i[a].newLineDashArray)),
                      n.bezierCurveTo(
                        i[a + 1].x,
                        i[a + 1].y,
                        i[a + 2].x,
                        i[a + 2].y,
                        i[a + 3].x,
                        i[a + 3].y
                      );
                  n.stroke();
                }
                for (
                  n.beginPath(),
                    n.moveTo(i[0].x, i[0].y),
                    Z && (o.beginPath(), o.moveTo(i[0].x, i[0].y)),
                    a = 0;
                  a < i.length - 3;
                  a += 3
                )
                  n.bezierCurveTo(
                    i[a + 1].x,
                    i[a + 1].y,
                    i[a + 2].x,
                    i[a + 2].y,
                    i[a + 3].x,
                    i[a + 3].y
                  ),
                    Z &&
                      o.bezierCurveTo(
                        i[a + 1].x,
                        i[a + 1].y,
                        i[a + 2].x,
                        i[a + 2].y,
                        i[a + 3].x,
                        i[a + 3].y
                      );
                for (
                  i = A(g, 2),
                    n.lineTo(g[g.length - 1].x, g[g.length - 1].y),
                    a = i.length - 1;
                  2 < a;
                  a -= 3
                )
                  n.bezierCurveTo(
                    i[a - 1].x,
                    i[a - 1].y,
                    i[a - 2].x,
                    i[a - 2].y,
                    i[a - 3].x,
                    i[a - 3].y
                  ),
                    Z &&
                      o.bezierCurveTo(
                        i[a - 1].x,
                        i[a - 1].y,
                        i[a - 2].x,
                        i[a - 2].y,
                        i[a - 3].x,
                        i[a - 3].y
                      );
                if (
                  (n.closePath(),
                  (n.globalAlpha = h.fillOpacity),
                  n.fill(),
                  Z && (o.closePath(), o.fill()),
                  (n.globalAlpha = 1),
                  0 < h.lineThickness)
                ) {
                  (n.strokeStyle = e),
                    n.setLineDash && n.setLineDash(t),
                    n.beginPath(),
                    n.moveTo(i[0].x, i[0].y);
                  for (var s = (a = 0); a < i.length - 3; a += 3, s++)
                    (m[s].newStrokeStyle || m[s].newLineDashArray) &&
                      (n.stroke(),
                      n.beginPath(),
                      n.moveTo(i[a].x, i[a].y),
                      m[s].newStrokeStyle &&
                        (n.strokeStyle = m[s].newStrokeStyle),
                      m[s].newLineDashArray &&
                        n.setLineDash(m[s].newLineDashArray)),
                      n.bezierCurveTo(
                        i[a + 1].x,
                        i[a + 1].y,
                        i[a + 2].x,
                        i[a + 2].y,
                        i[a + 3].x,
                        i[a + 3].y
                      );
                  n.stroke();
                }
                n.beginPath();
              }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
              n = Z ? this._preRenderCtx : i;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var o = this._eventManager.ghostCtx,
                a = [],
                s = this.plotArea;
              n.save(),
                Z && o.save(),
                n.beginPath(),
                n.rect(s.x1, s.y1, s.width, s.height),
                n.clip(),
                Z &&
                  (o.beginPath(),
                  o.rect(s.x1, s.y1, s.width, s.height),
                  o.clip());
              for (var r = 0; r < t.dataSeriesIndexes.length; r++) {
                var l = t.dataSeriesIndexes[r],
                  h = this.data[l],
                  d = h.dataPoints;
                a = h.id;
                (this._eventManager.objectMap[a] = {
                  objectType: "dataSeries",
                  dataSeriesIndex: l,
                }),
                  (a = N(a)),
                  (o.fillStyle = a);
                a = [];
                var c,
                  p,
                  u,
                  x = 0,
                  m = [],
                  g = [];
                if (0 < d.length) {
                  var b = h._colorSet[x % h._colorSet.length],
                    v = (h.lineColor = h.options.lineColor || b),
                    f = v;
                  (n.fillStyle = b), (n.lineWidth = h.lineThickness);
                  var y,
                    M = "solid";
                  if (n.setLineDash) {
                    var k = K(h.nullDataLineDashType, h.lineThickness);
                    y = K((M = h.lineDashType), h.lineThickness);
                  }
                  for (p = !1; x < d.length; x++)
                    if (
                      !(
                        (c = d[x].x.getTime ? d[x].x.getTime() : d[x].x) <
                          t.axisX.dataInfo.viewPortMin ||
                        (c > t.axisX.dataInfo.viewPortMax &&
                          (!h.connectNullData || !p))
                      )
                    )
                      if (
                        null !== d[x].y &&
                        d[x].y.length &&
                        "number" == typeof d[x].y[0] &&
                        "number" == typeof d[x].y[1]
                      ) {
                        (c = t.axisX.convertValueToPixel(c)),
                          (p = t.axisY.convertValueToPixel(d[x].y[0])),
                          (u = t.axisY.convertValueToPixel(d[x].y[1]));
                        var w = h.dataPointIds[x];
                        if (
                          ((this._eventManager.objectMap[w] = {
                            id: w,
                            objectType: "dataPoint",
                            dataSeriesIndex: l,
                            dataPointIndex: x,
                            x1: c,
                            y1: p,
                            y2: u,
                          }),
                          (m[m.length] = { x: c, y: p }),
                          (g[g.length] = { x: c, y: u }),
                          x < d.length - 1 &&
                            (f !== (d[x].lineColor || v) ||
                              M !== (d[x].lineDashType || h.lineDashType)) &&
                            ((f = d[x].lineColor || v),
                            (m[m.length - 1].newStrokeStyle = f),
                            n.setLineDash &&
                              (d[x].lineDashType
                                ? ((M = d[x].lineDashType),
                                  (m[m.length - 1].newLineDashArray = K(
                                    M,
                                    h.lineThickness
                                  )))
                                : ((M = h.lineDashType),
                                  (m[m.length - 1].newLineDashArray = y)))),
                          0 !== d[x].markerSize &&
                            (0 < d[x].markerSize || 0 < h.markerSize))
                        ) {
                          var T = h.getMarkerProperties(x, c, p, n);
                          a.push(T);
                          var C = N(w);
                          Z &&
                            a.push({
                              x: c,
                              y: p,
                              ctx: o,
                              type: T.type,
                              size: T.size,
                              color: C,
                              borderColor: C,
                              borderThickness: T.borderThickness,
                            }),
                            (T = h.getMarkerProperties(x, c, u, n)),
                            a.push(T),
                            (C = N(w)),
                            Z &&
                              a.push({
                                x: c,
                                y: u,
                                ctx: o,
                                type: T.type,
                                size: T.size,
                                color: C,
                                borderColor: C,
                                borderThickness: T.borderThickness,
                              });
                        }
                        (d[x].indexLabel ||
                          h.indexLabel ||
                          d[x].indexLabelFormatter ||
                          h.indexLabelFormatter) &&
                          (this._indexLabels.push({
                            chartType: "rangeSplineArea",
                            dataPoint: d[x],
                            dataSeries: h,
                            indexKeyword: 0,
                            point: { x: c, y: p },
                            direction: d[x].y[0] <= d[x].y[1] ? -1 : 1,
                            color: b,
                          }),
                          this._indexLabels.push({
                            chartType: "rangeSplineArea",
                            dataPoint: d[x],
                            dataSeries: h,
                            indexKeyword: 1,
                            point: { x: c, y: u },
                            direction: d[x].y[0] <= d[x].y[1] ? 1 : -1,
                            color: b,
                          })),
                          (p = !1);
                      } else
                        0 < x &&
                          !p &&
                          (h.connectNullData
                            ? n.setLineDash &&
                              0 < m.length &&
                              (h.options.nullDataLineDashType ||
                                !d[x - 1].lineDashType) &&
                              ((m[m.length - 1].newLineDashArray = k),
                              (M = h.nullDataLineDashType))
                            : (e(y, v), (m = []), (g = []))),
                          (p = !0);
                  e(y, v), I.drawMarkers(a);
                }
              }
              return (
                Z &&
                  (i.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (n.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    n.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    n.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  n.clearRect(s.x1, s.y1, s.width, s.height),
                  this._eventManager.ghostCtx.restore()),
                n.restore(),
                {
                  source: i,
                  dest: this.plotArea.ctx,
                  animationCallback: j.xClipAnimation,
                  easingFunction: j.easing.linear,
                  animationBase: 0,
                }
              );
            }
          }),
          (r.prototype.renderWaterfall = function (t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
              i = Z ? this._preRenderCtx : e;
            if (!(t.dataSeriesIndexes.length <= 0)) {
              var a,
                s,
                n,
                o,
                r = this._eventManager.ghostCtx,
                l = null,
                h = this.plotArea,
                d = 0,
                c = t.axisY.convertValueToPixel(
                  t.axisY.logarithmic ? t.axisY.viewportMinimum : 0
                );
              d = this.options.dataPointMinWidth
                ? this.dataPointMinWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : 1;
              s = this.options.dataPointMaxWidth
                ? this.dataPointMaxWidth
                : this.options.dataPointWidth
                ? this.dataPointWidth
                : Math.min(
                    0.15 * this.width,
                    (this.plotArea.width / t.plotType.totalDataSeries) * 0.9
                  ) << 0;
              var p = t.axisX.dataInfo.minDiff;
              isFinite(p) || (p = 0.3 * Math.abs(t.axisX.range)),
                (p = this.options.dataPointWidth
                  ? this.dataPointWidth
                  : (((h.width *
                      (t.axisX.logarithmic
                        ? Math.log(p) / Math.log(t.axisX.range)
                        : Math.abs(p) / Math.abs(t.axisX.range))) /
                      t.plotType.totalDataSeries) *
                      0.6) <<
                    0),
                this.dataPointMaxWidth &&
                  s < d &&
                  (d = Math.min(
                    this.options.dataPointWidth ? this.dataPointWidth : 1 / 0,
                    s
                  )),
                !this.dataPointMaxWidth &&
                  this.dataPointMinWidth &&
                  s < d &&
                  (s = Math.max(
                    this.options.dataPointWidth ? this.dataPointWidth : -1 / 0,
                    d
                  )),
                p < d && (p = d),
                s < p && (p = s),
                i.save(),
                Z && this._eventManager.ghostCtx.save(),
                i.beginPath(),
                i.rect(h.x1, h.y1, h.width, h.height),
                i.clip(),
                Z &&
                  (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(
                    h.x1,
                    h.y1,
                    h.width,
                    h.height
                  ),
                  this._eventManager.ghostCtx.clip());
              for (var u = 0; u < t.dataSeriesIndexes.length; u++) {
                var x = t.dataSeriesIndexes[u],
                  m = this.data[x],
                  g = m.dataPoints;
                l = m._colorSet[0];
                (m.risingColor = m.options.risingColor
                  ? m.options.risingColor
                  : l),
                  (m.fallingColor = m.options.fallingColor
                    ? m.options.fallingColor
                    : "#e40a0a");
                var b =
                    "number" == typeof m.options.lineThickness
                      ? Math.round(m.lineThickness)
                      : 1,
                  v = 1 == Math.round(b) % 2 ? -0.5 : 0;
                if (0 < g.length) {
                  var f = !!(5 < p && m.bevelEnabled),
                    y = !1,
                    M = null,
                    k = null;
                  for (d = 0; d < g.length; d++)
                    if (
                      ((o = g[d].getTime ? g[d].x.getTime() : g[d].x),
                      "number" != typeof g[d].y)
                    ) {
                      if (0 < d && !y && m.connectNullData)
                        var w =
                          m.options.nullDataLineDashType ||
                          !g[d - 1].lineDashType
                            ? m.nullDataLineDashType
                            : g[d - 1].lineDashType;
                      y = !0;
                    } else {
                      (a = t.axisX.convertValueToPixel(o)),
                        (s =
                          0 === m.dataPointEOs[d].cumulativeSum
                            ? c
                            : t.axisY.convertValueToPixel(
                                m.dataPointEOs[d].cumulativeSum
                              )),
                        (n =
                          0 === m.dataPointEOs[d].cumulativeSumYStartValue
                            ? c
                            : t.axisY.convertValueToPixel(
                                m.dataPointEOs[d].cumulativeSumYStartValue
                              )),
                        (a = t.axisX.reversed
                          ? (a +
                              (t.plotType.totalDataSeries * p) / 2 -
                              (t.previousDataSeriesCount + u) * p) <<
                            0
                          : (a -
                              (t.plotType.totalDataSeries * p) / 2 +
                              (t.previousDataSeriesCount + u) * p) <<
                            0);
                      var T = t.axisX.reversed ? (a - p) << 0 : (a + p) << 0;
                      n < s && ((l = s), (s = n), (n = l)),
                        t.axisY.reversed && ((l = s), (s = n), (n = l)),
                        (l = m.dataPointIds[d]),
                        (this._eventManager.objectMap[l] = {
                          id: l,
                          objectType: "dataPoint",
                          dataSeriesIndex: x,
                          dataPointIndex: d,
                          x1: a,
                          y1: s,
                          x2: T,
                          y2: n,
                        });
                      var C = g[d].color
                        ? g[d].color
                        : 0 < g[d].y
                        ? m.risingColor
                        : m.fallingColor;
                      R(i, a, s, T, n, C, 0, C, f, f, !1, !1, m.fillOpacity),
                        (l = N(l)),
                        Z &&
                          R(
                            this._eventManager.ghostCtx,
                            a,
                            s,
                            T,
                            n,
                            l,
                            0,
                            null,
                            !1,
                            !1,
                            !1,
                            !1
                          );
                      var P;
                      C = a;
                      (P =
                        (void 0 !== g[d].isIntermediateSum &&
                          !0 === g[d].isIntermediateSum) ||
                        (void 0 !== g[d].isCumulativeSum &&
                          !0 === g[d].isCumulativeSum)
                          ? 0 < g[d].y
                            ? s
                            : n
                          : 0 < g[d].y
                          ? n
                          : s),
                        0 < d &&
                          M &&
                          (!y || m.connectNullData) &&
                          (y && i.setLineDash && i.setLineDash(K(w, b)),
                          i.beginPath(),
                          i.moveTo(M, k - v),
                          i.lineTo(C, P - v),
                          0 < b && i.stroke(),
                          Z &&
                            (r.beginPath(),
                            r.moveTo(M, k - v),
                            r.lineTo(C, P - v),
                            0 < b && r.stroke())),
                        (y = !1),
                        (M = T),
                        (k = 0 < g[d].y ? s : n),
                        (C = g[d].lineDashType
                          ? g[d].lineDashType
                          : m.options.lineDashType
                          ? m.options.lineDashType
                          : "shortDash"),
                        (i.strokeStyle = g[d].lineColor
                          ? g[d].lineColor
                          : m.options.lineColor
                          ? m.options.lineColor
                          : "#9e9e9e"),
                        (i.lineWidth = b),
                        i.setLineDash && ((C = K(C, b)), i.setLineDash(C)),
                        (g[d].indexLabel ||
                          m.indexLabel ||
                          g[d].indexLabelFormatter ||
                          m.indexLabelFormatter) &&
                          this._indexLabels.push({
                            chartType: "waterfall",
                            dataPoint: g[d],
                            dataSeries: m,
                            point: {
                              x: a + (T - a) / 2,
                              y: 0 <= g[d].y ? s : n,
                            },
                            direction: g[d].y < 0 === t.axisY.reversed ? 1 : -1,
                            bounds: {
                              x1: a,
                              y1: Math.min(s, n),
                              x2: T,
                              y2: Math.max(s, n),
                            },
                            color: l,
                          });
                    }
                }
              }
              return (
                Z &&
                  (e.drawImage(
                    this._preRenderCanvas,
                    0,
                    0,
                    this.width,
                    this.height
                  ),
                  (i.globalCompositeOperation = "source-atop"),
                  t.axisX.maskCanvas &&
                    i.drawImage(
                      t.axisX.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  t.axisY.maskCanvas &&
                    i.drawImage(
                      t.axisY.maskCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  this._breaksCanvasCtx &&
                    this._breaksCanvasCtx.drawImage(
                      this._preRenderCanvas,
                      0,
                      0,
                      this.width,
                      this.height
                    ),
                  i.clearRect(h.x1, h.y1, h.width, h.height),
                  this._eventManager.ghostCtx.restore()),
                i.restore(),
                {
                  source: e,
                  dest: this.plotArea.ctx,
                  animationCallback: j.fadeInAnimation,
                  easingFunction: j.easing.easeInQuad,
                  animationBase: 0,
                }
              );
            }
          });
        var B = function (t, e, i, a, s, n, o, r, l) {
          if (!(i < 0)) {
            if ((void 0 === r && (r = 1), !Z)) {
              var h = Number((o % (2 * Math.PI)).toFixed(8));
              Number((n % (2 * Math.PI)).toFixed(8)) === h && (o -= 1e-4);
            }
            t.save(),
              (t.globalAlpha = r),
              "pie" === s
                ? (t.beginPath(),
                  t.moveTo(e.x, e.y),
                  t.arc(e.x, e.y, i, n, o, !1),
                  (t.fillStyle = a),
                  (t.strokeStyle = "white"),
                  (t.lineWidth = 2),
                  t.closePath(),
                  t.fill())
                : "doughnut" === s &&
                  (t.beginPath(),
                  t.arc(e.x, e.y, i, n, o, !1),
                  0 <= l && t.arc(e.x, e.y, l * i, o, n, !0),
                  t.closePath(),
                  (t.fillStyle = a),
                  (t.strokeStyle = "white"),
                  (t.lineWidth = 2),
                  t.fill()),
              (t.globalAlpha = 1),
              t.restore();
          }
        };
        r.prototype.renderPie = function (t) {
          function e(t) {
            var e = c.plotArea.ctx;
            for (
              e.clearRect(M.x1, M.y1, M.width, M.height),
                e.fillStyle = c.backgroundColor,
                e.fillRect(M.x1, M.y1, M.width, M.height),
                e = 0;
              e < f.length;
              e++
            ) {
              var i = k[e].startAngle,
                a = k[e].endAngle;
              if (i < a) {
                var s = 0.07 * S * Math.cos(k[e].midAngle),
                  n = 0.07 * S * Math.sin(k[e].midAngle),
                  o = !1;
                f[e].exploded
                  ? (1e-9 < Math.abs(k[e].center.x - (P.x + s)) ||
                      1e-9 < Math.abs(k[e].center.y - (P.y + n))) &&
                    ((k[e].center.x = P.x + s * t),
                    (k[e].center.y = P.y + n * t),
                    (o = !0))
                  : (0 < Math.abs(k[e].center.x - P.x) ||
                      0 < Math.abs(k[e].center.y - P.y)) &&
                    ((k[e].center.x = P.x + s * (1 - t)),
                    (k[e].center.y = P.y + n * (1 - t)),
                    (o = !0)),
                  o &&
                    (((s = {}).dataSeries = v),
                    (s.dataPoint = v.dataPoints[e]),
                    (s.index = e),
                    c.toolTip.highlightObjects([s])),
                  B(
                    c.plotArea.ctx,
                    k[e].center,
                    k[e].radius,
                    f[e].color
                      ? f[e].color
                      : v._colorSet[e % v._colorSet.length],
                    v.type,
                    i,
                    a,
                    v.fillOpacity,
                    k[e].percentInnerRadius
                  );
              }
            }
            for (
              (t = c.plotArea.ctx).save(),
                t.fillStyle = "black",
                t.strokeStyle = "grey",
                t.textBaseline = "middle",
                t.lineJoin = "round",
                e = e = 0;
              e < f.length;
              e++
            )
              (i = k[e]).indexLabelText &&
                ((i.indexLabelTextBlock.y -= i.indexLabelTextBlock.height / 2),
                (a = 0),
                (a =
                  "left" === i.hemisphere
                    ? "inside" !== v.indexLabelPlacement
                      ? -(i.indexLabelTextBlock.width + y)
                      : -i.indexLabelTextBlock.width / 2
                    : "inside" !== v.indexLabelPlacement
                    ? y
                    : -i.indexLabelTextBlock.width / 2),
                (i.indexLabelTextBlock.x += a),
                i.indexLabelTextBlock.render(!0),
                (i.indexLabelTextBlock.x -= a),
                (i.indexLabelTextBlock.y += i.indexLabelTextBlock.height / 2),
                "inside" !== i.indexLabelPlacement &&
                  0 < i.indexLabelLineThickness &&
                  ((a = i.center.x + S * Math.cos(i.midAngle)),
                  (s = i.center.y + S * Math.sin(i.midAngle)),
                  (t.strokeStyle = i.indexLabelLineColor),
                  (t.lineWidth = i.indexLabelLineThickness),
                  t.setLineDash &&
                    t.setLineDash(
                      K(i.indexLabelLineDashType, i.indexLabelLineThickness)
                    ),
                  t.beginPath(),
                  t.moveTo(a, s),
                  t.lineTo(i.indexLabelTextBlock.x, i.indexLabelTextBlock.y),
                  t.lineTo(
                    i.indexLabelTextBlock.x +
                      ("left" === i.hemisphere ? -y : y),
                    i.indexLabelTextBlock.y
                  ),
                  t.stroke()),
                (t.lineJoin = "miter"));
            t.save();
          }
          function g(t, e) {
            var i = 0,
              a =
                ((i =
                  t.indexLabelTextBlock.y - t.indexLabelTextBlock.height / 2),
                t.indexLabelTextBlock.y + t.indexLabelTextBlock.height / 2),
              s = e.indexLabelTextBlock.y - e.indexLabelTextBlock.height / 2,
              n = e.indexLabelTextBlock.y + e.indexLabelTextBlock.height / 2;
            return e.indexLabelTextBlock.y > t.indexLabelTextBlock.y
              ? s - a
              : i - n;
          }
          function b(t) {
            for (var e = null, i = 1; i < f.length; i++) {
              if (
                ((e = (t + i + k.length) % k.length),
                k[e].hemisphere !== k[t].hemisphere)
              ) {
                e = null;
                break;
              }
              if (
                k[e].indexLabelText &&
                e !== t &&
                (g(k[e], k[t]) < 0 ||
                  ("right" === k[t].hemisphere
                    ? k[e].indexLabelTextBlock.y >= k[t].indexLabelTextBlock.y
                    : k[e].indexLabelTextBlock.y <= k[t].indexLabelTextBlock.y))
              )
                break;
              e = null;
            }
            return e;
          }
          function d(t, e, i) {
            if (1e3 < (i = (i || 0) + 1)) return 0;
            e = e || 0;
            var a = 0,
              s = P.y - 1 * p,
              n = P.y + 1 * p;
            if (0 <= t && t < f.length) {
              var o = k[t];
              if (
                (e < 0 && o.indexLabelTextBlock.y < s) ||
                (0 < e && o.indexLabelTextBlock.y > n)
              )
                return 0;
              var r = 0,
                l = 0;
              l = r = r = 0;
              for (
                e < 0
                  ? o.indexLabelTextBlock.y - o.indexLabelTextBlock.height / 2 >
                      s &&
                    o.indexLabelTextBlock.y -
                      o.indexLabelTextBlock.height / 2 +
                      e <
                      s &&
                    (e = -(
                      s -
                      (o.indexLabelTextBlock.y -
                        o.indexLabelTextBlock.height / 2 +
                        e)
                    ))
                  : o.indexLabelTextBlock.y + o.indexLabelTextBlock.height / 2 <
                      s &&
                    o.indexLabelTextBlock.y +
                      o.indexLabelTextBlock.height / 2 +
                      e >
                      n &&
                    (e =
                      o.indexLabelTextBlock.y +
                      o.indexLabelTextBlock.height / 2 +
                      e -
                      n),
                  e = o.indexLabelTextBlock.y + e,
                  s = 0,
                  s =
                    "right" === o.hemisphere
                      ? P.x + Math.sqrt(Math.pow(p, 2) - Math.pow(e - P.y, 2))
                      : P.x - Math.sqrt(Math.pow(p, 2) - Math.pow(e - P.y, 2)),
                  l = P.x + S * Math.cos(o.midAngle),
                  r = P.y + S * Math.sin(o.midAngle),
                  r = Math.sqrt(Math.pow(s - l, 2) + Math.pow(e - r, 2)),
                  l = Math.acos(S / p),
                  e =
                    (r = Math.acos((p * p + S * S - r * r) / (2 * S * p))) < l
                      ? e - o.indexLabelTextBlock.y
                      : 0,
                  s = null,
                  n = 1;
                n < f.length;
                n++
              ) {
                if (
                  ((s = (t - n + k.length) % k.length),
                  k[s].hemisphere !== k[t].hemisphere)
                ) {
                  s = null;
                  break;
                }
                if (
                  k[s].indexLabelText &&
                  k[s].hemisphere === k[t].hemisphere &&
                  s !== t &&
                  (g(k[s], k[t]) < 0 ||
                    ("right" === k[t].hemisphere
                      ? k[s].indexLabelTextBlock.y <= k[t].indexLabelTextBlock.y
                      : k[s].indexLabelTextBlock.y >=
                        k[t].indexLabelTextBlock.y))
                )
                  break;
                s = null;
              }
              (l = s),
                (r = b(t)),
                (n = s = 0),
                e < 0
                  ? ((a = e),
                    null !== (n = "right" === o.hemisphere ? l : r) &&
                      ((l = -e),
                      (e =
                        o.indexLabelTextBlock.y -
                        o.indexLabelTextBlock.height / 2 -
                        (k[n].indexLabelTextBlock.y +
                          k[n].indexLabelTextBlock.height / 2)) -
                        l <
                        w &&
                        +(n = d(n, (s = -l), i + 1)).toFixed(C) >
                          +s.toFixed(C) &&
                        (a = w < e ? -(e - w) : -(l - (n - s)))))
                  : 0 < e &&
                    ((a = e),
                    null !== (n = "right" === o.hemisphere ? r : l) &&
                      ((l = e),
                      (e =
                        k[n].indexLabelTextBlock.y -
                        k[n].indexLabelTextBlock.height / 2 -
                        (o.indexLabelTextBlock.y +
                          o.indexLabelTextBlock.height / 2)) -
                        l <
                        w &&
                        +(n = d(n, (s = l), i + 1)).toFixed(C) <
                          +s.toFixed(C) &&
                        (a = w < e ? e - w : l - (s - n)))),
                a &&
                  ((i = o.indexLabelTextBlock.y + a),
                  (e = 0),
                  (e =
                    "right" === o.hemisphere
                      ? P.x + Math.sqrt(Math.pow(p, 2) - Math.pow(i - P.y, 2))
                      : P.x - Math.sqrt(Math.pow(p, 2) - Math.pow(i - P.y, 2))),
                  o.midAngle > Math.PI / 2 - u && o.midAngle < Math.PI / 2 + u
                    ? ((s = (t - 1 + k.length) % k.length),
                      (s = k[s]),
                      (t = k[(t + 1 + k.length) % k.length]),
                      "left" === o.hemisphere &&
                      "right" === s.hemisphere &&
                      e > s.indexLabelTextBlock.x
                        ? (e = s.indexLabelTextBlock.x - 15)
                        : "right" === o.hemisphere &&
                          "left" === t.hemisphere &&
                          e < t.indexLabelTextBlock.x &&
                          (e = t.indexLabelTextBlock.x + 15))
                    : o.midAngle > (3 * Math.PI) / 2 - u &&
                      o.midAngle < (3 * Math.PI) / 2 + u &&
                      ((s = (t - 1 + k.length) % k.length),
                      (s = k[s]),
                      (t = k[(t + 1 + k.length) % k.length]),
                      "right" === o.hemisphere &&
                      "left" === s.hemisphere &&
                      e < s.indexLabelTextBlock.x
                        ? (e = s.indexLabelTextBlock.x + 15)
                        : "left" === o.hemisphere &&
                          "right" === t.hemisphere &&
                          e > t.indexLabelTextBlock.x &&
                          (e = t.indexLabelTextBlock.x - 15)),
                  (o.indexLabelTextBlock.y = i),
                  (o.indexLabelTextBlock.x = e),
                  (o.indexLabelAngle = Math.atan2(
                    o.indexLabelTextBlock.y - P.y,
                    o.indexLabelTextBlock.x - P.x
                  )));
            }
            return a;
          }
          function i() {
            ((s = c.plotArea.ctx).fillStyle = "grey"),
              (s.strokeStyle = "grey"),
              (s.font = "16px Arial"),
              (s.textBaseline = "middle");
            var t = (s = 0),
              e = 0,
              i = !0;
            for (t = 0; t < 10 && (t < 1 || 0 < e); t++) {
              if (
                ((v.radius ||
                  (!v.radius &&
                    void 0 !== v.innerRadius &&
                    null !== v.innerRadius &&
                    S - e <= A)) &&
                  (i = !1),
                i && (S -= e),
                (e = 0),
                "inside" !== v.indexLabelPlacement)
              ) {
                for (p = S * T, s = 0; s < f.length; s++) {
                  ((n = k[s]).indexLabelTextBlock.x =
                    P.x + p * Math.cos(n.midAngle)),
                    (n.indexLabelTextBlock.y = P.y + p * Math.sin(n.midAngle)),
                    (n.indexLabelAngle = n.midAngle),
                    (n.radius = S),
                    (n.percentInnerRadius = _);
                }
                for (var u, a, s = 0; s < f.length; s++) {
                  var n = k[s],
                    o = b(s);
                  if (null !== o) {
                    (u = k[s]), (a = k[o]);
                    var x = 0;
                    if ((x = g(u, a) - w) < 0) {
                      for (var r = (a = 0), l = 0; l < f.length; l++)
                        l !== s &&
                          k[l].hemisphere === n.hemisphere &&
                          (k[l].indexLabelTextBlock.y < n.indexLabelTextBlock.y
                            ? a++
                            : r++);
                      r = -1 * (x - (a = (x / (a + r || 1)) * r));
                      var h = (l = 0);
                      "right" === n.hemisphere
                        ? ((l = d(s, a)),
                          +(h = d(o, (r = -1 * (x - l)))).toFixed(C) <
                            +r.toFixed(C) &&
                            +l.toFixed(C) <= +a.toFixed(C) &&
                            d(s, -(r - h)))
                        : ((l = d(o, a)),
                          +(h = d(s, (r = -1 * (x - l)))).toFixed(C) <
                            +r.toFixed(C) &&
                            +l.toFixed(C) <= +a.toFixed(C) &&
                            d(o, -(r - h)));
                    }
                  }
                }
              } else
                for (s = 0; s < f.length; s++)
                  (n = k[s]),
                    (p = "pie" === v.type ? 0.7 * S : 0.8 * S),
                    (o = P.x + p * Math.cos(n.midAngle)),
                    (a = P.y + p * Math.sin(n.midAngle)),
                    (n.indexLabelTextBlock.x = o),
                    (n.indexLabelTextBlock.y = a);
              for (s = 0; s < f.length; s++)
                0 !==
                  (o = (n = k[s]).indexLabelTextBlock.measureText()).height &&
                  0 !== o.width &&
                  ((o = o = 0),
                  "right" === n.hemisphere
                    ? ((o =
                        M.x2 -
                        (n.indexLabelTextBlock.x +
                          n.indexLabelTextBlock.width +
                          y)),
                      (o *= -1))
                    : (o =
                        M.x1 -
                        (n.indexLabelTextBlock.x -
                          n.indexLabelTextBlock.width -
                          y)),
                  0 < o &&
                    (!i &&
                      n.indexLabelText &&
                      ((a =
                        "right" === n.hemisphere
                          ? M.x2 - n.indexLabelTextBlock.x
                          : n.indexLabelTextBlock.x - M.x1),
                      0.3 * n.indexLabelTextBlock.maxWidth > a
                        ? (n.indexLabelText = "")
                        : (n.indexLabelTextBlock.maxWidth = 0.85 * a),
                      0.3 * n.indexLabelTextBlock.maxWidth < a &&
                        (n.indexLabelTextBlock.x -=
                          "right" === n.hemisphere ? 2 : -2)),
                    Math.abs(
                      n.indexLabelTextBlock.y -
                        n.indexLabelTextBlock.height / 2 -
                        P.y
                    ) < S ||
                      Math.abs(
                        n.indexLabelTextBlock.y +
                          n.indexLabelTextBlock.height / 2 -
                          P.y
                      ) < S) &&
                    (9 < (o /= Math.abs(Math.cos(n.indexLabelAngle))) &&
                      (o *= 0.3),
                    e < o && (e = o)),
                  (o = o = 0),
                  0 < n.indexLabelAngle && n.indexLabelAngle < Math.PI
                    ? ((o =
                        M.y2 -
                        (n.indexLabelTextBlock.y +
                          n.indexLabelTextBlock.height / 2 +
                          5)),
                      (o *= -1))
                    : (o =
                        M.y1 -
                        (n.indexLabelTextBlock.y -
                          n.indexLabelTextBlock.height / 2 -
                          5)),
                  0 < o &&
                    (!i &&
                      n.indexLabelText &&
                      0 ===
                        d(
                          s,
                          o *
                            (a =
                              0 < n.indexLabelAngle &&
                              n.indexLabelAngle < Math.PI
                                ? -1
                                : 1)
                        ) &&
                      d(s, 2 * a),
                    Math.abs(n.indexLabelTextBlock.x - P.x) < S &&
                      (9 < (o /= Math.abs(Math.sin(n.indexLabelAngle))) &&
                        (o *= 0.3),
                      e < o && (e = o))));
              var m = function (t, e, i) {
                for (
                  var a = [], s = 0;
                  a.push(k[e]), e !== i;
                  e = (e + 1 + f.length) % f.length
                );
                for (
                  a.sort(function (t, e) {
                    return t.y - e.y;
                  }),
                    e = 0;
                  e < a.length && ((i = a[e]), s < 0.7 * t);
                  e++
                )
                  (s += i.indexLabelTextBlock.height),
                    (i.indexLabelTextBlock.text = ""),
                    (i.indexLabelText = ""),
                    i.indexLabelTextBlock.measureText();
              };
              !(function () {
                for (
                  var t = -1, e = -1, i = 0, a = !1, s = 0;
                  s < f.length;
                  s++
                )
                  if (((a = !1), (u = k[s]).indexLabelText)) {
                    var n = b(s);
                    if (null !== n) {
                      var o,
                        r = k[n];
                      if (((x = 0), (o = (x = g(u, r)) < 0))) {
                        o = u.indexLabelTextBlock.x;
                        var l =
                            u.indexLabelTextBlock.y -
                            u.indexLabelTextBlock.height / 2,
                          h =
                            u.indexLabelTextBlock.y +
                            u.indexLabelTextBlock.height / 2,
                          d =
                            r.indexLabelTextBlock.y -
                            r.indexLabelTextBlock.height / 2,
                          c =
                            r.indexLabelTextBlock.x +
                            r.indexLabelTextBlock.width,
                          p =
                            r.indexLabelTextBlock.y +
                            r.indexLabelTextBlock.height / 2;
                        o = !(
                          u.indexLabelTextBlock.x +
                            u.indexLabelTextBlock.width <
                            r.indexLabelTextBlock.x - y ||
                          c + y < o ||
                          p + y < l ||
                          h < d - y
                        );
                      }
                      o
                        ? (t < 0 && (t = s),
                          n !== t && ((e = n), (i += -x)),
                          0 == s % Math.max(f.length / 10, 3) && (a = !0))
                        : (a = !0),
                        a &&
                          0 < i &&
                          0 <= t &&
                          0 <= e &&
                          (m(i, t, e), (e = t = -1), (i = 0));
                    }
                  }
                0 < i && m(i, t, e);
              })();
            }
          }
          function o() {
            if (
              (c.plotArea.layoutManager.reset(),
              c.title &&
                (c.title.dockInsidePlotArea ||
                  ("center" === c.title.horizontalAlign &&
                    "center" === c.title.verticalAlign)) &&
                c.title.render(),
              c.subtitles)
            )
              for (var t = 0; t < c.subtitles.length; t++) {
                var e = c.subtitles[t];
                (e.dockInsidePlotArea ||
                  ("center" === e.horizontalAlign &&
                    "center" === e.verticalAlign)) &&
                  e.render();
              }
            c.legend &&
              (c.legend.dockInsidePlotArea ||
                ("center" === c.legend.horizontalAlign &&
                  "center" === c.legend.verticalAlign)) &&
              c.legend.render();
          }
          var c = this;
          if (!(t.dataSeriesIndexes.length <= 0)) {
            var p,
              v = this.data[t.dataSeriesIndexes[0]],
              f = v.dataPoints,
              y = 10,
              M = this.plotArea,
              k = v.dataPointEOs,
              w = 2,
              T = 1.3,
              u = (20 / 180) * Math.PI,
              C = 6,
              P = { x: (M.x2 + M.x1) / 2, y: (M.y2 + M.y1) / 2 },
              x = 0;
            t = !1;
            for (var a = 0; a < f.length; a++)
              (x += Math.abs(f[a].y)),
                !t &&
                  void 0 !== f[a].indexLabel &&
                  null !== f[a].indexLabel &&
                  0 < f[a].indexLabel.toString().length &&
                  (t = !0),
                !t &&
                  void 0 !== f[a].label &&
                  null !== f[a].label &&
                  0 < f[a].label.toString().length &&
                  (t = !0);
            if (0 !== x) {
              t =
                t ||
                (void 0 !== v.indexLabel &&
                  null !== v.indexLabel &&
                  0 < v.indexLabel.toString().length);
              var S =
                "inside" !== v.indexLabelPlacement && t
                  ? (0.75 * Math.min(M.width, M.height)) / 2
                  : (0.92 * Math.min(M.width, M.height)) / 2;
              v.radius && (S = l(v.radius, S));
              var A =
                void 0 !== v.innerRadius && null !== v.innerRadius
                  ? l(v.innerRadius, S)
                  : 0.7 * S;
              (v.radius = S), "doughnut" === v.type && (v.innerRadius = A);
              var _ = Math.min(A / S, (S - 1) / S);
              (this.pieDoughnutClickHandler = function (t) {
                c.isAnimating ||
                  (!U(t.dataSeries.explodeOnClick) &&
                    !t.dataSeries.explodeOnClick) ||
                  (((t = t.dataPoint).exploded = !t.exploded),
                  1 < this.dataPoints.length &&
                    c._animator.animate(0, 500, function (t) {
                      e(t), o();
                    }));
              }),
                (function () {
                  if (v && f) {
                    for (
                      var t = 0, e = 0, i = 0, a = 0, s = 0;
                      s < f.length;
                      s++
                    ) {
                      var n = f[s],
                        o = v.dataPointIds[s];
                      (k[s].id = o),
                        (k[s].objectType = "dataPoint"),
                        (k[s].dataPointIndex = s),
                        (k[s].dataSeriesIndex = 0);
                      var r = k[s],
                        l = { percent: null, total: null },
                        h = null;
                      (l = c.getPercentAndTotal(v, n)),
                        (v.indexLabelFormatter || n.indexLabelFormatter) &&
                          (h = {
                            chart: c.options,
                            dataSeries: v,
                            dataPoint: n,
                            total: l.total,
                            percent: l.percent,
                          }),
                        (l = n.indexLabelFormatter
                          ? n.indexLabelFormatter(h)
                          : n.indexLabel
                          ? c.replaceKeywordsWithValue(n.indexLabel, n, v, s)
                          : v.indexLabelFormatter
                          ? v.indexLabelFormatter(h)
                          : v.indexLabel
                          ? c.replaceKeywordsWithValue(v.indexLabel, n, v, s)
                          : n.label
                          ? n.label
                          : ""),
                        ((c._eventManager.objectMap[o] = r).center = {
                          x: P.x,
                          y: P.y,
                        }),
                        (r.y = n.y),
                        (r.radius = S),
                        (r.percentInnerRadius = _),
                        (r.indexLabelText = l),
                        (r.indexLabelPlacement = v.indexLabelPlacement),
                        (r.indexLabelLineColor = n.indexLabelLineColor
                          ? n.indexLabelLineColor
                          : v.options.indexLabelLineColor
                          ? v.options.indexLabelLineColor
                          : n.color
                          ? n.color
                          : v._colorSet[s % v._colorSet.length]),
                        (r.indexLabelLineThickness = U(
                          n.indexLabelLineThickness
                        )
                          ? v.indexLabelLineThickness
                          : n.indexLabelLineThickness),
                        (r.indexLabelLineDashType = n.indexLabelLineDashType
                          ? n.indexLabelLineDashType
                          : v.indexLabelLineDashType),
                        (r.indexLabelFontColor = n.indexLabelFontColor
                          ? n.indexLabelFontColor
                          : v.indexLabelFontColor),
                        (r.indexLabelFontStyle = n.indexLabelFontStyle
                          ? n.indexLabelFontStyle
                          : v.indexLabelFontStyle),
                        (r.indexLabelFontWeight = n.indexLabelFontWeight
                          ? n.indexLabelFontWeight
                          : v.indexLabelFontWeight),
                        (r.indexLabelFontSize = U(n.indexLabelFontSize)
                          ? v.indexLabelFontSize
                          : n.indexLabelFontSize),
                        (r.indexLabelFontFamily = n.indexLabelFontFamily
                          ? n.indexLabelFontFamily
                          : v.indexLabelFontFamily),
                        (r.indexLabelBackgroundColor =
                          n.indexLabelBackgroundColor
                            ? n.indexLabelBackgroundColor
                            : v.options.indexLabelBackgroundColor
                            ? v.options.indexLabelBackgroundColor
                            : v.indexLabelBackgroundColor),
                        (r.indexLabelMaxWidth = n.indexLabelMaxWidth
                          ? n.indexLabelMaxWidth
                          : v.indexLabelMaxWidth
                          ? v.indexLabelMaxWidth
                          : 0.33 * M.width),
                        (r.indexLabelWrap =
                          void 0 !== n.indexLabelWrap
                            ? n.indexLabelWrap
                            : v.indexLabelWrap),
                        (r.startAngle =
                          0 === s
                            ? v.startAngle
                              ? (v.startAngle / 180) * Math.PI
                              : 0
                            : k[s - 1].endAngle),
                        (r.startAngle =
                          (r.startAngle + 2 * Math.PI) % (2 * Math.PI)),
                        (r.endAngle =
                          r.startAngle + ((2 * Math.PI) / x) * Math.abs(n.y)),
                        (n =
                          ((n = (r.endAngle + r.startAngle) / 2) +
                            2 * Math.PI) %
                          (2 * Math.PI)),
                        (r.midAngle = n),
                        r.midAngle > Math.PI / 2 - u &&
                        r.midAngle < Math.PI / 2 + u
                          ? ((0 === t || k[i].midAngle > r.midAngle) && (i = s),
                            t++)
                          : r.midAngle > (3 * Math.PI) / 2 - u &&
                            r.midAngle < (3 * Math.PI) / 2 + u &&
                            ((0 === e || k[a].midAngle > r.midAngle) && (a = s),
                            e++),
                        (r.hemisphere =
                          n > Math.PI / 2 && n <= (3 * Math.PI) / 2
                            ? "left"
                            : "right"),
                        (r.indexLabelTextBlock = new Q(c.plotArea.ctx, {
                          fontSize: r.indexLabelFontSize,
                          fontFamily: r.indexLabelFontFamily,
                          fontColor: r.indexLabelFontColor,
                          fontStyle: r.indexLabelFontStyle,
                          fontWeight: r.indexLabelFontWeight,
                          horizontalAlign: "left",
                          backgroundColor: r.indexLabelBackgroundColor,
                          maxWidth: r.indexLabelMaxWidth,
                          maxHeight: r.indexLabelWrap
                            ? 5 * r.indexLabelFontSize
                            : 1.5 * r.indexLabelFontSize,
                          text: r.indexLabelText,
                          padding: 0,
                          textBaseline: "top",
                        })),
                        r.indexLabelTextBlock.measureText();
                    }
                    for (o = n = 0, l = !1, s = 0; s < f.length; s++)
                      (r = k[(i + s) % f.length]),
                        1 < t &&
                          r.midAngle > Math.PI / 2 - u &&
                          r.midAngle < Math.PI / 2 + u &&
                          (n <= t / 2 && !l
                            ? ((r.hemisphere = "right"), n++)
                            : ((r.hemisphere = "left"), (l = !0)));
                    for (l = !1, s = 0; s < f.length; s++)
                      (r = k[(a + s) % f.length]),
                        1 < e &&
                          r.midAngle > (3 * Math.PI) / 2 - u &&
                          r.midAngle < (3 * Math.PI) / 2 + u &&
                          (o <= e / 2 && !l
                            ? ((r.hemisphere = "left"), o++)
                            : ((r.hemisphere = "right"), (l = !0)));
                  }
                })(),
                i(),
                i(),
                i(),
                i(),
                (this.disableToolTip = !0),
                this._animator.animate(
                  0,
                  this.animatedRender ? this.animationDuration : 0,
                  function (t) {
                    var e = c.plotArea.ctx;
                    for (
                      e.clearRect(M.x1, M.y1, M.width, M.height),
                        e.fillStyle = c.backgroundColor,
                        e.fillRect(M.x1, M.y1, M.width, M.height),
                        t = k[0].startAngle + 2 * Math.PI * t,
                        e = 0;
                      e < f.length;
                      e++
                    ) {
                      var i = 0 === e ? k[e].startAngle : a,
                        a = i + (k[e].endAngle - k[e].startAngle),
                        s = !1;
                      t < a && ((a = t), (s = !0));
                      var n = f[e].color
                        ? f[e].color
                        : v._colorSet[e % v._colorSet.length];
                      if (
                        (i < a &&
                          B(
                            c.plotArea.ctx,
                            k[e].center,
                            k[e].radius,
                            n,
                            v.type,
                            i,
                            a,
                            v.fillOpacity,
                            k[e].percentInnerRadius
                          ),
                        s)
                      )
                        break;
                    }
                    o();
                  },
                  function () {
                    (c.disableToolTip = !1),
                      c._animator.animate(
                        0,
                        c.animatedRender ? 500 : 0,
                        function (t) {
                          e(t), o();
                        }
                      );
                  }
                );
            }
          }
        };
        var $ = function (t, e, i, a) {
          void 0 === i && (i = 1),
            Math.round(e.y4 - e.y1) <= 0 ||
              (t.save(),
              (t.globalAlpha = i),
              t.beginPath(),
              t.moveTo(Math.round(e.x1), Math.round(e.y1)),
              t.lineTo(Math.round(e.x2), Math.round(e.y2)),
              t.lineTo(Math.round(e.x3), Math.round(e.y3)),
              t.lineTo(Math.round(e.x4), Math.round(e.y4)),
              "undefined" !== e.x5 &&
                (t.lineTo(Math.round(e.x5), Math.round(e.y5)),
                t.lineTo(Math.round(e.x6), Math.round(e.y6))),
              t.closePath(),
              (t.fillStyle = a || e.color),
              t.fill(),
              (t.globalAplha = 1),
              t.restore());
        };
        (r.prototype.renderFunnel = function (t) {
          function c() {
            var t, e, i, a;
            if ("inside" !== k.indexLabelPlacement)
              for (var s = 0; s < V.length; s++)
                0 == O[s].textBlock.text.length
                  ? (O[s].isDirty = !0)
                  : ((i =
                      void 0 !== (t = V[s]).x5
                        ? (t.y2 + t.y4) / 2
                        : (t.y2 + t.y3) / 2),
                    (e = k.reversed
                      ? void 0 !== t.x5 && h < i
                        ? y(i).x2 + 1
                        : (t.x2 + t.x3) / 2 + 1
                      : void 0 !== t.x5
                      ? i < h
                        ? y(i).x2 + 1
                        : (t.x4 + t.x3) / 2 + 1
                      : (t.x2 + t.x3) / 2 + 1),
                    (O[s].textBlock.x = e + B),
                    (O[s].textBlock.y = i - O[s].height / 2),
                    k.reversed
                      ? (O[s].textBlock.y + O[s].height > l + f &&
                          (O[s].textBlock.y = l + f - O[s].height),
                        O[s].textBlock.y < d - f && (O[s].textBlock.y = d - f))
                      : (O[s].textBlock.y < l - f && (O[s].textBlock.y = l - f),
                        O[s].textBlock.y + O[s].height > d + f &&
                          (O[s].textBlock.y = d + f - O[s].height)));
            else
              for (s = 0; s < V.length; s++)
                0 == O[s].textBlock.text.length
                  ? (O[s].isDirty = !0)
                  : ((e = (t = V[s]).height),
                    (i = O[s].height),
                    (a = O[s].width),
                    i <= e
                      ? ((e =
                          s != D
                            ? (t.x4 + t.x3) / 2 - a / 2
                            : (t.x5 + t.x4) / 2 - a / 2),
                        (i =
                          s != D
                            ? (t.y1 + t.y3) / 2 - i / 2
                            : (t.y1 + t.y4) / 2 - i / 2),
                        (O[s].textBlock.x = e),
                        (O[s].textBlock.y = i))
                      : (O[s].isDirty = !0));
          }
          function p(t, e) {
            return (
              (e < V.length ? O[e].textBlock.y : k.reversed ? l + f : d + f) -
              (t < 0
                ? k.reversed
                  ? d - f
                  : l - f
                : O[t].textBlock.y + O[t].height + Y)
            );
          }
          function i(a, s, t) {
            var e,
              i,
              n,
              o = [],
              r = f,
              l = [];
            if (
              (-1 !== s &&
                (0 <= N.indexOf(s)
                  ? ((i = N.indexOf(s)), N.splice(i, 1))
                  : (N.push(s),
                    (N = N.sort(function (t, e) {
                      return t - e;
                    })))),
              0 === N.length)
            )
              o = H;
            else {
              i =
                (f *
                  (1 != N.length || (0 != N[0] && N[0] != V.length - 1)
                    ? 2
                    : 1)) /
                (function () {
                  for (var t = 0, e = 0; e < V.length - 1; e++)
                    (0 <= N.indexOf(e) || 0 <= N.indexOf(e + 1)) && t++;
                  return t;
                })();
              for (var h = 0; h < V.length; h++) {
                if (1 == N.length && 0 == N[0]) {
                  if (0 === h) {
                    o.push(H[h]), (e = r);
                    continue;
                  }
                } else 0 === h && (e = -1 * r);
                o.push(H[h] + e),
                  (0 <= N.indexOf(h) ||
                    (h < V.length && 0 <= N.indexOf(h + 1))) &&
                    (e += i);
              }
            }
            n = (function () {
              for (var t = [], e = 0; e < V.length; e++) t.push(o[e] - V[e].y1);
              return t;
            })();
            new Date().getTime();
            var d = function (t) {
              for (var e, i, a = 0; a < V.length; a++)
                (e = n[a]),
                  (i = V[a]),
                  (newY = e * t),
                  void 0 === l[a] && (l[a] = 0),
                  l < 0 && (l *= -1),
                  (i.y1 += newY - l[a]),
                  (i.y2 += newY - l[a]),
                  (i.y3 += newY - l[a]),
                  (i.y4 += newY - l[a]),
                  i.y5 && ((i.y5 += newY - l[a]), (i.y6 += newY - l[a])),
                  (l[a] = newY);
            };
            a._animator.animate(
              0,
              t,
              function (t) {
                var e = a.plotArea.ctx || a.ctx;
                (R = !0),
                  e.clearRect(v.x1, v.y1, v.x2 - v.x1, v.y2 - v.y1),
                  (e.fillStyle = a.backgroundColor),
                  e.fillRect(v.x1, v.y1, v.width, v.height),
                  d(t, s);
                var i = {};
                for (
                  i.dataSeries = k,
                    i.dataPoint = k.reversed
                      ? k.dataPoints[w.length - 1 - s]
                      : k.dataPoints[s],
                    i.index = k.reversed ? w.length - 1 - s : s,
                    a.toolTip.highlightObjects([i]),
                    i = 0;
                  i < V.length;
                  i++
                )
                  $(e, V[i], k.fillOpacity);
                b(e),
                  T && ("inside" !== k.indexLabelPlacement ? u(e) : c(), g(e)),
                  1 <= t && (R = !1);
              },
              null,
              j.easing.easeOutQuart
            );
          }
          function u(t) {
            for (var e, i, a, s, n = 0; n < V.length; n++)
              (s = 1 == O[n].lineThickness % 2 ? 0.5 : 0),
                (e = y((i = (((V[n].y2 + V[n].y4) / 2) << 0) + s)).x2 - 1),
                (a = O[n].textBlock.x),
                (s = ((O[n].textBlock.y + O[n].height / 2) << 0) + s),
                O[n].isDirty ||
                  0 == O[n].lineThickness ||
                  ((t.strokeStyle = O[n].lineColor),
                  (t.lineWidth = O[n].lineThickness),
                  t.setLineDash &&
                    t.setLineDash(K(O[n].lineDashType, O[n].lineThickness)),
                  t.beginPath(),
                  t.moveTo(e, i),
                  t.lineTo(a, s),
                  t.stroke());
          }
          function x(t) {
            for (t -= 1; -1 <= t && -1 != t && O[t].isDirty; t--);
            return t;
          }
          function m(t) {
            for (t += 1; t <= V.length && t != V.length && O[t].isDirty; t++);
            return t;
          }
          function y(t) {
            for (var e, i = 0; i < w.length; i++)
              if (V[i].y1 < t && V[i].y4 > t) {
                e = V[i];
                break;
              }
            return e
              ? {
                  x1: (t =
                    e.y6 && t > e.y6
                      ? e.x3 + ((e.x4 - e.x3) / (e.y4 - e.y3)) * (t - e.y3)
                      : e.x2 + ((e.x3 - e.x2) / (e.y3 - e.y2)) * (t - e.y2)),
                  x2: t,
                }
              : -1;
          }
          function g(t) {
            for (var e = 0; e < V.length; e++)
              O[e].isDirty ||
                (t && (O[e].textBlock.ctx = t), O[e].textBlock.render(!0));
          }
          function b(t) {
            if (
              (M.plotArea.layoutManager.reset(),
              t.roundRect || G(t),
              M.title &&
                (M.title.dockInsidePlotArea ||
                  ("center" === M.title.horizontalAlign &&
                    "center" === M.title.verticalAlign)) &&
                ((M.title.ctx = t), M.title.render()),
              M.subtitles)
            )
              for (var e = 0; e < M.subtitles.length; e++) {
                var i = M.subtitles[e];
                (i.dockInsidePlotArea ||
                  ("center" === i.horizontalAlign &&
                    "center" === i.verticalAlign)) &&
                  ((M.subtitles.ctx = t), i.render());
              }
            M.legend &&
              (M.legend.dockInsidePlotArea ||
                ("center" === M.legend.horizontalAlign &&
                  "center" === M.legend.verticalAlign)) &&
              ((M.legend.ctx = t), M.legend.render()),
              J.fNg && J.fNg(M);
          }
          var M = this;
          if (!(t.dataSeriesIndexes.length <= 0)) {
            for (
              var k = this.data[t.dataSeriesIndexes[0]],
                w = k.dataPoints,
                v = this.plotArea,
                f = 0.025 * v.width,
                e = 0.01 * v.width,
                a = 0,
                s = v.height - 2 * f,
                n = Math.min(v.width - 2 * e, 2.8 * v.height),
                T = !1,
                o = 0;
              o < w.length;
              o++
            )
              !T &&
                void 0 !== w[o].indexLabel &&
                null !== w[o].indexLabel &&
                0 < w[o].indexLabel.toString().length &&
                (T = !0),
                !T &&
                  void 0 !== w[o].label &&
                  null !== w[o].label &&
                  0 < w[o].label.toString().length &&
                  (T = !0),
                ((!T && "function" == typeof k.indexLabelFormatter) ||
                  "function" == typeof w[o].indexLabelFormatter) &&
                  (T = !0);
            (T =
              T ||
              (void 0 !== k.indexLabel &&
                null !== k.indexLabel &&
                0 < k.indexLabel.toString().length)),
              ("inside" !== k.indexLabelPlacement && T) ||
                (e = (v.width - 0.75 * n) / 2);
            o = v.x1 + e;
            var C = v.x2 - e,
              P = v.y1 + f,
              S = v.y2 - f,
              A = t.targetCanvasCtx || this.plotArea.ctx || this.ctx;
            if (0 != k.length && k.dataPoints && k.visible && 0 !== w.length) {
              var _,
                r,
                B = (30 * (C - (t = (75 * n) / 100))) / 100;
              "funnel" === k.type
                ? ((_ = U(k.options.neckHeight) ? 0.35 * s : k.neckHeight),
                  (r = U(k.options.neckWidth) ? 0.25 * t : k.neckWidth),
                  (_ =
                    "string" == typeof _ && _.match(/%$/)
                      ? ((_ = parseInt(_)) * s) / 100
                      : parseInt(_)),
                  (r =
                    "string" == typeof r && r.match(/%$/)
                      ? ((r = parseInt(r)) * t) / 100
                      : parseInt(r)),
                  s < _ ? (_ = s) : _ <= 0 && (_ = 0),
                  t < r ? (r = t - 0.5) : r <= 0 && (r = 0))
                : "pyramid" === k.type &&
                  ((r = _ = 0), (k.reversed = !k.reversed));
              e = o + t / 2;
              var F = o,
                L = o + t,
                l = k.reversed ? S : P,
                I = e - r / 2,
                E = e + r / 2,
                h = k.reversed ? P + _ : S - _,
                d = k.reversed ? P : S;
              t = [];
              e = [];
              var D,
                V = [],
                z = ((n = []), P),
                W = (h - l) / (I - F),
                X = -W;
              if (
                -1 !==
                (o =
                  "area" === (k.valueRepresents ? k.valueRepresents : "height")
                    ? (function () {
                        var t,
                          e,
                          i = F,
                          a = L,
                          s = I,
                          n = E;
                        (t = P),
                          (e = S - _),
                          (headArea = ((e - t) * (a - i + (n - s))) / 2),
                          (headArea = Math.abs(headArea)),
                          (t = e - t),
                          (e = (s = E - I) * (e - S)),
                          (e = Math.abs(e)),
                          (e = headArea + e),
                          (n = []);
                        for (var o = 0, r = 0; r < w.length; r++) {
                          if (void 0 === w[r].y) return -1;
                          (w[r].y = "number" == typeof w[r].y ? w[r].y : 0),
                            (o += Math.abs(w[r].y));
                        }
                        if (0 === o) return -1;
                        var l,
                          h = (n[0] = 0),
                          d = 0,
                          c = ((a -= i), !1);
                        for (r = 0; r < w.length; r++)
                          (i = (Math.abs(w[r].y) * e) / o),
                            c
                              ? (h = 0 == Number(s.toFixed(3)) ? 0 : i / s)
                              : ((sqrt = W * W * a * a - 4 * Math.abs(W) * i),
                                sqrt < 0
                                  ? ((i -= h = ((a + (l = s)) * (t - d)) / 2),
                                    (d += h = t - d),
                                    (h += 0 == l ? 0 : i / l),
                                    (d += i / l),
                                    (c = !0))
                                  : ((l =
                                      a -
                                      (2 *
                                        (h =
                                          (Math.abs(W) * a - Math.sqrt(sqrt)) /
                                          2)) /
                                        Math.abs(W)),
                                    t < (d += h) &&
                                      ((i -= h =
                                        ((a + (l = s)) * (t - (d -= h))) / 2),
                                      (d += h = t - d),
                                      (h += i / l),
                                      (d += i / l),
                                      (c = !0)),
                                    (a = l))),
                            n.push(h);
                        return n;
                      })()
                    : (function () {
                        for (var t = 0, e = [], i = 0; i < w.length; i++) {
                          if (void 0 === w[i].y) return -1;
                          (w[i].y = "number" == typeof w[i].y ? w[i].y : 0),
                            (t += Math.abs(w[i].y));
                        }
                        if (0 === t) return -1;
                        for (i = e[0] = 0; i < w.length; i++)
                          e.push((Math.abs(w[i].y) * s) / t);
                        return e;
                      })())
              ) {
                if (k.reversed)
                  for (n.push(z), r = o.length - 1; 0 < r; r--)
                    (z += o[r]), n.push(z);
                else for (r = 0; r < o.length; r++) (z += o[r]), n.push(z);
                if (k.reversed)
                  for (r = 0; r < o.length; r++)
                    n[r] < h
                      ? (t.push(I), e.push(E), (D = r))
                      : (t.push((n[r] - l + W * F) / W),
                        e.push((n[r] - l + X * L) / X));
                else
                  for (r = 0; r < o.length; r++)
                    n[r] < h
                      ? (t.push((n[r] - l + W * F) / W),
                        e.push((n[r] - l + X * L) / X),
                        (D = r))
                      : (t.push(I), e.push(E));
                for (r = 0; r < o.length - 1; r++)
                  (z = k.reversed
                    ? w[w.length - 1 - r].color
                      ? w[w.length - 1 - r].color
                      : k._colorSet[(w.length - 1 - r) % k._colorSet.length]
                    : w[r].color
                    ? w[r].color
                    : k._colorSet[r % k._colorSet.length]),
                    r === D
                      ? V.push({
                          x1: t[r],
                          y1: n[r],
                          x2: e[r],
                          y2: n[r],
                          x3: E,
                          y3: h,
                          x4: e[r + 1],
                          y4: n[r + 1],
                          x5: t[r + 1],
                          y5: n[r + 1],
                          x6: I,
                          y6: h,
                          id: r,
                          height: n[r + 1] - n[r],
                          color: z,
                        })
                      : V.push({
                          x1: t[r],
                          y1: n[r],
                          x2: e[r],
                          y2: n[r],
                          x3: e[r + 1],
                          y3: n[r + 1],
                          x4: t[r + 1],
                          y4: n[r + 1],
                          id: r,
                          height: n[r + 1] - n[r],
                          color: z,
                        });
                var Y = 2,
                  O = [],
                  R = !1,
                  N = [],
                  H = [];
                o = !1;
                for (t = t = 0, q(N), r = 0; r < w.length; r++)
                  w[r].exploded &&
                    ((o = !0),
                    k.reversed ? N.push(w.length - 1 - r) : N.push(r));
                if (
                  (A.clearRect(v.x1, v.y1, v.width, v.height),
                  (A.fillStyle = M.backgroundColor),
                  A.fillRect(v.x1, v.y1, v.width, v.height),
                  T &&
                    k.visible &&
                    ((function () {
                      if (k && w) {
                        for (
                          var t,
                            e,
                            i,
                            a,
                            s,
                            n,
                            o,
                            r,
                            l,
                            h,
                            d,
                            c,
                            p,
                            u,
                            x = [],
                            m = [],
                            g = { percent: null, total: null },
                            b = null,
                            v = 0;
                          v < w.length;
                          v++
                        )
                          (u =
                            y(
                              (u =
                                void 0 !== (u = V[v]).x5
                                  ? (u.y2 + u.y4) / 2
                                  : (u.y2 + u.y3) / 2)
                            ).x2 + 1),
                            (x[v] = C - u - B);
                        (u = 0.5 * B), (v = 0);
                        for (
                          var f = w.length - 1;
                          v < w.length || 0 <= f;
                          v++, f--
                        )
                          (t = (e = k.reversed ? w[f] : w[v]).color
                            ? e.color
                            : k.reversed
                            ? k._colorSet[
                                (w.length - 1 - v) % k._colorSet.length
                              ]
                            : k._colorSet[v % k._colorSet.length]),
                            (i =
                              e.indexLabelPlacement ||
                              k.indexLabelPlacement ||
                              "outside"),
                            (a =
                              e.indexLabelBackgroundColor ||
                              k.indexLabelBackgroundColor ||
                              (Z ? "transparent" : null)),
                            (s =
                              e.indexLabelFontColor ||
                              k.indexLabelFontColor ||
                              "#979797"),
                            (n = U(e.indexLabelFontSize)
                              ? k.indexLabelFontSize
                              : e.indexLabelFontSize),
                            (o =
                              e.indexLabelFontStyle ||
                              k.indexLabelFontStyle ||
                              "normal"),
                            (r =
                              e.indexLabelFontFamily ||
                              k.indexLabelFontFamily ||
                              "arial"),
                            (l =
                              e.indexLabelFontWeight ||
                              k.indexLabelFontWeight ||
                              "normal"),
                            (t =
                              e.indexLabelLineColor ||
                              k.options.indexLabelLineColor ||
                              t),
                            (h =
                              "number" == typeof e.indexLabelLineThickness
                                ? e.indexLabelLineThickness
                                : "number" == typeof k.indexLabelLineThickness
                                ? k.indexLabelLineThickness
                                : 2),
                            (d =
                              e.indexLabelLineDashType ||
                              k.indexLabelLineDashType ||
                              "solid"),
                            (c =
                              void 0 !== e.indexLabelWrap
                                ? e.indexLabelWrap
                                : void 0 === k.indexLabelWrap ||
                                  k.indexLabelWrap),
                            (p = k.dataPointIds[v]),
                            (M._eventManager.objectMap[p] = {
                              id: p,
                              objectType: "dataPoint",
                              dataPointIndex: v,
                              dataSeriesIndex: 0,
                              funnelSection:
                                V[k.reversed ? w.length - 1 - v : v],
                            }),
                            "inside" === k.indexLabelPlacement &&
                              ((x[v] =
                                v !== D
                                  ? k.reversed
                                    ? V[v].x2 - V[v].x1
                                    : V[v].x3 - V[v].x4
                                  : V[v].x3 - V[v].x6),
                              x[v] < 20 &&
                                ((x[v] =
                                  v !== D && k.reversed
                                    ? V[v].x3 - V[v].x4
                                    : V[v].x2 - V[v].x1),
                                (x[v] /= 2))),
                            ((p = e.indexLabelMaxWidth
                              ? e.indexLabelMaxWidth
                              : k.options.indexLabelMaxWidth
                              ? k.indexLabelMaxWidth
                              : x[v]) > x[v] ||
                              p < 0) &&
                              (p = x[v]),
                            (m[v] =
                              "inside" === k.indexLabelPlacement &&
                              V[v].height),
                            (g = M.getPercentAndTotal(k, e)),
                            (k.indexLabelFormatter || e.indexLabelFormatter) &&
                              (b = {
                                chart: M.options,
                                dataSeries: k,
                                dataPoint: e,
                                total: g.total,
                                percent: g.percent,
                              }),
                            (e = e.indexLabelFormatter
                              ? e.indexLabelFormatter(b)
                              : e.indexLabel
                              ? M.replaceKeywordsWithValue(
                                  e.indexLabel,
                                  e,
                                  k,
                                  v
                                )
                              : k.indexLabelFormatter
                              ? k.indexLabelFormatter(b)
                              : k.indexLabel
                              ? M.replaceKeywordsWithValue(
                                  k.indexLabel,
                                  e,
                                  k,
                                  v
                                )
                              : e.label
                              ? e.label
                              : ""),
                            h <= 0 && (h = 0),
                            p < 1e3 && 1e3 - p < u && (p += 1e3 - p),
                            A.roundRect || G(A),
                            (i = new Q(A, {
                              fontSize: n,
                              fontFamily: r,
                              fontColor: s,
                              fontStyle: o,
                              fontWeight: l,
                              horizontalAlign: i,
                              backgroundColor: a,
                              maxWidth: p,
                              maxHeight:
                                !1 === m[v]
                                  ? c
                                    ? 4.28571429 * n
                                    : 1.5 * n
                                  : m[v],
                              text: e,
                              padding: Y,
                            })).measureText(),
                            O.push({
                              textBlock: i,
                              id: k.reversed ? f : v,
                              isDirty: !1,
                              lineColor: t,
                              lineThickness: h,
                              lineDashType: d,
                              height:
                                i.height < i.maxHeight ? i.height : i.maxHeight,
                              width:
                                i.width < i.maxWidth ? i.width : i.maxWidth,
                            });
                      }
                    })(),
                    c(),
                    (function () {
                      var t,
                        e,
                        i,
                        a,
                        s,
                        n = [];
                      (s = !1), (i = 0);
                      for (
                        var o = C - L - B / 2,
                          r =
                            ((o = k.options.indexLabelMaxWidth
                              ? k.indexLabelMaxWidth > o
                                ? o
                                : k.indexLabelMaxWidth
                              : o),
                            O.length - 1);
                        0 <= r;
                        r--
                      )
                        (dataPoint = w[O[r].id]),
                          (a = (i = O[r]).textBlock),
                          (e = (t = m(r) < V.length ? O[m(r)] : null)
                            ? t.textBlock
                            : null),
                          (i = i.height),
                          t && a.y + i + Y > e.y && (s = !0),
                          (o < (i = dataPoint.indexLabelMaxWidth || o) ||
                            i < 0) &&
                            (i = o),
                          n.push(i);
                      if (s)
                        for (r = O.length - 1; 0 <= r; r--)
                          (t = V[r]),
                            (O[r].textBlock.maxWidth = n[n.length - (r + 1)]),
                            O[r].textBlock.measureText(),
                            (O[r].textBlock.x = C - o),
                            (i =
                              O[r].textBlock.height < O[r].textBlock.maxHeight
                                ? O[r].textBlock.height
                                : O[r].textBlock.maxHeight),
                            (s =
                              O[r].textBlock.width < O[r].textBlock.maxWidth
                                ? O[r].textBlock.width
                                : O[r].textBlock.maxWidth),
                            (O[r].height = i),
                            (O[r].width = s),
                            (i =
                              void 0 !== t.x5
                                ? (t.y2 + t.y4) / 2
                                : (t.y2 + t.y3) / 2),
                            (O[r].textBlock.y = i - O[r].height / 2),
                            k.reversed
                              ? (O[r].textBlock.y + O[r].height > l + f &&
                                  (O[r].textBlock.y = l + f - O[r].height),
                                O[r].textBlock.y < d - f &&
                                  (O[r].textBlock.y = d - f))
                              : (O[r].textBlock.y < l - f &&
                                  (O[r].textBlock.y = l - f),
                                O[r].textBlock.y + O[r].height > d + f &&
                                  (O[r].textBlock.y = d + f - O[r].height));
                    })(),
                    "inside" !== k.indexLabelPlacement))
                ) {
                  for (
                    (function () {
                      function n(t, e) {
                        var i;
                        if (t < 0 || t >= O.length) return 0;
                        var a,
                          s = O[t].textBlock;
                        return e < 0
                          ? (e *= -1) <= (i = p((a = x(t)), t))
                            ? ((s.y -= e), e)
                            : (0 == t
                                ? 0 < i && (s.y -= i)
                                : 0 < (i += n(a, -(e - i))) && (s.y -= i),
                              i)
                          : e <= (i = p(t, (a = m(t))))
                          ? ((s.y += e), e)
                          : (t == V.length - 1
                              ? 0 < i && (s.y += i)
                              : 0 < (i += n(a, e - i)) && (s.y += i),
                            i);
                      }
                      function t() {
                        var t,
                          e,
                          i,
                          a,
                          s,
                          n = 0;
                        (a = (S - P + 2 * f) / d), (s = d);
                        for (var o, r = 1; r < s; r++) {
                          i = r * a;
                          for (var l = O.length - 1; 0 <= l; l--)
                            !O[l].isDirty &&
                              O[l].textBlock.y < i &&
                              O[l].textBlock.y + O[l].height > i &&
                              !((o = m(l)) >= O.length - 1) &&
                              O[l].textBlock.y + O[l].height + Y >
                                O[o].textBlock.y &&
                              (O[l].textBlock.y =
                                O[l].textBlock.y + O[l].height - i >
                                i - O[l].textBlock.y
                                  ? i + 1
                                  : i - O[l].height - 1);
                        }
                        for (o = V.length - 1; 0 < o; o--)
                          if (!O[o].isDirty) {
                            if ((i = x(o)) < 0 && O[(i = 0)].isDirty) break;
                            if (
                              O[o].textBlock.y <
                              O[i].textBlock.y + O[i].height
                            ) {
                              for (
                                e = e || o, a = o, s = 0;
                                O[a].textBlock.y <
                                O[i].textBlock.y + O[i].height + Y;

                              ) {
                                if (
                                  ((t = t || O[a].textBlock.y + O[a].height),
                                  (s += O[a].height),
                                  (s += Y),
                                  (a = i) <= 0)
                                ) {
                                  s += O[(a = 0)].height;
                                  break;
                                }
                                if ((i = x(a)) < 0) {
                                  s += O[(a = 0)].height;
                                  break;
                                }
                              }
                              if (a != o) {
                                n = h(
                                  (t = s - (t -= n = O[a].textBlock.y)),
                                  e,
                                  a
                                );
                                break;
                              }
                            }
                          }
                        return n;
                      }
                      function h(t, e, i) {
                        var a = [],
                          s = 0,
                          n = 0;
                        for (t = Math.abs(t); i <= e; i++) a.push(V[i]);
                        for (
                          a.sort(function (t, e) {
                            return t.height - e.height;
                          }),
                            i = 0;
                          i < a.length && ((e = a[i]), s < t);
                          i++
                        )
                          n++,
                            (s += O[e.id].height + Y),
                            (O[e.id].textBlock.text = ""),
                            (O[e.id].indexLabelText = ""),
                            (O[e.id].isDirty = !0),
                            O[e.id].textBlock.measureText();
                        return n;
                      }
                      for (var e, i, a, s, o, r, d = 1, l = 0; l < 2 * d; l++) {
                        for (
                          var c = O.length - 1;
                          0 <= c &&
                          ((previousTextBlock = (previousLabel =
                            0 <= x(c) ? O[x(c)] : null)
                            ? previousLabel.textBlock
                            : null),
                          (s = (a = O[c]).textBlock),
                          (r = (o = m(c) < V.length ? O[m(c)] : null)
                            ? o.textBlock
                            : null),
                          (e = +a.height.toFixed(6)),
                          (i = +s.y.toFixed(6)),
                          !(
                            !a.isDirty &&
                            o &&
                            i + e + Y > +r.y.toFixed(6) &&
                            (i = n(c, -(e = s.y + e + Y - r.y))) < e &&
                            (0 < i && (e -= i), (i = n(m(c), e)) != e)
                          ));
                          c--
                        );
                        t();
                      }
                    })(),
                      r = 0;
                    r < w.length;
                    r++
                  )
                    O[r].isDirty ||
                      ((t = O[r].textBlock.x + O[r].width),
                      (t = (C - t) / 2),
                      0 == r && (a = t),
                      t < a && (a = t));
                  for (r = 0; r < V.length; r++)
                    (V[r].x1 += a),
                      (V[r].x2 += a),
                      (V[r].x3 += a),
                      (V[r].x4 += a),
                      V[r].x5 && ((V[r].x5 += a), (V[r].x6 += a)),
                      (O[r].textBlock.x += a);
                }
                for (r = 0; r < V.length; r++)
                  (a = V[r]), $(A, a, k.fillOpacity), H.push(a.y1);
                if (
                  (b(A),
                  T &&
                    k.visible &&
                    ("inside" === k.indexLabelPlacement ||
                      M.animationEnabled ||
                      u(A),
                    M.animationEnabled || g()),
                  !T)
                )
                  for (r = 0; r < w.length; r++)
                    (t = {
                      id: (a = k.dataPointIds[r]),
                      objectType: "dataPoint",
                      dataPointIndex: r,
                      dataSeriesIndex: 0,
                      funnelSection: V[k.reversed ? w.length - 1 - r : r],
                    }),
                      (M._eventManager.objectMap[a] = t);
                return (
                  !M.animationEnabled && o
                    ? i(M, -1, 0)
                    : M.animationEnabled && !M.animatedRender && i(M, -1, 0),
                  (this.funnelPyramidClickHandler = function (t) {
                    var e = -1;
                    !R &&
                      !M.isAnimating &&
                      (U(t.dataSeries.explodeOnClick) ||
                        t.dataSeries.explodeOnClick) &&
                      0 <=
                        (e = k.reversed
                          ? w.length - 1 - t.dataPointIndex
                          : t.dataPointIndex) &&
                      ((t = e),
                      ("funnel" !== k.type && "pyramid" !== k.type) ||
                        (k.reversed
                          ? (w[w.length - 1 - t].exploded =
                              !w[w.length - 1 - t].exploded)
                          : (w[t].exploded = !w[t].exploded)),
                      i(M, e, 500));
                  }),
                  {
                    source: A,
                    dest: this.plotArea.ctx,
                    animationCallback: function (t, e) {
                      j.fadeInAnimation(t, e),
                        1 <= t && (i(M, -1, 500), b(M.plotArea.ctx || M.ctx));
                    },
                    easingFunction: j.easing.easeInQuad,
                    animationBase: 0,
                  }
                );
              }
            }
          }
        }),
          (r.prototype.requestAnimFrame =
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (t) {
              window.setTimeout(t, 1e3 / 60);
            }),
          (r.prototype.cancelRequestAnimFrame =
            window.cancelAnimationFrame ||
            window.webkitCancelRequestAnimationFrame ||
            window.mozCancelRequestAnimationFrame ||
            window.oCancelRequestAnimationFrame ||
            window.msCancelRequestAnimationFrame ||
            clearTimeout),
          (r.prototype.set = function (t, e, i) {
            (i = void 0 === i || i),
              "options" === t
                ? ((this.options = e), i && this.render())
                : r.base.set.call(this, t, e, i);
          }),
          (r.prototype.exportChart = function (t) {
            var e = (t = void 0 === t ? {} : t).format ? t.format : "png",
              i = t.fileName ? t.fileName : this.exportFileName;
            if (t.toDataURL) return this.canvas.toDataURL("image/" + e);
            s(this.canvas, e, i);
          }),
          (r.prototype.print = function () {
            var t = this.exportChart({ toDataURL: !0 }),
              e = document.createElement("iframe");
            e.setAttribute("class", "canvasjs-chart-print-frame"),
              e.setAttribute(
                "style",
                "position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;"
              ),
              (e.style.height = this.height + "px"),
              this._canvasJSContainer.appendChild(e);
            var i = this,
              a =
                e.contentWindow ||
                e.contentDocument.document ||
                e.contentDocument;
            a.document.open(),
              a.document.write(
                '<!DOCTYPE HTML>\n<html><body style="margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;"><img src="' +
                  t +
                  '"/><body/></html>'
              ),
              a.document.close(),
              setTimeout(function () {
                a.focus(),
                  a.print(),
                  setTimeout(function () {
                    i._canvasJSContainer.removeChild(e);
                  }, 1e3);
              }, 500);
          }),
          (r.prototype.getPercentAndTotal = function (t, e) {
            var a = null,
              s = null,
              n = null;
            if (0 <= t.type.indexOf("stacked"))
              (s = 0),
                (a = e.x.getTime ? e.x.getTime() : e.x) in t.plotUnit.yTotals &&
                  ((s = t.plotUnit.yTotals[a]),
                  (n = isNaN(e.y) ? 0 : (e.y / s) * 100));
            else if (
              "pie" === t.type ||
              "doughnut" === t.type ||
              "funnel" === t.type ||
              "pyramid" === t.type
            ) {
              for (i = s = 0; i < t.dataPoints.length; i++)
                isNaN(t.dataPoints[i].y) || (s += t.dataPoints[i].y);
              n = isNaN(e.y) ? 0 : (e.y / s) * 100;
            }
            return { percent: n, total: s };
          }),
          (r.prototype.replaceKeywordsWithValue = function (t, a, s, n, o) {
            var r = this;
            if (
              ((o = void 0 === o ? 0 : o),
              (0 <= s.type.indexOf("stacked") ||
                "pie" === s.type ||
                "doughnut" === s.type ||
                "funnel" === s.type ||
                "pyramid" === s.type) &&
                (0 <= t.indexOf("#percent") || 0 <= t.indexOf("#total")))
            ) {
              var e = "#percent",
                i = "#total",
                l = this.getPercentAndTotal(s, a);
              (i = isNaN(l.total) ? i : l.total),
                (e = isNaN(l.percent) ? e : l.percent);
              do {
                if (((l = ""), s.percentFormatString))
                  l = s.percentFormatString;
                else {
                  l = "#,##0.";
                  var h = Math.max(
                    Math.ceil(Math.log(1 / Math.abs(e)) / Math.LN10),
                    2
                  );
                  (!isNaN(h) && isFinite(h)) || (h = 2);
                  for (var d = 0; d < h; d++) l += "#";
                  s.percentFormatString = l;
                }
                t = (t = t.replace(
                  "#percent",
                  at(e, l, r._cultureInfo)
                )).replace(
                  "#total",
                  at(
                    i,
                    s.yValueFormatString
                      ? s.yValueFormatString
                      : "#,##0.########",
                    r._cultureInfo
                  )
                );
              } while (0 <= t.indexOf("#percent") || 0 <= t.indexOf("#total"));
            }
            return t.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, function (t) {
              if (
                ('"' === t[0] && '"' === t[t.length - 1]) ||
                ("'" === t[0] && "'" === t[t.length - 1])
              )
                return t.slice(1, t.length - 1);
              t = (t = g(t.slice(1, t.length - 1))).replace("#index", o);
              var e = null;
              try {
                var i = t.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
                i && 0 < i.length && ((e = g(i[2])), (t = g(i[1])));
              } catch (t) {}
              if (((i = null), "color" === t))
                return "waterfall" === s.type
                  ? a.color
                    ? a.color
                    : 0 < a.y
                    ? s.risingColor
                    : s.fallingColor
                  : "error" === s.type
                  ? s.color
                    ? s.color
                    : s._colorSet[e % s._colorSet.length]
                  : a.color
                  ? a.color
                  : s.color
                  ? s.color
                  : s._colorSet[n % s._colorSet.length];
              if (a.hasOwnProperty(t)) i = a;
              else {
                if (!s.hasOwnProperty(t)) return "";
                i = s;
              }
              return (
                (i = i[t]),
                null !== e && (i = i[e]),
                "x" !== t
                  ? "y" === t
                    ? at(
                        i,
                        a.yValueFormatString
                          ? a.yValueFormatString
                          : s.yValueFormatString
                          ? s.yValueFormatString
                          : (s.yValueFormatString = "#,##0.########"),
                        r._cultureInfo
                      )
                    : "z" === t
                    ? at(
                        i,
                        a.zValueFormatString
                          ? a.zValueFormatString
                          : s.zValueFormatString
                          ? s.zValueFormatString
                          : (s.zValueFormatString = "#,##0.########"),
                        r._cultureInfo
                      )
                    : i
                  : "dateTime" === s.axisX.valueType ||
                    "dateTime" === s.xValueType ||
                    (a.x && a.x.getTime)
                  ? r.plotInfo.plotTypes[0].plotUnits[0].axisX &&
                    !r.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic
                    ? it(
                        i,
                        a.xValueFormatString
                          ? a.xValueFormatString
                          : s.xValueFormatString
                          ? s.xValueFormatString
                          : (s.xValueFormatString =
                              r.axisX && r.axisX.autoValueFormatString
                                ? r.axisX.autoValueFormatString
                                : "DD MMM YY"),
                        r._cultureInfo
                      )
                    : void 0
                  : at(
                      i,
                      a.xValueFormatString
                        ? a.xValueFormatString
                        : s.xValueFormatString
                        ? s.xValueFormatString
                        : (s.xValueFormatString = "#,##0.########"),
                      r._cultureInfo
                    )
              );
            });
          }),
          t(p, L),
          (p.prototype.render = function () {
            var t = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,
              e = t.layoutManager.getFreeSpace(),
              i = null,
              a = 0,
              s = 0,
              n = 0,
              o = 0,
              r = (this.markerMargin =
                this.chart.options.legend &&
                !U(this.chart.options.legend.markerMargin)
                  ? this.chart.options.legend.markerMargin
                  : 0.3 * this.fontSize);
            this.height = 0;
            var l = [],
              h = [];
            "top" === this.verticalAlign || "bottom" === this.verticalAlign
              ? ((this.orientation = "horizontal"),
                (i = this.verticalAlign),
                (n = this.maxWidth =
                  null !== this.maxWidth ? this.maxWidth : e.width),
                (o = this.maxHeight =
                  null !== this.maxHeight ? this.maxHeight : 0.5 * e.height))
              : "center" === this.verticalAlign &&
                ((this.orientation = "vertical"),
                (i = this.horizontalAlign),
                (n = this.maxWidth =
                  null !== this.maxWidth ? this.maxWidth : 0.5 * e.width),
                (o = this.maxHeight =
                  null !== this.maxHeight ? this.maxHeight : e.height));
            for (var d = [], c = 0; c < this.dataSeries.length; c++) {
              var p = this.dataSeries[c];
              if (p.dataPoints && p.dataPoints.length)
                if (
                  "pie" !== p.type &&
                  "doughnut" !== p.type &&
                  "funnel" !== p.type &&
                  "pyramid" !== p.type
                ) {
                  var u = (p.legendMarkerType = p.legendMarkerType
                      ? p.legendMarkerType
                      : ("line" !== p.type &&
                          "stepLine" !== p.type &&
                          "spline" !== p.type &&
                          "scatter" !== p.type &&
                          "bubble" !== p.type) ||
                        !p.markerType
                      ? "error" === p.type && p._linkedSeries
                        ? p._linkedSeries.legendMarkerType
                          ? p._linkedSeries.legendMarkerType
                          : T.getDefaultLegendMarker(p._linkedSeries.type)
                        : T.getDefaultLegendMarker(p.type)
                      : p.markerType),
                    x = p.legendText
                      ? p.legendText
                      : this.itemTextFormatter
                      ? this.itemTextFormatter({
                          chart: this.chart,
                          legend: this.options,
                          dataSeries: p,
                          dataPoint: null,
                        })
                      : p.name,
                    m = (p.legendMarkerColor = p.legendMarkerColor
                      ? p.legendMarkerColor
                      : p.markerColor
                      ? p.markerColor
                      : "error" === p.type
                      ? U(p.whiskerColor)
                        ? p._colorSet[0]
                        : p.whiskerColor
                      : p._colorSet[0]),
                    g =
                      p.markerSize ||
                      ("line" !== p.type &&
                        "stepLine" !== p.type &&
                        "spline" !== p.type)
                        ? 0.75 * this.lineHeight
                        : 0,
                    b = p.legendMarkerBorderColor
                      ? p.legendMarkerBorderColor
                      : p.markerBorderColor,
                    v = p.legendMarkerBorderThickness
                      ? p.legendMarkerBorderThickness
                      : p.markerBorderThickness
                      ? Math.max(1, Math.round(0.2 * g))
                      : 0;
                  "error" === p.type && d.push(m),
                    (u = {
                      markerType: u,
                      markerColor: m,
                      text: (x = this.chart.replaceKeywordsWithValue(
                        x,
                        p.dataPoints[0],
                        p,
                        c
                      )),
                      textBlock: null,
                      chartType: p.type,
                      markerSize: g,
                      lineColor: p._colorSet[0],
                      dataSeriesIndex: p.index,
                      dataPointIndex: null,
                      markerBorderColor: b,
                      markerBorderThickness: v,
                    }),
                    l.push(u);
                } else
                  for (var f = 0; f < p.dataPoints.length; f++) {
                    var y = p.dataPoints[f];
                    (u = y.legendMarkerType
                      ? y.legendMarkerType
                      : p.legendMarkerType
                      ? p.legendMarkerType
                      : T.getDefaultLegendMarker(p.type)),
                      (x = y.legendText
                        ? y.legendText
                        : p.legendText
                        ? p.legendText
                        : this.itemTextFormatter
                        ? this.itemTextFormatter({
                            chart: this.chart,
                            legend: this.options,
                            dataSeries: p,
                            dataPoint: y,
                          })
                        : y.name
                        ? y.name
                        : "DataPoint: " + (f + 1)),
                      (m = y.legendMarkerColor
                        ? y.legendMarkerColor
                        : p.legendMarkerColor
                        ? p.legendMarkerColor
                        : y.color
                        ? y.color
                        : p.color
                        ? p.color
                        : p._colorSet[f % p._colorSet.length]),
                      (g = 0.75 * this.lineHeight),
                      (b = y.legendMarkerBorderColor
                        ? y.legendMarkerBorderColor
                        : p.legendMarkerBorderColor
                        ? p.legendMarkerBorderColor
                        : y.markerBorderColor
                        ? y.markerBorderColor
                        : p.markerBorderColor),
                      (v = y.legendMarkerBorderThickness
                        ? y.legendMarkerBorderThickness
                        : p.legendMarkerBorderThickness
                        ? p.legendMarkerBorderThickness
                        : y.markerBorderThickness || p.markerBorderThickness
                        ? Math.max(1, Math.round(0.2 * g))
                        : 0),
                      (u = {
                        markerType: u,
                        markerColor: m,
                        text: (x = this.chart.replaceKeywordsWithValue(
                          x,
                          y,
                          p,
                          f
                        )),
                        textBlock: null,
                        chartType: p.type,
                        markerSize: g,
                        dataSeriesIndex: c,
                        dataPointIndex: f,
                        markerBorderColor: b,
                        markerBorderThickness: v,
                      });
                    (y.showInLegend ||
                      (p.showInLegend && !1 !== y.showInLegend)) &&
                      l.push(u);
                  }
            }
            if ((!0 === this.reversed && l.reverse(), 0 < l.length)) {
              for (
                x = f = y = v = 0,
                  y =
                    (p = null) !== this.itemWidth
                      ? null !== this.itemMaxWidth
                        ? Math.min(this.itemWidth, this.itemMaxWidth, n)
                        : (this.itemMaxWidth = Math.min(this.itemWidth, n))
                      : null !== this.itemMaxWidth
                      ? Math.min(this.itemMaxWidth, n)
                      : (this.itemMaxWidth = n),
                  y -= (g = 0 === g ? 0.75 * this.lineHeight : g) + r,
                  c = 0;
                c < l.length;
                c++
              )
                (m = y),
                  ("line" !== (u = l[c]).chartType &&
                    "spline" !== u.chartType &&
                    "stepLine" !== u.chartType) ||
                    (m -= 0.2 * this.lineHeight),
                  o <= 0 ||
                    void 0 === o ||
                    m <= 0 ||
                    void 0 === m ||
                    ("horizontal" === this.orientation
                      ? ((u.textBlock = new Q(this.ctx, {
                          x: 0,
                          y: 0,
                          maxWidth: m,
                          maxHeight: this.itemWrap ? o : this.lineHeight,
                          angle: 0,
                          text: u.text,
                          horizontalAlign: "left",
                          fontSize: this.fontSize,
                          fontFamily: this.fontFamily,
                          fontWeight: this.fontWeight,
                          fontColor: this.fontColor,
                          fontStyle: this.fontStyle,
                          textBaseline: "middle",
                        })),
                        u.textBlock.measureText(),
                        null !== this.itemWidth &&
                          (u.textBlock.width =
                            this.itemWidth -
                            (g +
                              r +
                              ("line" === u.chartType ||
                              "spline" === u.chartType ||
                              "stepLine" === u.chartType
                                ? 0.2 * this.lineHeight
                                : 0))),
                        (!p ||
                          p.width +
                            Math.round(
                              u.textBlock.width +
                                g +
                                r +
                                (0 === p.width ? 0 : this.horizontalSpacing) +
                                ("line" === u.chartType ||
                                "spline" === u.chartType ||
                                "stepLine" === u.chartType
                                  ? 0.2 * this.lineHeight
                                  : 0)
                            ) >
                            n) &&
                          ((p = { items: [], width: 0 }),
                          h.push(p),
                          (this.height += f),
                          (f = 0)),
                        (f = Math.max(f, u.textBlock.height)))
                      : ((u.textBlock = new Q(this.ctx, {
                          x: 0,
                          y: 0,
                          maxWidth: y,
                          maxHeight:
                            !0 === this.itemWrap ? o : 1.5 * this.fontSize,
                          angle: 0,
                          text: u.text,
                          horizontalAlign: "left",
                          fontSize: this.fontSize,
                          fontFamily: this.fontFamily,
                          fontWeight: this.fontWeight,
                          fontColor: this.fontColor,
                          fontStyle: this.fontStyle,
                          textBaseline: "middle",
                        })),
                        u.textBlock.measureText(),
                        null !== this.itemWidth &&
                          (u.textBlock.width =
                            this.itemWidth -
                            (g +
                              r +
                              ("line" === u.chartType ||
                              "spline" === u.chartType ||
                              "stepLine" === u.chartType
                                ? 0.2 * this.lineHeight
                                : 0))),
                        this.height < o - this.lineHeight
                          ? ((p = { items: [], width: 0 }), h.push(p))
                          : ((p = h[v]), (v = (v + 1) % h.length)),
                        (this.height += u.textBlock.height)),
                    (u.textBlock.x = p.width),
                    (u.textBlock.y = 0),
                    (p.width += Math.round(
                      u.textBlock.width +
                        g +
                        r +
                        (0 === p.width ? 0 : this.horizontalSpacing) +
                        ("line" === u.chartType ||
                        "spline" === u.chartType ||
                        "stepLine" === u.chartType
                          ? 0.2 * this.lineHeight
                          : 0)
                    )),
                    p.items.push(u),
                    (this.width = Math.max(p.width, this.width)),
                    (x =
                      u.textBlock.width +
                      (g +
                        r +
                        ("line" === u.chartType ||
                        "spline" === u.chartType ||
                        "stepLine" === u.chartType
                          ? 0.2 * this.lineHeight
                          : 0))));
              (this.itemWidth = x),
                (this.height =
                  !1 === this.itemWrap
                    ? h.length * this.lineHeight
                    : this.height + f),
                (this.height = Math.min(o, this.height)),
                (this.width = Math.min(n, this.width));
            }
            for (
              "top" === this.verticalAlign
                ? ((s =
                    "left" === this.horizontalAlign
                      ? e.x1
                      : "right" === this.horizontalAlign
                      ? e.x2 - this.width
                      : e.x1 + e.width / 2 - this.width / 2),
                  (a = e.y1))
                : "center" === this.verticalAlign
                ? ((s =
                    "left" === this.horizontalAlign
                      ? e.x1
                      : "right" === this.horizontalAlign
                      ? e.x2 - this.width
                      : e.x1 + e.width / 2 - this.width / 2),
                  (a = e.y1 + e.height / 2 - this.height / 2))
                : "bottom" === this.verticalAlign &&
                  ((s =
                    "left" === this.horizontalAlign
                      ? e.x1
                      : "right" === this.horizontalAlign
                      ? e.x2 - this.width
                      : e.x1 + e.width / 2 - this.width / 2),
                  (a = e.y2 - this.height)),
                this.items = l,
                c = 0;
              c < this.items.length;
              c++
            )
              ((u = l[c]).id = ++this.chart._eventManager.lastObjectId),
                (this.chart._eventManager.objectMap[u.id] = {
                  id: u.id,
                  objectType: "legendItem",
                  legendItemIndex: c,
                  dataSeriesIndex: u.dataSeriesIndex,
                  dataPointIndex: u.dataPointIndex,
                });
            for (
              ((0 < this.borderThickness && this.borderColor) ||
                this.backgroundColor) &&
                this.ctx.roundRect(
                  s,
                  a,
                  this.width,
                  this.height,
                  this.cornerRadius,
                  this.borderThickness,
                  this.backgroundColor,
                  this.borderColor
                ),
                c = e = 0;
              c < h.length;
              c++
            ) {
              for (p = h[c], y = f = 0; y < p.items.length; y++) {
                if (
                  ((b = a + e),
                  (x = m =
                    (u = p.items[y]).textBlock.x +
                    s +
                    (0 === y ? 0.2 * g : this.horizontalSpacing)),
                  this.chart.data[u.dataSeriesIndex].visible ||
                    (this.ctx.globalAlpha = 0.5),
                  this.ctx.save(),
                  this.ctx.beginPath(),
                  this.ctx.rect(
                    s,
                    a,
                    n,
                    Math.max(o - (o % this.lineHeight), 0)
                  ),
                  this.ctx.clip(),
                  ("line" !== u.chartType &&
                    "stepLine" !== u.chartType &&
                    "spline" !== u.chartType) ||
                    ((this.ctx.strokeStyle = u.lineColor),
                    (this.ctx.lineWidth = Math.ceil(this.lineHeight / 8)),
                    this.ctx.beginPath(),
                    this.ctx.moveTo(
                      m - 0.1 * this.lineHeight,
                      b + this.lineHeight / 2
                    ),
                    this.ctx.lineTo(
                      m + 0.85 * this.lineHeight,
                      b + this.lineHeight / 2
                    ),
                    this.ctx.stroke(),
                    (x -= 0.1 * this.lineHeight)),
                  "error" === u.chartType)
                ) {
                  (this.ctx.strokeStyle = d[0]),
                    (v = g / 8),
                    (this.ctx.lineWidth = v),
                    this.ctx.beginPath();
                  v = m - 0.08 * this.lineHeight + 0.1 * this.lineHeight;
                  var M = b + 0.15 * this.lineHeight,
                    k = 0.7 * this.lineHeight,
                    w = k + 0.02 * this.lineHeight;
                  this.ctx.moveTo(v, M),
                    this.ctx.lineTo(v + k, M),
                    this.ctx.stroke(),
                    this.ctx.beginPath(),
                    this.ctx.moveTo(v + k / 2, M),
                    this.ctx.lineTo(v + k / 2, M + w),
                    this.ctx.stroke(),
                    this.ctx.beginPath(),
                    this.ctx.moveTo(v, M + w),
                    this.ctx.lineTo(v + k, M + w),
                    this.ctx.stroke(),
                    d.shift();
                }
                I.drawMarker(
                  m + g / 2,
                  b + this.lineHeight / 2,
                  this.ctx,
                  u.markerType,
                  "error" === u.chartType ||
                    "line" === u.chartType ||
                    "spline" === u.chartType
                    ? u.markerSize / 2
                    : u.markerSize,
                  u.markerColor,
                  u.markerBorderColor,
                  u.markerBorderThickness
                ),
                  (u.textBlock.x = m + r + g),
                  ("line" !== u.chartType &&
                    "stepLine" !== u.chartType &&
                    "spline" !== u.chartType) ||
                    (u.textBlock.x += 0.1 * this.lineHeight),
                  (u.textBlock.y = Math.round(b + this.lineHeight / 2)),
                  u.textBlock.render(!0),
                  this.ctx.restore(),
                  (f =
                    0 < y
                      ? Math.max(f, u.textBlock.height)
                      : u.textBlock.height),
                  this.chart.data[u.dataSeriesIndex].visible ||
                    (this.ctx.globalAlpha = 1),
                  (v = N(u.id)),
                  (this.ghostCtx.fillStyle = v),
                  this.ghostCtx.beginPath(),
                  this.ghostCtx.fillRect(
                    x,
                    u.textBlock.y - this.lineHeight / 2,
                    u.textBlock.x + u.textBlock.width - x,
                    u.textBlock.height
                  ),
                  (u.x1 = this.chart._eventManager.objectMap[u.id].x1 = x),
                  (u.y1 = this.chart._eventManager.objectMap[u.id].y1 =
                    u.textBlock.y - this.lineHeight / 2),
                  (u.x2 = this.chart._eventManager.objectMap[u.id].x2 =
                    u.textBlock.x + u.textBlock.width),
                  (u.y2 = this.chart._eventManager.objectMap[u.id].y2 =
                    u.textBlock.y + u.textBlock.height - this.lineHeight / 2);
              }
              e += f;
            }
            0 < l.length &&
              t.layoutManager.registerSpace(i, {
                width: this.width + 2 + 2,
                height: this.height + 5 + 5,
              }),
              (this.bounds = {
                x1: s,
                y1: a,
                x2: s + this.width,
                y2: a + this.height,
              });
          }),
          t(T, L),
          (T.prototype.getDefaultAxisPlacement = function () {
            var t = this.type;
            return "column" === t ||
              "line" === t ||
              "stepLine" === t ||
              "spline" === t ||
              "area" === t ||
              "stepArea" === t ||
              "splineArea" === t ||
              "stackedColumn" === t ||
              "stackedLine" === t ||
              "bubble" === t ||
              "scatter" === t ||
              "stackedArea" === t ||
              "stackedColumn100" === t ||
              "stackedLine100" === t ||
              "stackedArea100" === t ||
              "candlestick" === t ||
              "ohlc" === t ||
              "rangeColumn" === t ||
              "rangeArea" === t ||
              "rangeSplineArea" === t ||
              "boxAndWhisker" === t ||
              "waterfall" === t
              ? "normal"
              : "bar" === t ||
                "stackedBar" === t ||
                "stackedBar100" === t ||
                "rangeBar" === t
              ? "xySwapped"
              : "pie" === t ||
                "doughnut" === t ||
                "funnel" === t ||
                "pyramid" === t
              ? "none"
              : ("error" !== t &&
                  window.console.log("Unknown Chart Type: " + t),
                null);
          }),
          (T.getDefaultLegendMarker = function (t) {
            return "column" === t ||
              "stackedColumn" === t ||
              "stackedLine" === t ||
              "bar" === t ||
              "stackedBar" === t ||
              "stackedBar100" === t ||
              "bubble" === t ||
              "scatter" === t ||
              "stackedColumn100" === t ||
              "stackedLine100" === t ||
              "stepArea" === t ||
              "candlestick" === t ||
              "ohlc" === t ||
              "rangeColumn" === t ||
              "rangeBar" === t ||
              "rangeArea" === t ||
              "rangeSplineArea" === t ||
              "boxAndWhisker" === t ||
              "waterfall" === t
              ? "square"
              : "line" === t ||
                "stepLine" === t ||
                "spline" === t ||
                "pie" === t ||
                "doughnut" === t
              ? "circle"
              : "area" === t ||
                "splineArea" === t ||
                "stackedArea" === t ||
                "stackedArea100" === t ||
                "funnel" === t ||
                "pyramid" === t
              ? "triangle"
              : "error" === t
              ? "none"
              : (window.console.log("Unknown Chart Type: " + t), null);
          }),
          (T.prototype.getDataPointAtX = function (t, e) {
            if (!this.dataPoints || 0 === this.dataPoints.length) return null;
            var i = { dataPoint: null, distance: 1 / 0, index: NaN },
              a = null,
              s = 0,
              n = 0,
              o = 1,
              r = 1 / 0,
              l = 0,
              h = 0,
              d = 0;
            for (
              "none" !== this.chart.plotInfo.axisPlacement &&
              (d = this.axisX.logarithmic
                ? 1 <
                  (d = Math.log(
                    this.dataPoints[this.dataPoints.length - 1].x /
                      this.dataPoints[0].x
                  ))
                  ? Math.min(
                      Math.max(
                        (((this.dataPoints.length - 1) / d) *
                          Math.log(t / this.dataPoints[0].x)) >>
                          0,
                        0
                      ),
                      this.dataPoints.length
                    )
                  : 0
                : 0 <
                  (d =
                    this.dataPoints[this.dataPoints.length - 1].x -
                    this.dataPoints[0].x)
                ? Math.min(
                    Math.max(
                      (((this.dataPoints.length - 1) / d) *
                        (t - this.dataPoints[0].x)) >>
                        0,
                      0
                    ),
                    this.dataPoints.length
                  )
                : 0);
              ;

            ) {
              if (
                0 <= (n = 0 < o ? d + s : d - s) &&
                n < this.dataPoints.length
              ) {
                a = this.dataPoints[n];
                var c = this.axisX.logarithmic
                  ? a.x > t
                    ? a.x / t
                    : t / a.x
                  : Math.abs(a.x - t);
                if (
                  (c < i.distance &&
                    ((i.dataPoint = a), (i.distance = c), (i.index = n)),
                  (a = c) <= r ? (r = a) : 0 < o ? l++ : h++,
                  1e3 < l && 1e3 < h)
                )
                  break;
              } else if (d - s < 0 && d + s >= this.dataPoints.length) break;
              o = -1 === o ? (s++, 1) : -1;
            }
            return e || i.dataPoint.x !== t
              ? e && null !== i.dataPoint
                ? i
                : null
              : i;
          }),
          (T.prototype.getDataPointAtXY = function (t, e, i) {
            if (
              !this.dataPoints ||
              0 === this.dataPoints.length ||
              t < this.chart.plotArea.x1 ||
              t > this.chart.plotArea.x2 ||
              e < this.chart.plotArea.y1 ||
              e > this.chart.plotArea.y2
            )
              return null;
            i = i || !1;
            var a = [],
              s = 0,
              n = 0,
              o = 1,
              r = !1,
              l = 1 / 0,
              h = 0,
              d = 0,
              c = 0;
            if ("none" !== this.chart.plotInfo.axisPlacement)
              if (
                ((c = (
                  this.chart.axisX[0]
                    ? this.chart.axisX[0]
                    : this.chart.axisX2[0]
                ).getXValueAt({ x: t, y: e })),
                this.axisX.logarithmic)
              )
                c =
                  1 <
                  (p = Math.log(
                    this.dataPoints[this.dataPoints.length - 1].x /
                      this.dataPoints[0].x
                  ))
                    ? Math.min(
                        Math.max(
                          (((this.dataPoints.length - 1) / p) *
                            Math.log(c / this.dataPoints[0].x)) >>
                            0,
                          0
                        ),
                        this.dataPoints.length
                      )
                    : 0;
              else
                c =
                  0 <
                  (p =
                    this.dataPoints[this.dataPoints.length - 1].x -
                    this.dataPoints[0].x)
                    ? Math.min(
                        Math.max(
                          (((this.dataPoints.length - 1) / p) *
                            (c - this.dataPoints[0].x)) >>
                            0,
                          0
                        ),
                        this.dataPoints.length
                      )
                    : 0;
            for (;;) {
              if (
                0 <= (n = 0 < o ? c + s : c - s) &&
                n < this.dataPoints.length
              ) {
                var p =
                    this.chart._eventManager.objectMap[this.dataPointIds[n]],
                  u = this.dataPoints[n],
                  x = null;
                if (p) {
                  switch (this.type) {
                    case "column":
                    case "stackedColumn":
                    case "stackedColumn100":
                    case "bar":
                    case "stackedBar":
                    case "stackedBar100":
                    case "rangeColumn":
                    case "rangeBar":
                    case "waterfall":
                    case "error":
                      t >= p.x1 &&
                        t <= p.x2 &&
                        e >= p.y1 &&
                        e <= p.y2 &&
                        (a.push({
                          dataPoint: u,
                          dataPointIndex: n,
                          dataSeries: this,
                          distance: Math.min(
                            Math.abs(p.x1 - t),
                            Math.abs(p.x2 - t),
                            Math.abs(p.y1 - e),
                            Math.abs(p.y2 - e)
                          ),
                        }),
                        (r = !0));
                      break;
                    case "line":
                    case "stepLine":
                    case "spline":
                    case "area":
                    case "stepArea":
                    case "stackedArea":
                    case "stackedArea100":
                    case "splineArea":
                    case "scatter":
                      var m = C("markerSize", u, this) || 4,
                        g = i ? 20 : m;
                      (x = Math.sqrt(
                        Math.pow(p.x1 - t, 2) + Math.pow(p.y1 - e, 2)
                      )) <= g &&
                        a.push({
                          dataPoint: u,
                          dataPointIndex: n,
                          dataSeries: this,
                          distance: x,
                        }),
                        (p = Math.abs(p.x1 - t)) <= l
                          ? (l = p)
                          : 0 < o
                          ? h++
                          : d++,
                        x <= m / 2 && (r = !0);
                      break;
                    case "rangeArea":
                    case "rangeSplineArea":
                      (m = C("markerSize", u, this) || 4),
                        (g = i ? 20 : m),
                        (x = Math.min(
                          Math.sqrt(
                            Math.pow(p.x1 - t, 2) + Math.pow(p.y1 - e, 2)
                          ),
                          Math.sqrt(
                            Math.pow(p.x1 - t, 2) + Math.pow(p.y2 - e, 2)
                          )
                        )) <= g &&
                          a.push({
                            dataPoint: u,
                            dataPointIndex: n,
                            dataSeries: this,
                            distance: x,
                          }),
                        (p = Math.abs(p.x1 - t)) <= l
                          ? (l = p)
                          : 0 < o
                          ? h++
                          : d++,
                        x <= m / 2 && (r = !0);
                      break;
                    case "bubble":
                      (m = p.size),
                        (x = Math.sqrt(
                          Math.pow(p.x1 - t, 2) + Math.pow(p.y1 - e, 2)
                        )) <=
                          m / 2 &&
                          (a.push({
                            dataPoint: u,
                            dataPointIndex: n,
                            dataSeries: this,
                            distance: x,
                          }),
                          (r = !0));
                      break;
                    case "pie":
                    case "doughnut":
                      (m = p.center),
                        (g =
                          "doughnut" === this.type
                            ? p.percentInnerRadius * p.radius
                            : 0),
                        (x = Math.sqrt(
                          Math.pow(m.x - t, 2) + Math.pow(m.y - e, 2)
                        )) < p.radius &&
                          g < x &&
                          ((x = Math.atan2(e - m.y, t - m.x)) < 0 &&
                            (x += 2 * Math.PI),
                          (x = Number(
                            (
                              ((((x / Math.PI) * 180) % 360) + 360) %
                              360
                            ).toFixed(12)
                          )),
                          (m = Number(
                            (
                              ((((p.startAngle / Math.PI) * 180) % 360) + 360) %
                              360
                            ).toFixed(12)
                          )),
                          0 ===
                            (g = Number(
                              (
                                ((((p.endAngle / Math.PI) * 180) % 360) + 360) %
                                360
                              ).toFixed(12)
                            )) &&
                            1 < p.endAngle &&
                            (g = 360),
                          g <= m &&
                            0 !== u.y &&
                            ((g += 360), x < m && (x += 360)),
                          m < x &&
                            x < g &&
                            (a.push({
                              dataPoint: u,
                              dataPointIndex: n,
                              dataSeries: this,
                              distance: 0,
                            }),
                            (r = !0)));
                      break;
                    case "funnel":
                    case "pyramid":
                      e > (x = p.funnelSection).y1 &&
                        e < x.y4 &&
                        ((x = x.y6
                          ? e > x.y6
                            ? ((n =
                                x.x6 +
                                ((x.x5 - x.x6) / (x.y5 - x.y6)) * (e - x.y6)),
                              x.x3 +
                                ((x.x4 - x.x3) / (x.y4 - x.y3)) * (e - x.y3))
                            : ((n =
                                x.x1 +
                                ((x.x6 - x.x1) / (x.y6 - x.y1)) * (e - x.y1)),
                              x.x2 +
                                ((x.x3 - x.x2) / (x.y3 - x.y2)) * (e - x.y2))
                          : ((n =
                              x.x1 +
                              ((x.x4 - x.x1) / (x.y4 - x.y1)) * (e - x.y1)),
                            x.x2 +
                              ((x.x3 - x.x2) / (x.y3 - x.y2)) * (e - x.y2))),
                        n < t &&
                          t < x &&
                          (a.push({
                            dataPoint: u,
                            dataPointIndex: p.dataPointIndex,
                            dataSeries: this,
                            distance: 0,
                          }),
                          (r = !0)));
                      break;
                    case "boxAndWhisker":
                      ((t >= p.x1 - p.borderThickness / 2 &&
                        t <= p.x2 + p.borderThickness / 2 &&
                        e >= p.y4 - p.borderThickness / 2 &&
                        e <= p.y1 + p.borderThickness / 2) ||
                        (Math.abs(p.x2 - t + p.x1 - t) < p.borderThickness &&
                          e >= p.y1 &&
                          e <= p.y4)) &&
                        (a.push({
                          dataPoint: u,
                          dataPointIndex: n,
                          dataSeries: this,
                          distance: Math.min(
                            Math.abs(p.x1 - t),
                            Math.abs(p.x2 - t),
                            Math.abs(p.y2 - e),
                            Math.abs(p.y3 - e)
                          ),
                        }),
                        (r = !0));
                      break;
                    case "candlestick":
                      ((t >= p.x1 - p.borderThickness / 2 &&
                        t <= p.x2 + p.borderThickness / 2 &&
                        e >= p.y2 - p.borderThickness / 2 &&
                        e <= p.y3 + p.borderThickness / 2) ||
                        (Math.abs(p.x2 - t + p.x1 - t) < p.borderThickness &&
                          e >= p.y1 &&
                          e <= p.y4)) &&
                        (a.push({
                          dataPoint: u,
                          dataPointIndex: n,
                          dataSeries: this,
                          distance: Math.min(
                            Math.abs(p.x1 - t),
                            Math.abs(p.x2 - t),
                            Math.abs(p.y2 - e),
                            Math.abs(p.y3 - e)
                          ),
                        }),
                        (r = !0));
                      break;
                    case "ohlc":
                      ((Math.abs(p.x2 - t + p.x1 - t) < p.borderThickness &&
                        e >= p.y2 &&
                        e <= p.y3) ||
                        (t >= p.x1 &&
                          t <= (p.x2 + p.x1) / 2 &&
                          e >= p.y1 - p.borderThickness / 2 &&
                          e <= p.y1 + p.borderThickness / 2) ||
                        (t >= (p.x1 + p.x2) / 2 &&
                          t <= p.x2 &&
                          e >= p.y4 - p.borderThickness / 2 &&
                          e <= p.y4 + p.borderThickness / 2)) &&
                        (a.push({
                          dataPoint: u,
                          dataPointIndex: n,
                          dataSeries: this,
                          distance: Math.min(
                            Math.abs(p.x1 - t),
                            Math.abs(p.x2 - t),
                            Math.abs(p.y2 - e),
                            Math.abs(p.y3 - e)
                          ),
                        }),
                        (r = !0));
                  }
                  if (r || (1e3 < h && 1e3 < d)) break;
                }
              } else if (c - s < 0 && c + s >= this.dataPoints.length) break;
              o = -1 === o ? (s++, 1) : -1;
            }
            for (t = null, e = 0; e < a.length; e++)
              t ? a[e].distance <= t.distance && (t = a[e]) : (t = a[e]);
            return t;
          }),
          (T.prototype.getMarkerProperties = function (t, e, i, a) {
            var s = this.dataPoints;
            return {
              x: e,
              y: i,
              ctx: a,
              type: s[t].markerType ? s[t].markerType : this.markerType,
              size: s[t].markerSize ? s[t].markerSize : this.markerSize,
              color: s[t].markerColor
                ? s[t].markerColor
                : this.markerColor
                ? this.markerColor
                : s[t].color
                ? s[t].color
                : this.color
                ? this.color
                : this._colorSet[t % this._colorSet.length],
              borderColor: s[t].markerBorderColor
                ? s[t].markerBorderColor
                : this.markerBorderColor
                ? this.markerBorderColor
                : null,
              borderThickness: s[t].markerBorderThickness
                ? s[t].markerBorderThickness
                : this.markerBorderThickness
                ? this.markerBorderThickness
                : null,
            };
          }),
          t(v, L),
          (v.prototype.createExtraLabelsForLog = function (t) {
            if (!(5 < (t = (t || 0) + 1))) {
              var e = this.logLabelValues[0] || this.intervalStartPosition;
              if (
                Math.log(this.range) / Math.log(e / this.viewportMinimum) <
                this.noTicks - 1
              ) {
                for (
                  var i = v.getNiceNumber(
                      (e - this.viewportMinimum) /
                        Math.min(
                          Math.max(
                            2,
                            this.noTicks - this.logLabelValues.length
                          ),
                          3
                        ),
                      !0
                    ),
                    a = Math.ceil(this.viewportMinimum / i) * i;
                  a < e;
                  a += i
                )
                  a < this.viewportMinimum || this.logLabelValues.push(a);
                this.logLabelValues.sort(E), this.createExtraLabelsForLog(t);
              }
            }
          }),
          (v.prototype.createLabels = function () {
            var t,
              e,
              i,
              a,
              s,
              n = 0,
              o = 0,
              r = 0,
              l = 0,
              h = ((o = 0), (o = this.interval), 0),
              d = 0.6 * this.chart.height;
            t = !1;
            var c = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],
              p = c.length
                ? U(this.scaleBreaks.firstBreakIndex)
                  ? 0
                  : this.scaleBreaks.firstBreakIndex
                : 0;
            if (
              "axisX" !== this.type ||
              "dateTime" !== this.valueType ||
              this.logarithmic
            ) {
              if (((i = this.viewportMaximum), this.labels)) {
                t = Math.ceil(o);
                var u = !1;
                for (
                  n = o = Math.ceil(this.intervalStartPosition);
                  n < this.viewportMaximum;
                  n += t
                ) {
                  if (!this.labels[n]) {
                    u = !1;
                    break;
                  }
                  u = !0;
                }
                u && ((this.interval = t), (this.intervalStartPosition = o));
              }
              if (this.logarithmic && !this.equidistantInterval)
                for (
                  this.logLabelValues ||
                    ((this.logLabelValues = []),
                    this.createExtraLabelsForLog()),
                    o = 0,
                    u = p;
                  o < this.logLabelValues.length;
                  o++
                )
                  if ((n = this.logLabelValues[o]) < this.viewportMinimum) o++;
                  else {
                    for (; u < c.length && n > c[u].endValue; u++);
                    (s = n),
                      (t =
                        u < c.length &&
                        n >= c[u].startValue &&
                        n <= c[u].endValue) ||
                        ((t = this.labelFormatter
                          ? this.labelFormatter({
                              chart: this.chart,
                              axis: this.options,
                              value: s,
                              label: this.labels[s] ? this.labels[s] : null,
                            })
                          : "axisX" === this.type && this.labels[s]
                          ? this.labels[s]
                          : at(
                              s,
                              this.valueFormatString,
                              this.chart._cultureInfo
                            )),
                        (t = new Q(this.ctx, {
                          x: 0,
                          y: 0,
                          maxWidth: r,
                          maxHeight: l,
                          angle: this.labelAngle,
                          text: this.prefix + t + this.suffix,
                          backgroundColor: this.labelBackgroundColor,
                          borderColor: this.labelBorderColor,
                          borderThickness: this.labelBorderThickness,
                          cornerRadius: this.labelCornerRadius,
                          horizontalAlign: "left",
                          fontSize: this.labelFontSize,
                          fontFamily: this.labelFontFamily,
                          fontWeight: this.labelFontWeight,
                          fontColor: this.labelFontColor,
                          fontStyle: this.labelFontStyle,
                          textBaseline: "middle",
                          borderThickness: 0,
                        })),
                        this._labels.push({
                          position: s,
                          textBlock: t,
                          effectiveHeight: null,
                        }));
                  }
              for (
                u = p, n = this.intervalStartPosition;
                n <= i;
                n = parseFloat(
                  this.interval < 1e-12
                    ? this.logarithmic && this.equidistantInterval
                      ? n * Math.pow(this.logarithmBase, this.interval)
                      : n + this.interval
                    : (this.logarithmic && this.equidistantInterval
                        ? n * Math.pow(this.logarithmBase, this.interval)
                        : n + this.interval
                      ).toFixed(12)
                )
              ) {
                for (; u < c.length && n > c[u].endValue; u++);
                (s = n),
                  (t =
                    u < c.length &&
                    n >= c[u].startValue &&
                    n <= c[u].endValue) ||
                    ((t = this.labelFormatter
                      ? this.labelFormatter({
                          chart: this.chart,
                          axis: this.options,
                          value: s,
                          label: this.labels[s] ? this.labels[s] : null,
                        })
                      : "axisX" === this.type && this.labels[s]
                      ? this.labels[s]
                      : at(s, this.valueFormatString, this.chart._cultureInfo)),
                    (t = new Q(this.ctx, {
                      x: 0,
                      y: 0,
                      maxWidth: r,
                      maxHeight: l,
                      angle: this.labelAngle,
                      text: this.prefix + t + this.suffix,
                      horizontalAlign: "left",
                      backgroundColor: this.labelBackgroundColor,
                      borderColor: this.labelBorderColor,
                      borderThickness: this.labelBorderThickness,
                      cornerRadius: this.labelCornerRadius,
                      fontSize: this.labelFontSize,
                      fontFamily: this.labelFontFamily,
                      fontWeight: this.labelFontWeight,
                      fontColor: this.labelFontColor,
                      fontStyle: this.labelFontStyle,
                      textBaseline: "middle",
                    })),
                    this._labels.push({
                      position: s,
                      textBlock: t,
                      effectiveHeight: null,
                    }));
              }
            } else
              for (
                this.intervalStartPosition = this.getLabelStartPoint(
                  new Date(this.viewportMinimum),
                  this.intervalType,
                  this.interval
                ),
                  i = b(
                    new Date(this.viewportMaximum),
                    this.interval,
                    this.intervalType
                  ),
                  u = p,
                  n = this.intervalStartPosition;
                n < i;
                b(n, o, this.intervalType)
              ) {
                for (t = n.getTime(); u < c.length && t > c[u].endValue; u++);
                (s = t),
                  (t =
                    u < c.length &&
                    t >= c[u].startValue &&
                    t <= c[u].endValue) ||
                    ((t = this.labelFormatter
                      ? this.labelFormatter({
                          chart: this.chart,
                          axis: this.options,
                          value: new Date(s),
                          label: this.labels[s] ? this.labels[s] : null,
                        })
                      : "axisX" === this.type && this.labels[s]
                      ? this.labels[s]
                      : it(s, this.valueFormatString, this.chart._cultureInfo)),
                    (t = new Q(this.ctx, {
                      x: 0,
                      y: 0,
                      maxWidth: r,
                      backgroundColor: this.labelBackgroundColor,
                      borderColor: this.labelBorderColor,
                      borderThickness: this.labelBorderThickness,
                      cornerRadius: this.labelCornerRadius,
                      maxHeight: l,
                      angle: this.labelAngle,
                      text: this.prefix + t + this.suffix,
                      horizontalAlign: "left",
                      fontSize: this.labelFontSize,
                      fontFamily: this.labelFontFamily,
                      fontWeight: this.labelFontWeight,
                      fontColor: this.labelFontColor,
                      fontStyle: this.labelFontStyle,
                      textBaseline: "middle",
                    })),
                    this._labels.push({
                      position: s,
                      textBlock: t,
                      effectiveHeight: null,
                      breaksLabelType: void 0,
                    }));
              }
            for (
              "bottom" === this._position || "top" === this._position
                ? ((h =
                    this.logarithmic &&
                    !this.equidistantInterval &&
                    2 <= this._labels.length
                      ? (this.lineCoordinates.width *
                          Math.log(
                            Math.min(
                              this._labels[this._labels.length - 1].position /
                                this._labels[this._labels.length - 2].position,
                              this._labels[1].position /
                                this._labels[0].position
                            )
                          )) /
                        Math.log(this.range)
                      : (this.lineCoordinates.width /
                          (this.logarithmic && this.equidistantInterval
                            ? Math.log(this.range) /
                              Math.log(this.logarithmBase)
                            : Math.abs(this.range))) *
                        tt[this.intervalType + "Duration"] *
                        this.interval),
                  (r =
                    void 0 === this.options.labelMaxWidth
                      ? (0.5 * this.chart.width) >> 0
                      : this.options.labelMaxWidth),
                  this.chart.panEnabled ||
                    (l =
                      void 0 === this.options.labelWrap || this.labelWrap
                        ? (0.8 * this.chart.height) >> 0
                        : 1.5 * this.labelFontSize))
                : ("left" !== this._position && "right" !== this._position) ||
                  ((h =
                    this.logarithmic &&
                    !this.equidistantInterval &&
                    2 <= this._labels.length
                      ? (this.lineCoordinates.height *
                          Math.log(
                            Math.min(
                              this._labels[this._labels.length - 1].position /
                                this._labels[this._labels.length - 2].position,
                              this._labels[1].position /
                                this._labels[0].position
                            )
                          )) /
                        Math.log(this.range)
                      : (this.lineCoordinates.height /
                          (this.logarithmic && this.equidistantInterval
                            ? Math.log(this.range) /
                              Math.log(this.logarithmBase)
                            : Math.abs(this.range))) *
                        tt[this.intervalType + "Duration"] *
                        this.interval),
                  this.chart.panEnabled ||
                    (r =
                      void 0 === this.options.labelMaxWidth
                        ? (0.3 * this.chart.width) >> 0
                        : this.options.labelMaxWidth),
                  (l =
                    void 0 === this.options.labelWrap || this.labelWrap
                      ? (0.3 * this.chart.height) >> 0
                      : 1.5 * this.labelFontSize)),
                o = 0;
              o < this._labels.length;
              o++
            ) {
              ((t = this._labels[o].textBlock).maxWidth = r), (t.maxHeight = l);
              var x = t.measureText();
              a = x.height;
            }
            if (
              ((i = []),
              (p = c = 0),
              this.labelAutoFit || this.options.labelAutoFit)
            )
              if (
                (U(this.labelAngle) ||
                  ((this.labelAngle = ((this.labelAngle % 360) + 360) % 360),
                  90 < this.labelAngle && this.labelAngle < 270
                    ? (this.labelAngle -= 180)
                    : 270 <= this.labelAngle &&
                      this.labelAngle <= 360 &&
                      (this.labelAngle -= 360)),
                "bottom" === this._position || "top" === this._position)
              )
                if (
                  ((r = (0.9 * h) >> 0),
                  (p = 0),
                  !this.chart.panEnabled && 1 <= this._labels.length)
                ) {
                  for (
                    this.sessionVariables.labelFontSize = this.labelFontSize,
                      this.sessionVariables.labelMaxWidth = r,
                      this.sessionVariables.labelMaxHeight = l,
                      this.sessionVariables.labelAngle = this.labelAngle,
                      this.sessionVariables.labelWrap = this.labelWrap,
                      n = 0;
                    n < this._labels.length;
                    n++
                  )
                    if (!this._labels[n].breaksLabelType) {
                      var m;
                      for (
                        u = (t = this._labels[n].textBlock).text.split(" "),
                          o = 0;
                        o < u.length;
                        o++
                      )
                        (s = u[o]),
                          (this.ctx.font =
                            t.fontStyle +
                            " " +
                            t.fontWeight +
                            " " +
                            t.fontSize +
                            "px " +
                            t.fontFamily),
                          (s = this.ctx.measureText(s)).width > p &&
                            ((m = n), (p = s.width));
                    }
                  for (
                    n = 0,
                      n =
                        this.intervalStartPosition < this.viewportMinimum
                          ? 1
                          : 0;
                    n < this._labels.length;
                    n++
                  )
                    if (!this._labels[n].breaksLabelType) {
                      for (
                        x = (t = this._labels[n].textBlock).measureText(),
                          u = n + 1;
                        u < this._labels.length;
                        u++
                      )
                        if (!this._labels[u].breaksLabelType) {
                          e = (e = this._labels[u].textBlock).measureText();
                          break;
                        }
                      if (
                        (i.push(t.height),
                        (this.sessionVariables.labelMaxHeight = Math.max.apply(
                          Math,
                          i
                        )),
                        Math.cos((Math.PI / 180) * Math.abs(this.labelAngle)),
                        Math.sin((Math.PI / 180) * Math.abs(this.labelAngle)),
                        (o =
                          r *
                            Math.sin(
                              (Math.PI / 180) * Math.abs(this.labelAngle)
                            ) +
                          (l - t.fontSize / 2) *
                            Math.cos(
                              (Math.PI / 180) * Math.abs(this.labelAngle)
                            )),
                        U(this.options.labelAngle) &&
                          isNaN(this.options.labelAngle) &&
                          0 !== this.options.labelAngle)
                      )
                        if (
                          ((this.sessionVariables.labelMaxHeight =
                            0 === this.labelAngle
                              ? l
                              : Math.min(
                                  (o -
                                    r *
                                      Math.cos(
                                        (Math.PI / 180) *
                                          Math.abs(this.labelAngle)
                                      )) /
                                    Math.sin(
                                      (Math.PI / 180) *
                                        Math.abs(this.labelAngle)
                                    ),
                                  o
                                )),
                          (s =
                            (d -
                              (a + t.fontSize / 2) *
                                Math.cos((Math.PI / 180) * Math.abs(-25))) /
                            Math.sin((Math.PI / 180) * Math.abs(-25))),
                          U(this.options.labelWrap))
                        ) {
                          if (U(this.options.labelWrap))
                            if (U(this.options.labelMaxWidth)) {
                              if (!U(e))
                                if (
                                  ((o = (x.width + e.width) >> 0),
                                  (u = this.labelFontSize),
                                  p < r)
                                )
                                  c < o - 2 * r &&
                                    ((c = o - 2 * r),
                                    2 * r <= o && o < 2.2 * r
                                      ? ((this.sessionVariables.labelMaxWidth =
                                          r),
                                        U(this.options.labelFontSize) &&
                                          12 < u &&
                                          ((u = Math.floor((12 / 13) * u)),
                                          t.measureText()),
                                        (this.sessionVariables.labelFontSize =
                                          U(this.options.labelFontSize)
                                            ? u
                                            : this.options.labelFontSize),
                                        (this.sessionVariables.labelAngle =
                                          this.labelAngle))
                                      : 2.2 * r <= o && o < 2.8 * r
                                      ? ((this.sessionVariables.labelAngle =
                                          -25),
                                        (this.sessionVariables.labelMaxWidth =
                                          s),
                                        (this.sessionVariables.labelFontSize =
                                          u))
                                      : 2.8 * r <= o && o < 3.2 * r
                                      ? ((this.sessionVariables.labelMaxWidth =
                                          Math.max(r, p)),
                                        (this.sessionVariables.labelWrap = !0),
                                        U(this.options.labelFontSize) &&
                                          12 < this.labelFontSize &&
                                          ((this.labelFontSize = Math.floor(
                                            (12 / 13) * this.labelFontSize
                                          )),
                                          t.measureText()),
                                        (this.sessionVariables.labelFontSize =
                                          U(this.options.labelFontSize)
                                            ? u
                                            : this.options.labelFontSize),
                                        (this.sessionVariables.labelAngle =
                                          this.labelAngle))
                                      : 3.2 * r <= o && o < 3.6 * r
                                      ? ((this.sessionVariables.labelAngle =
                                          -25),
                                        (this.sessionVariables.labelWrap = !0),
                                        (this.sessionVariables.labelMaxWidth =
                                          s),
                                        (this.sessionVariables.labelFontSize =
                                          this.labelFontSize))
                                      : 3.6 * r < o && o < 5 * r
                                      ? (U(this.options.labelFontSize) &&
                                          12 < u &&
                                          ((u = Math.floor((12 / 13) * u)),
                                          t.measureText()),
                                        (this.sessionVariables.labelFontSize =
                                          U(this.options.labelFontSize)
                                            ? u
                                            : this.options.labelFontSize),
                                        (this.sessionVariables.labelWrap = !0),
                                        (this.sessionVariables.labelAngle =
                                          -25),
                                        (this.sessionVariables.labelMaxWidth =
                                          s))
                                      : 5 * r < o &&
                                        ((this.sessionVariables.labelWrap = !0),
                                        (this.sessionVariables.labelMaxWidth =
                                          r),
                                        (this.sessionVariables.labelFontSize =
                                          u),
                                        (this.sessionVariables.labelMaxHeight =
                                          l),
                                        (this.sessionVariables.labelAngle =
                                          this.labelAngle)));
                                else if (
                                  m === n &&
                                  ((0 === m &&
                                    p +
                                      this._labels[
                                        m + 1
                                      ].textBlock.measureText().width -
                                      2 * r >
                                      c) ||
                                    (m === this._labels.length - 1 &&
                                      p +
                                        this._labels[
                                          m - 1
                                        ].textBlock.measureText().width -
                                        2 * r >
                                        c) ||
                                    (0 < m &&
                                      m < this._labels.length - 1 &&
                                      p +
                                        this._labels[
                                          m + 1
                                        ].textBlock.measureText().width -
                                        2 * r >
                                        c &&
                                      p +
                                        this._labels[
                                          m - 1
                                        ].textBlock.measureText().width -
                                        2 * r >
                                        c))
                                )
                                  (c =
                                    0 === m
                                      ? p +
                                        this._labels[
                                          m + 1
                                        ].textBlock.measureText().width -
                                        2 * r
                                      : p +
                                        this._labels[
                                          m - 1
                                        ].textBlock.measureText().width -
                                        2 * r),
                                    (this.sessionVariables.labelFontSize = U(
                                      this.options.labelFontSize
                                    )
                                      ? u
                                      : this.options.labelFontSize),
                                    (this.sessionVariables.labelWrap = !0),
                                    (this.sessionVariables.labelAngle = -25),
                                    (this.sessionVariables.labelMaxWidth = s);
                                else if (0 === c)
                                  for (
                                    this.sessionVariables.labelFontSize = U(
                                      this.options.labelFontSize
                                    )
                                      ? u
                                      : this.options.labelFontSize,
                                      this.sessionVariables.labelWrap = !0,
                                      o = 0;
                                    o < this._labels.length;
                                    o++
                                  )
                                    ((t = this._labels[o].textBlock).maxWidth =
                                      this.sessionVariables.labelMaxWidth =
                                        Math.min(Math.max(r, p), s)),
                                      (x = t.measureText()),
                                      o < this._labels.length - 1 &&
                                        ((u = o + 1),
                                        ((e =
                                          this._labels[u].textBlock).maxWidth =
                                          this.sessionVariables.labelMaxWidth =
                                            Math.min(Math.max(r, p), s)),
                                        (e = e.measureText()),
                                        (x.width + e.width) >> 0 > 2 * r &&
                                          (this.sessionVariables.labelAngle =
                                            -25));
                            } else
                              this.options.labelMaxWidth < r
                                ? ((this.sessionVariables.labelMaxWidth =
                                    this.options.labelMaxWidth),
                                  (this.sessionVariables.labelMaxHeight = o))
                                : ((this.sessionVariables.labelAngle = -25),
                                  (this.sessionVariables.labelMaxWidth =
                                    this.options.labelMaxWidth),
                                  (this.sessionVariables.labelMaxHeight = l));
                        } else
                          this.labelWrap
                            ? U(this.options.labelMaxWidth)
                              ? ((this.sessionVariables.labelMaxWidth =
                                  Math.min(Math.max(r, p), s)),
                                (this.sessionVariables.labelWrap =
                                  this.labelWrap),
                                (x.width + e.width) >> 0 > 2 * r &&
                                  (this.sessionVariables.labelAngle = -25))
                              : ((this.sessionVariables.labelWrap =
                                  this.labelWrap),
                                (this.sessionVariables.labelMaxWidth =
                                  this.options.labelMaxWidth),
                                (this.sessionVariables.labelAngle =
                                  this.sessionVariables.labelMaxWidth > r
                                    ? -25
                                    : this.sessionVariables.labelAngle))
                            : U(this.options.labelMaxWidth)
                            ? ((this.sessionVariables.labelWrap =
                                this.labelWrap),
                              (this.sessionVariables.labelMaxHeight = l),
                              (this.sessionVariables.labelMaxWidth = r),
                              (x.width + e.width) >> 0 > 2 * r &&
                                ((this.sessionVariables.labelAngle = -25),
                                (this.sessionVariables.labelMaxWidth = s)))
                            : ((this.sessionVariables.labelAngle =
                                this.sessionVariables.labelMaxWidth > r
                                  ? -25
                                  : this.sessionVariables.labelAngle),
                              (this.sessionVariables.labelMaxWidth =
                                this.options.labelMaxWidth),
                              (this.sessionVariables.labelMaxHeight = l),
                              (this.sessionVariables.labelWrap =
                                this.labelWrap));
                      else
                        (this.sessionVariables.labelAngle = this.labelAngle),
                          (this.sessionVariables.labelMaxHeight =
                            0 === this.labelAngle
                              ? l
                              : Math.min(
                                  (o -
                                    r *
                                      Math.cos(
                                        (Math.PI / 180) *
                                          Math.abs(this.labelAngle)
                                      )) /
                                    Math.sin(
                                      (Math.PI / 180) *
                                        Math.abs(this.labelAngle)
                                    ),
                                  o
                                )),
                          (s =
                            0 != this.labelAngle
                              ? (d -
                                  (a + t.fontSize / 2) *
                                    Math.cos(
                                      (Math.PI / 180) *
                                        Math.abs(this.labelAngle)
                                    )) /
                                Math.sin(
                                  (Math.PI / 180) * Math.abs(this.labelAngle)
                                )
                              : r),
                          (this.sessionVariables.labelMaxHeight = l =
                            this.labelWrap
                              ? (d -
                                  s *
                                    Math.sin(
                                      (Math.PI / 180) *
                                        Math.abs(this.labelAngle)
                                    )) /
                                Math.cos(
                                  (Math.PI / 180) * Math.abs(this.labelAngle)
                                )
                              : 1.5 * this.labelFontSize),
                          U(this.options.labelWrap)
                            ? U(this.options.labelWrap) &&
                              (this.labelWrap && !U(this.options.labelMaxWidth)
                                ? ((this.sessionVariables.labelWrap =
                                    this.labelWrap),
                                  (this.sessionVariables.labelMaxWidth = this
                                    .options.labelMaxWidth
                                    ? this.options.labelMaxWidth
                                    : s),
                                  (this.sessionVariables.labelMaxHeight = l))
                                : ((this.sessionVariables.labelAngle =
                                    this.labelAngle),
                                  (this.sessionVariables.labelMaxWidth = s),
                                  (this.sessionVariables.labelMaxHeight =
                                    o < 0.9 * h ? 0.9 * h : o),
                                  (this.sessionVariables.labelWrap =
                                    this.labelWrap)))
                            : (this.options.labelWrap
                                ? ((this.sessionVariables.labelWrap =
                                    this.labelWrap),
                                  (this.sessionVariables.labelMaxWidth = this
                                    .options.labelMaxWidth
                                    ? this.options.labelMaxWidth
                                    : s))
                                : (U(this.options.labelMaxWidth),
                                  (this.sessionVariables.labelMaxWidth = this
                                    .options.labelMaxWidth
                                    ? this.options.labelMaxWidth
                                    : s),
                                  (this.sessionVariables.labelWrap =
                                    this.labelWrap)),
                              (this.sessionVariables.labelMaxHeight = l));
                    }
                  for (o = 0; o < this._labels.length; o++)
                    ((t = this._labels[o].textBlock).maxWidth =
                      this.labelMaxWidth =
                        this.sessionVariables.labelMaxWidth),
                      (t.fontSize = this.sessionVariables.labelFontSize),
                      (t.angle = this.labelAngle =
                        this.sessionVariables.labelAngle),
                      (t.wrap = this.labelWrap =
                        this.sessionVariables.labelWrap),
                      (t.maxHeight = this.sessionVariables.labelMaxHeight),
                      t.measureText();
                } else
                  for (n = 0; n < this._labels.length; n++)
                    ((t = this._labels[n].textBlock).maxWidth =
                      this.labelMaxWidth =
                        U(this.options.labelMaxWidth)
                          ? this.sessionVariables.labelMaxWidth
                          : this.options.labelMaxWidth),
                      (t.fontSize = this.labelFontSize =
                        U(this.options.labelFontSize)
                          ? this.sessionVariables.labelFontSize
                          : this.options.labelFontSize),
                      (t.angle = this.labelAngle =
                        U(this.options.labelAngle)
                          ? this.sessionVariables.labelAngle
                          : this.labelAngle),
                      (t.wrap = this.labelWrap =
                        U(this.options.labelWrap)
                          ? this.sessionVariables.labelWrap
                          : this.options.labelWrap),
                      (t.maxHeight = this.sessionVariables.labelMaxHeight),
                      t.measureText();
              else if ("left" === this._position || "right" === this._position)
                if (
                  ((r = U(this.options.labelMaxWidth)
                    ? (0.3 * this.chart.width) >> 0
                    : this.options.labelMaxWidth),
                  (l =
                    void 0 === this.options.labelWrap || this.labelWrap
                      ? (0.3 * this.chart.height) >> 0
                      : 1.5 * this.labelFontSize),
                  !this.chart.panEnabled && 1 <= this._labels.length)
                ) {
                  for (
                    this.sessionVariables.labelFontSize = this.labelFontSize,
                      this.sessionVariables.labelMaxWidth = r,
                      this.sessionVariables.labelMaxHeight = l,
                      this.sessionVariables.labelAngle = U(
                        this.sessionVariables.labelAngle
                      )
                        ? 0
                        : this.sessionVariables.labelAngle,
                      this.sessionVariables.labelWrap = this.labelWrap,
                      n = 0;
                    n < this._labels.length;
                    n++
                  )
                    if (!this._labels[n].breaksLabelType) {
                      for (
                        x = (t = this._labels[n].textBlock).measureText(),
                          u = n + 1;
                        u < this._labels.length;
                        u++
                      )
                        if (!this._labels[u].breaksLabelType) {
                          e = (e = this._labels[u].textBlock).measureText();
                          break;
                        }
                      i.push(t.height),
                        (this.sessionVariables.labelMaxHeight = Math.max.apply(
                          Math,
                          i
                        )),
                        (o =
                          r *
                            Math.sin(
                              (Math.PI / 180) * Math.abs(this.labelAngle)
                            ) +
                          (l - t.fontSize / 2) *
                            Math.cos(
                              (Math.PI / 180) * Math.abs(this.labelAngle)
                            )),
                        Math.cos((Math.PI / 180) * Math.abs(this.labelAngle)),
                        Math.sin((Math.PI / 180) * Math.abs(this.labelAngle)),
                        U(this.options.labelAngle) &&
                        isNaN(this.options.labelAngle) &&
                        0 !== this.options.labelAngle
                          ? U(this.options.labelWrap)
                            ? U(this.options.labelWrap) &&
                              (U(this.options.labelMaxWidth)
                                ? U(e) ||
                                  (p <
                                    (h = (x.height + e.height) >> 0) - 2 * l &&
                                    ((p = h - 2 * l),
                                    2 * l <= h && h < 2.4 * l
                                      ? (U(this.options.labelFontSize) &&
                                          12 < this.labelFontSize &&
                                          ((this.labelFontSize = Math.floor(
                                            (12 / 13) * this.labelFontSize
                                          )),
                                          t.measureText()),
                                        (this.sessionVariables.labelMaxHeight =
                                          l),
                                        (this.sessionVariables.labelFontSize =
                                          U(this.options.labelFontSize)
                                            ? this.labelFontSize
                                            : this.options.labelFontSize))
                                      : 2.4 * l <= h && h < 2.8 * l
                                      ? ((this.sessionVariables.labelMaxHeight =
                                          o),
                                        (this.sessionVariables.labelFontSize =
                                          this.labelFontSize),
                                        (this.sessionVariables.labelWrap = !0))
                                      : 2.8 * l <= h && h < 3.2 * l
                                      ? ((this.sessionVariables.labelMaxHeight =
                                          l),
                                        (this.sessionVariables.labelWrap = !0),
                                        U(this.options.labelFontSize) &&
                                          12 < this.labelFontSize &&
                                          ((this.labelFontSize = Math.floor(
                                            (12 / 13) * this.labelFontSize
                                          )),
                                          t.measureText()),
                                        (this.sessionVariables.labelFontSize =
                                          U(this.options.labelFontSize)
                                            ? this.labelFontSize
                                            : this.options.labelFontSize),
                                        (this.sessionVariables.labelAngle = U(
                                          this.sessionVariables.labelAngle
                                        )
                                          ? 0
                                          : this.sessionVariables.labelAngle))
                                      : 3.2 * l <= h && h < 3.6 * l
                                      ? ((this.sessionVariables.labelMaxHeight =
                                          o),
                                        (this.sessionVariables.labelWrap = !0),
                                        (this.sessionVariables.labelFontSize =
                                          this.labelFontSize))
                                      : 3.6 * l < h && h < 10 * l
                                      ? (U(this.options.labelFontSize) &&
                                          12 < this.labelFontSize &&
                                          ((this.labelFontSize = Math.floor(
                                            (12 / 13) * this.labelFontSize
                                          )),
                                          t.measureText()),
                                        (this.sessionVariables.labelFontSize =
                                          U(this.options.labelFontSize)
                                            ? this.labelFontSize
                                            : this.options.labelFontSize),
                                        (this.sessionVariables.labelMaxWidth =
                                          r),
                                        (this.sessionVariables.labelMaxHeight =
                                          l),
                                        (this.sessionVariables.labelAngle = U(
                                          this.sessionVariables.labelAngle
                                        )
                                          ? 0
                                          : this.sessionVariables.labelAngle))
                                      : 10 * l < h &&
                                        h < 50 * l &&
                                        (U(this.options.labelFontSize) &&
                                          12 < this.labelFontSize &&
                                          ((this.labelFontSize = Math.floor(
                                            (12 / 13) * this.labelFontSize
                                          )),
                                          t.measureText()),
                                        (this.sessionVariables.labelFontSize =
                                          U(this.options.labelFontSize)
                                            ? this.labelFontSize
                                            : this.options.labelFontSize),
                                        (this.sessionVariables.labelMaxHeight =
                                          l),
                                        (this.sessionVariables.labelMaxWidth =
                                          r),
                                        (this.sessionVariables.labelAngle = U(
                                          this.sessionVariables.labelAngle
                                        )
                                          ? 0
                                          : this.sessionVariables.labelAngle))))
                                : ((this.sessionVariables.labelMaxHeight = l),
                                  (this.sessionVariables.labelMaxWidth = this
                                    .options.labelMaxWidth
                                    ? this.options.labelMaxWidth
                                    : this.sessionVariables.labelMaxWidth)))
                            : ((this.sessionVariables.labelMaxWidth = this
                                .labelWrap
                                ? this.options.labelMaxWidth
                                  ? this.options.labelMaxWidth
                                  : this.sessionVariables.labelMaxWidth
                                : this.labelMaxWidth
                                ? this.options.labelMaxWidth
                                  ? this.options.labelMaxWidth
                                  : this.sessionVariables.labelMaxWidth
                                : r),
                              (this.sessionVariables.labelMaxHeight = l))
                          : ((this.sessionVariables.labelAngle =
                              this.labelAngle),
                            (this.sessionVariables.labelMaxWidth =
                              0 === this.labelAngle
                                ? r
                                : Math.min(
                                    (o -
                                      l *
                                        Math.sin(
                                          (Math.PI / 180) *
                                            Math.abs(this.labelAngle)
                                        )) /
                                      Math.cos(
                                        (Math.PI / 180) *
                                          Math.abs(this.labelAngle)
                                      ),
                                    l
                                  )),
                            U(this.options.labelWrap)
                              ? U(this.options.labelWrap) &&
                                (this.labelWrap &&
                                !U(this.options.labelMaxWidth)
                                  ? ((this.sessionVariables.labelMaxWidth = this
                                      .options.labelMaxWidth
                                      ? this.options.labelMaxWidth >
                                        this.options.labelMaxWidth
                                      : this.sessionVariables.labelMaxWidth),
                                    (this.sessionVariables.labelWrap =
                                      this.labelWrap),
                                    (this.sessionVariables.labelMaxHeight = o))
                                  : ((this.sessionVariables.labelMaxWidth = this
                                      .options.labelMaxWidth
                                      ? this.options.labelMaxWidth
                                      : r),
                                    (this.sessionVariables.labelMaxHeight =
                                      0 === this.labelAngle ? l : o),
                                    U(this.options.labelMaxWidth) &&
                                      (this.sessionVariables.labelAngle =
                                        this.labelAngle)))
                              : this.options.labelWrap
                              ? ((this.sessionVariables.labelMaxHeight =
                                  0 === this.labelAngle ? l : o),
                                (this.sessionVariables.labelWrap =
                                  this.labelWrap),
                                (this.sessionVariables.labelMaxWidth = r))
                              : ((this.sessionVariables.labelMaxHeight = l),
                                U(this.options.labelMaxWidth),
                                (this.sessionVariables.labelMaxWidth = this
                                  .options.labelMaxWidth
                                  ? this.options.labelMaxWidth
                                  : this.sessionVariables.labelMaxWidth),
                                (this.sessionVariables.labelWrap =
                                  this.labelWrap)));
                    }
                  for (o = 0; o < this._labels.length; o++)
                    ((t = this._labels[o].textBlock).maxWidth =
                      this.labelMaxWidth =
                        this.sessionVariables.labelMaxWidth),
                      (t.fontSize = this.labelFontSize =
                        this.sessionVariables.labelFontSize),
                      (t.angle = this.labelAngle =
                        this.sessionVariables.labelAngle),
                      (t.wrap = this.labelWrap =
                        this.sessionVariables.labelWrap),
                      (t.maxHeight = this.sessionVariables.labelMaxHeight),
                      t.measureText();
                } else
                  for (n = 0; n < this._labels.length; n++)
                    ((t = this._labels[n].textBlock).maxWidth =
                      this.labelMaxWidth =
                        U(this.options.labelMaxWidth)
                          ? this.sessionVariables.labelMaxWidth
                          : this.options.labelMaxWidth),
                      (t.fontSize = this.labelFontSize =
                        U(this.options.labelFontSize)
                          ? this.sessionVariables.labelFontSize
                          : this.options.labelFontSize),
                      (t.angle = this.labelAngle =
                        U(this.options.labelAngle)
                          ? this.sessionVariables.labelAngle
                          : this.labelAngle),
                      (t.wrap = this.labelWrap =
                        U(this.options.labelWrap)
                          ? this.sessionVariables.labelWrap
                          : this.options.labelWrap),
                      (t.maxHeight = this.sessionVariables.labelMaxHeight),
                      t.measureText();
            for (n = 0; n < this.stripLines.length; n++) {
              var g;
              "outside" === (r = this.stripLines[n]).labelPlacement
                ? ((l = this.sessionVariables.labelMaxWidth),
                  ("bottom" !== this._position && "top" !== this._position) ||
                    (g = U(r.options.labelWrap)
                      ? this.sessionVariables.labelMaxHeight
                      : r.labelWrap
                      ? (0.8 * this.chart.height) >> 0
                      : 1.5 * this.labelFontSize),
                  ("left" !== this._position && "right" !== this._position) ||
                    (g = U(r.options.labelWrap)
                      ? this.sessionVariables.labelMaxHeight
                      : r.labelWrap
                      ? (0.8 * this.chart.width) >> 0
                      : 1.5 * this.labelFontSize),
                  U(r.labelBackgroundColor) &&
                    (r.labelBackgroundColor = "#EEEEEE"))
                : ((l =
                    "bottom" === this._position || "top" === this._position
                      ? (0.9 * this.chart.width) >> 0
                      : (0.9 * this.chart.height) >> 0),
                  (g =
                    U(r.options.labelWrap) || r.labelWrap
                      ? "bottom" === this._position || "top" === this._position
                        ? (0.8 * this.chart.width) >> 0
                        : (0.8 * this.chart.height) >> 0
                      : 1.5 * this.labelFontSize),
                  U(r.labelBackgroundColor) &&
                    (U(r.startValue) && 0 !== r.startValue
                      ? (r.labelBackgroundColor = Z ? "transparent" : null)
                      : (r.labelBackgroundColor = "#EEEEEE"))),
                (t = new Q(this.ctx, {
                  x: 0,
                  y: 0,
                  backgroundColor: r.labelBackgroundColor,
                  borderColor: r.labelBorderColor,
                  borderThickness: r.labelBorderThickness,
                  cornerRadius: r.labelCornerRadius,
                  maxWidth: r.options.labelMaxWidth
                    ? r.options.labelMaxWidth
                    : l,
                  maxHeight: g,
                  angle: this.labelAngle,
                  text: r.labelFormatter
                    ? r.labelFormatter({
                        chart: this.chart,
                        axis: this,
                        stripLine: r,
                      })
                    : r.label,
                  horizontalAlign: "left",
                  fontSize:
                    "outside" === r.labelPlacement
                      ? r.options.labelFontSize
                        ? r.labelFontSize
                        : this.labelFontSize
                      : r.labelFontSize,
                  fontFamily:
                    "outside" === r.labelPlacement
                      ? r.options.labelFontFamily
                        ? r.labelFontFamily
                        : this.labelFontFamily
                      : r.labelFontFamily,
                  fontWeight:
                    "outside" === r.labelPlacement
                      ? r.options.labelFontWeight
                        ? r.labelFontWeight
                        : this.labelFontWeight
                      : r.labelFontWeight,
                  fontColor: r.labelFontColor || r.color,
                  fontStyle:
                    "outside" === r.labelPlacement
                      ? r.options.labelFontStyle
                        ? r.labelFontStyle
                        : this.fontWeight
                      : r.labelFontStyle,
                  textBaseline: "middle",
                })),
                this._stripLineLabels.push({
                  position: r.value,
                  textBlock: t,
                  effectiveHeight: null,
                  stripLine: r,
                });
            }
          }),
          (v.prototype.createLabelsAndCalculateWidth = function () {
            var t = 0,
              e = 0;
            if (
              ((this._labels = []),
              (this._stripLineLabels = []),
              "left" === this._position || "right" === this._position)
            ) {
              for (this.createLabels(), e = 0; e < this._labels.length; e++) {
                var i = this._labels[e].textBlock,
                  a = i.measureText(),
                  s = 0;
                t <
                  (s =
                    0 === this.labelAngle
                      ? a.width
                      : a.width *
                          Math.cos(
                            (Math.PI / 180) * Math.abs(this.labelAngle)
                          ) +
                        (a.height - i.fontSize / 2) *
                          Math.sin(
                            (Math.PI / 180) * Math.abs(this.labelAngle)
                          )) && (t = s),
                  (this._labels[e].effectiveWidth = s);
              }
              for (e = 0; e < this._stripLineLabels.length; e++)
                "outside" ===
                  this._stripLineLabels[e].stripLine.labelPlacement &&
                  this._stripLineLabels[e].stripLine.value >=
                    this.viewportMinimum &&
                  this._stripLineLabels[e].stripLine.value <=
                    this.viewportMaximum &&
                  ((a = (i = this._stripLineLabels[e].textBlock).measureText()),
                  t <
                    (s =
                      0 === this.labelAngle
                        ? a.width
                        : a.width *
                            Math.cos(
                              (Math.PI / 180) * Math.abs(this.labelAngle)
                            ) +
                          (a.height - i.fontSize / 2) *
                            Math.sin(
                              (Math.PI / 180) * Math.abs(this.labelAngle)
                            )) && (t = s),
                  (this._stripLineLabels[e].effectiveWidth = s));
            }
            return (
              (e = this.title
                ? this._titleTextBlock.measureText().height + 2
                : 0),
              "inside" === this.labelPlacement
                ? (i = e + 5)
                : e + t + this.tickLength + 5
            );
          }),
          (v.prototype.createLabelsAndCalculateHeight = function () {
            var t = 0;
            (this._labels = []), (this._stripLineLabels = []);
            var e,
              i = 0;
            if (
              (this.createLabels(),
              "bottom" === this._position || "top" === this._position)
            ) {
              for (i = 0; i < this._labels.length; i++) {
                var a = (e = this._labels[i].textBlock).measureText(),
                  s = 0;
                t <
                  (s =
                    0 === this.labelAngle
                      ? a.height
                      : a.width *
                          Math.sin(
                            (Math.PI / 180) * Math.abs(this.labelAngle)
                          ) +
                        (a.height - e.fontSize / 2) *
                          Math.cos(
                            (Math.PI / 180) * Math.abs(this.labelAngle)
                          )) && (t = s),
                  (this._labels[i].effectiveHeight = s);
              }
              for (i = 0; i < this._stripLineLabels.length; i++)
                "outside" ===
                  this._stripLineLabels[i].stripLine.labelPlacement &&
                  this._stripLineLabels[i].stripLine.value >=
                    this.viewportMinimum &&
                  this._stripLineLabels[i].stripLine.value <=
                    this.viewportMaximum &&
                  ((a = (e = this._stripLineLabels[i].textBlock).measureText()),
                  t <
                    (s =
                      0 === this.labelAngle
                        ? a.height
                        : a.width *
                            Math.sin(
                              (Math.PI / 180) * Math.abs(this.labelAngle)
                            ) +
                          (a.height - e.fontSize / 2) *
                            Math.cos(
                              (Math.PI / 180) * Math.abs(this.labelAngle)
                            )) && (t = s),
                  (this._stripLineLabels[i].effectiveHeight = s));
            }
            return (
              (e = this.title
                ? this._titleTextBlock.measureText().height + 2
                : 0),
              "inside" === this.labelPlacement
                ? (i = e + 5)
                : e + t + this.tickLength + 5
            );
          }),
          (v.setLayoutAndRender = function (t, e, i, a, s, n) {
            var o,
              r,
              l,
              h,
              d = t[0] ? t[0].chart : e[0].chart,
              c = d.ctx,
              p = d._axes;
            if (t && 0 < t.length)
              for (var u = 0; u < t.length; u++)
                t[u] && t[u].calculateAxisParameters();
            if (e && 0 < e.length)
              for (u = 0; u < e.length; u++) e[u].calculateAxisParameters();
            if (i && 0 < i.length)
              for (u = 0; u < i.length; u++) i[u].calculateAxisParameters();
            if (a && 0 < a.length)
              for (u = 0; u < a.length; u++) a[u].calculateAxisParameters();
            for (u = 0; u < p.length; u++)
              if (
                p[u] &&
                p[u].scaleBreaks &&
                p[u].scaleBreaks._appliedBreaks.length
              )
                for (
                  var x = p[u].scaleBreaks._appliedBreaks, m = 0;
                  m < x.length && !(x[m].startValue > p[u].viewportMaximum);
                  m++
                )
                  x[m].endValue < p[u].viewportMinimum ||
                    (U(p[u].scaleBreaks.firstBreakIndex) &&
                      (p[u].scaleBreaks.firstBreakIndex = m),
                    x[m].startValue >= p[u].viewPortMinimum &&
                      (p[u].scaleBreaks.lastBreakIndex = m));
            var g,
              b,
              v,
              f,
              y,
              M = (m = 0),
              k = 0,
              w = 0,
              T = 0,
              C = 0,
              P = 0,
              S = (r = 0);
            for (x = v = f = y = !1, u = 0; u < p.length; u++)
              p[u] &&
                p[u].title &&
                (p[u]._titleTextBlock = new Q(p[u].ctx, {
                  text: p[u].title,
                  horizontalAlign: "center",
                  fontSize: p[u].titleFontSize,
                  fontFamily: p[u].titleFontFamily,
                  fontWeight: p[u].titleFontWeight,
                  fontColor: p[u].titleFontColor,
                  fontStyle: p[u].titleFontStyle,
                  borderColor: p[u].titleBorderColor,
                  borderThickness: p[u].titleBorderThickness,
                  backgroundColor: p[u].titleBackgroundColor,
                  cornerRadius: p[u].titleCornerRadius,
                  textBaseline: "top",
                }));
            for (u = 0; u < p.length; u++)
              if (p[u].title)
                switch (p[u]._position) {
                  case "left":
                    (p[u]._titleTextBlock.maxWidth =
                      p[u].titleMaxWidth || n.height),
                      (p[u]._titleTextBlock.maxHeight = p[u].titleWrap
                        ? 0.8 * n.width
                        : 1.5 * p[u].titleFontSize),
                      (p[u]._titleTextBlock.angle = -90);
                    break;
                  case "right":
                    (p[u]._titleTextBlock.maxWidth =
                      p[u].titleMaxWidth || n.height),
                      (p[u]._titleTextBlock.maxHeight = p[u].titleWrap
                        ? 0.8 * n.width
                        : 1.5 * p[u].titleFontSize),
                      (p[u]._titleTextBlock.angle = 90);
                    break;
                  default:
                    (p[u]._titleTextBlock.maxWidth =
                      p[u].titleMaxWidth || n.width),
                      (p[u]._titleTextBlock.maxHeight = p[u].titleWrap
                        ? 0.8 * n.height
                        : 1.5 * p[u].titleFontSize),
                      (p[u]._titleTextBlock.angle = 0);
                }
            if ("normal" === s) {
              (w = []), (T = []), (C = []), (P = []);
              for (var A = [], _ = [], B = [], F = []; m < 4; ) {
                var L = 0,
                  I = 0,
                  E = 0,
                  D = 0,
                  V = (s = 0),
                  z = 0,
                  W = 0,
                  X = 0,
                  Y = 0,
                  O = 0,
                  R = 0;
                if (i && 0 < i.length)
                  for (C = [], u = O = 0; u < i.length; u++)
                    C.push(
                      Math.ceil(i[u] ? i[u].createLabelsAndCalculateWidth() : 0)
                    ),
                      (O += C[u]),
                      (z += i[u] ? i[u].margin : 0);
                else
                  C.push(
                    Math.ceil(i[0] ? i[0].createLabelsAndCalculateWidth() : 0)
                  );
                if ((B.push(C), a && 0 < a.length))
                  for (P = [], u = R = 0; u < a.length; u++)
                    P.push(
                      Math.ceil(a[u] ? a[u].createLabelsAndCalculateWidth() : 0)
                    ),
                      (R += P[u]),
                      (W += a[u] ? a[u].margin : 0);
                else
                  P.push(
                    Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0)
                  );
                if (
                  (F.push(P),
                  (o = Math.round(n.x1 + O + z)),
                  (l = Math.round(
                    n.x2 - R - W > d.width - 10 ? d.width - 10 : n.x2 - R - W
                  )),
                  t && 0 < t.length)
                )
                  for (w = [], u = X = 0; u < t.length; u++)
                    t[u] && (t[u].lineCoordinates = {}),
                      (t[u].lineCoordinates.width = Math.abs(l - o)),
                      t[u].title &&
                        (t[u]._titleTextBlock.maxWidth =
                          0 < t[u].titleMaxWidth &&
                          t[u].titleMaxWidth < t[u].lineCoordinates.width
                            ? t[u].titleMaxWidth
                            : t[u].lineCoordinates.width),
                      w.push(
                        Math.ceil(
                          t[u] ? t[u].createLabelsAndCalculateHeight() : 0
                        )
                      ),
                      (X += w[u]),
                      (s += t[u] ? t[u].margin : 0);
                else
                  w.push(
                    Math.ceil(t[0] ? t[0].createLabelsAndCalculateHeight() : 0)
                  );
                if ((A.push(w), e && 0 < e.length))
                  for (T = [], u = Y = 0; u < e.length; u++)
                    e[u] && (e[u].lineCoordinates = {}),
                      (e[u].lineCoordinates.width = Math.abs(l - o)),
                      e[u].title &&
                        (e[u]._titleTextBlock.maxWidth =
                          0 < e[u].titleMaxWidth &&
                          e[u].titleMaxWidth < e[u].lineCoordinates.width
                            ? e[u].titleMaxWidth
                            : e[u].lineCoordinates.width),
                      T.push(
                        Math.ceil(
                          e[u] ? e[u].createLabelsAndCalculateHeight() : 0
                        )
                      ),
                      (Y += T[u]),
                      (V += e[u] ? e[u].margin : 0);
                else
                  T.push(
                    Math.ceil(e[0] ? e[0].createLabelsAndCalculateHeight() : 0)
                  );
                if ((_.push(T), t && 0 < t.length))
                  for (u = 0; u < t.length; u++)
                    t[u] &&
                      ((t[u].lineCoordinates.x1 = o),
                      (l = Math.round(
                        n.x2 - R - W > d.width - 10
                          ? d.width - 10
                          : n.x2 - R - W
                      )),
                      t[u]._labels &&
                        1 < t[u]._labels.length &&
                        ((r = h = 0),
                        (h = t[u]._labels[1]),
                        (r =
                          "dateTime" === t[u].valueType
                            ? t[u]._labels[t[u]._labels.length - 2]
                            : t[u]._labels[t[u]._labels.length - 1]),
                        (M =
                          h.textBlock.width *
                            Math.cos(
                              (Math.PI / 180) * Math.abs(h.textBlock.angle)
                            ) +
                          (h.textBlock.height - r.textBlock.fontSize / 2) *
                            Math.sin(
                              (Math.PI / 180) * Math.abs(h.textBlock.angle)
                            )),
                        (k =
                          r.textBlock.width *
                            Math.cos(
                              (Math.PI / 180) * Math.abs(r.textBlock.angle)
                            ) +
                          (r.textBlock.height - r.textBlock.fontSize / 2) *
                            Math.sin(
                              (Math.PI / 180) * Math.abs(r.textBlock.angle)
                            ))),
                      t[u] &&
                        t[u].labelAutoFit &&
                        !U(g) &&
                        !U(b) &&
                        ((r = 0) < t[u].labelAngle
                          ? l < b + k &&
                            (r += 0 < t[u].labelAngle ? b + k - l - R : 0)
                          : t[u].labelAngle < 0
                          ? g - M < o &&
                            g - M < t[u].viewportMinimum &&
                            (S =
                              o -
                              (z +
                                t[u].tickLength +
                                C +
                                g -
                                M +
                                t[u].labelFontSize / 2))
                          : 0 === t[u].labelAngle &&
                            (l < b + k && (r = b + k / 2 - l - R),
                            g - M < o &&
                              g - M < t[u].viewportMinimum &&
                              (S = o - z - t[u].tickLength - C - g + M / 2)),
                        t[u].viewportMaximum === t[u].maximum &&
                        t[u].viewportMinimum === t[u].minimum &&
                        0 < t[u].labelAngle &&
                        0 < r
                          ? (l -= r)
                          : t[u].viewportMaximum === t[u].maximum &&
                            t[u].viewportMinimum === t[u].minimum &&
                            t[u].labelAngle < 0 &&
                            0 < S
                          ? (o += S)
                          : t[u].viewportMaximum === t[u].maximum &&
                            t[u].viewportMinimum === t[u].minimum &&
                            0 === t[u].labelAngle &&
                            (0 < S && (o += S), 0 < r && (l -= r))),
                      d.panEnabled
                        ? (X = d.sessionVariables.axisX.height)
                        : (d.sessionVariables.axisX.height = X),
                      (r = Math.round(n.y2 - X - s + L)),
                      (h = Math.round(n.y2)),
                      (t[u].lineCoordinates.x2 = l),
                      (t[u].lineCoordinates.width = l - o),
                      (t[u].lineCoordinates.y1 = r),
                      (t[u].lineCoordinates.y2 = r),
                      (t[u].bounds = {
                        x1: o,
                        y1: r,
                        x2: l,
                        y2: h - (X + s - w[u] - L),
                        width: l - o,
                        height: h - r,
                      })),
                      (L += w[u] + t[u].margin);
                if (e && 0 < e.length)
                  for (u = 0; u < e.length; u++)
                    (e[u].lineCoordinates.x1 = Math.round(n.x1 + O + z)),
                      (e[u].lineCoordinates.x2 = Math.round(
                        n.x2 - R - W > d.width - 10
                          ? d.width - 10
                          : n.x2 - R - W
                      )),
                      (e[u].lineCoordinates.width = Math.abs(l - o)),
                      e[u]._labels &&
                        1 < e[u]._labels.length &&
                        ((h = e[u]._labels[1]),
                        (r =
                          "dateTime" === e[u].valueType
                            ? e[u]._labels[e[u]._labels.length - 2]
                            : e[u]._labels[e[u]._labels.length - 1]),
                        (M =
                          h.textBlock.width *
                            Math.cos(
                              (Math.PI / 180) * Math.abs(h.textBlock.angle)
                            ) +
                          (h.textBlock.height - r.textBlock.fontSize / 2) *
                            Math.sin(
                              (Math.PI / 180) * Math.abs(h.textBlock.angle)
                            )),
                        (k =
                          r.textBlock.width *
                            Math.cos(
                              (Math.PI / 180) * Math.abs(r.textBlock.angle)
                            ) +
                          (r.textBlock.height - r.textBlock.fontSize / 2) *
                            Math.sin(
                              (Math.PI / 180) * Math.abs(r.textBlock.angle)
                            ))),
                      d.panEnabled
                        ? (Y = d.sessionVariables.axisX2.height)
                        : (d.sessionVariables.axisX2.height = Y),
                      (r = Math.round(n.y1)),
                      (h = Math.round(n.y2 + e[u].margin)),
                      (e[u].lineCoordinates.y1 = r + Y + V - I),
                      (e[u].lineCoordinates.y2 = r),
                      (e[u].bounds = {
                        x1: o,
                        y1: r + (Y + V - T[u] - I),
                        x2: l,
                        y2: h,
                        width: l - o,
                        height: h - r,
                      }),
                      (I += T[u] + e[u].margin);
                if (i && 0 < i.length)
                  for (u = 0; u < i.length; u++)
                    (z = 10),
                      i[u] &&
                        ((o = Math.round(
                          t[0]
                            ? t[0].lineCoordinates.x1
                            : e[0].lineCoordinates.x1
                        )),
                        (z =
                          i[u]._labels && 0 < i[u]._labels.length
                            ? i[u]._labels[i[u]._labels.length - 1].textBlock
                                .height / 2
                            : 10),
                        (r = Math.round(
                          n.y1 + Y + V < Math.max(z, 10)
                            ? Math.max(z, 10)
                            : n.y1 + Y + V
                        )),
                        (l = Math.round(
                          t[0]
                            ? t[0].lineCoordinates.x1
                            : e[0].lineCoordinates.x1
                        )),
                        (z =
                          0 < t.length
                            ? 0
                            : i[u]._labels && 0 < i[u]._labels.length
                            ? i[u]._labels[0].textBlock.height / 2
                            : 10),
                        (h = Math.round(n.y2 - X - s - z)),
                        (i[u].lineCoordinates = {
                          x1: l - E,
                          y1: r,
                          x2: l - E,
                          y2: h,
                          height: Math.abs(h - r),
                        }),
                        (i[u].bounds = {
                          x1: o - (C[u] + E),
                          y1: r,
                          x2: l,
                          y2: h,
                          width: l - o,
                          height: h - r,
                        }),
                        i[u].title &&
                          (i[u]._titleTextBlock.maxWidth =
                            0 < i[u].titleMaxWidth &&
                            i[u].titleMaxWidth < i[u].lineCoordinates.height
                              ? i[u].titleMaxWidth
                              : i[u].lineCoordinates.height),
                        (E += C[u] + i[u].margin));
                if (a && 0 < a.length)
                  for (u = 0; u < a.length; u++)
                    a[u] &&
                      ((o = Math.round(
                        t[0] ? t[0].lineCoordinates.x2 : e[0].lineCoordinates.x2
                      )),
                      (l = Math.round(o)),
                      (z =
                        a[u]._labels && 0 < a[u]._labels.length
                          ? a[u]._labels[a[u]._labels.length - 1].textBlock
                              .height / 2
                          : 0),
                      (r = Math.round(
                        n.y1 + Y + V < Math.max(z, 10)
                          ? Math.max(z, 10)
                          : n.y1 + Y + V
                      )),
                      (z =
                        0 < t.length
                          ? 0
                          : a[u]._labels && 0 < a[u]._labels.length
                          ? a[u]._labels[0].textBlock.height / 2
                          : 0),
                      (h = Math.round(n.y2 - (X + s + z))),
                      (a[u].lineCoordinates = {
                        x1: o + D,
                        y1: r,
                        x2: o + D,
                        y2: h,
                        height: Math.abs(h - r),
                      }),
                      (a[u].bounds = {
                        x1: o,
                        y1: r,
                        x2: l + (P[u] + D),
                        y2: h,
                        width: l - o,
                        height: h - r,
                      }),
                      a[u].title &&
                        (a[u]._titleTextBlock.maxWidth =
                          0 < a[u].titleMaxWidth &&
                          a[u].titleMaxWidth < a[u].lineCoordinates.height
                            ? a[u].titleMaxWidth
                            : a[u].lineCoordinates.height),
                      (D += P[u] + a[u].margin));
                if (t && 0 < t.length)
                  for (u = 0; u < t.length; u++)
                    t[u] &&
                      (t[u].calculateValueToPixelConversionParameters(),
                      t[u].calculateBreaksSizeInValues(),
                      t[u]._labels &&
                        1 < t[u]._labels.length &&
                        ((g =
                          (t[u].logarithmic
                            ? Math.log(
                                t[u]._labels[1].position / t[u].viewportMinimum
                              ) / t[u].conversionParameters.lnLogarithmBase
                            : t[u]._labels[1].position - t[u].viewportMinimum) *
                            Math.abs(t[u].conversionParameters.pixelPerUnit) +
                          t[u].lineCoordinates.x1),
                        (o =
                          t[u]._labels[
                            t[u]._labels.length -
                              ("dateTime" === t[u].valueType ? 2 : 1)
                          ].position),
                        (o = t[u].getApparentDifference(
                          t[u].viewportMinimum,
                          o
                        )),
                        (b = t[u].logarithmic
                          ? (1 < o
                              ? (Math.log(o) /
                                  t[u].conversionParameters.lnLogarithmBase) *
                                Math.abs(t[u].conversionParameters.pixelPerUnit)
                              : 0) + t[u].lineCoordinates.x1
                          : (0 < o
                              ? o *
                                Math.abs(t[u].conversionParameters.pixelPerUnit)
                              : 0) + t[u].lineCoordinates.x1)));
                if (e && 0 < e.length)
                  for (u = 0; u < e.length; u++)
                    e[u].calculateValueToPixelConversionParameters(),
                      e[u].calculateBreaksSizeInValues(),
                      e[u]._labels &&
                        1 < e[u]._labels.length &&
                        ((g =
                          (e[u].logarithmic
                            ? Math.log(
                                e[u]._labels[1].position / e[u].viewportMinimum
                              ) / e[u].conversionParameters.lnLogarithmBase
                            : e[u]._labels[1].position - e[u].viewportMinimum) *
                            Math.abs(e[u].conversionParameters.pixelPerUnit) +
                          e[u].lineCoordinates.x1),
                        (o =
                          e[u]._labels[
                            e[u]._labels.length -
                              ("dateTime" === e[u].valueType ? 2 : 1)
                          ].position),
                        (o = e[u].getApparentDifference(
                          e[u].viewportMinimum,
                          o
                        )),
                        (b = e[u].logarithmic
                          ? (1 < o
                              ? (Math.log(o) /
                                  e[u].conversionParameters.lnLogarithmBase) *
                                Math.abs(e[u].conversionParameters.pixelPerUnit)
                              : 0) + e[u].lineCoordinates.x1
                          : (0 < o
                              ? o *
                                Math.abs(e[u].conversionParameters.pixelPerUnit)
                              : 0) + e[u].lineCoordinates.x1));
                for (u = 0; u < p.length; u++)
                  "axisY" === p[u].type &&
                    (p[u].calculateValueToPixelConversionParameters(),
                    p[u].calculateBreaksSizeInValues());
                if (0 < m) {
                  if (t && 0 < t.length)
                    for (u = 0; u < t.length; u++) x = A[m - 1][u] === A[m][u];
                  else x = !0;
                  if (e && 0 < e.length)
                    for (u = 0; u < e.length; u++) v = _[m - 1][u] === _[m][u];
                  else v = !0;
                  if (i && 0 < i.length)
                    for (u = 0; u < i.length; u++) f = B[m - 1][u] === B[m][u];
                  else f = !0;
                  if (a && 0 < a.length)
                    for (u = 0; u < a.length; u++) y = F[m - 1][u] === F[m][u];
                  else y = !0;
                }
                if (x && v && f && y) break;
                m++;
              }
              if (
                (c.save(),
                c.beginPath(),
                t[0] &&
                  c.rect(
                    5,
                    t[0].bounds.y1,
                    t[0].chart.width - 10,
                    t[0].bounds.height
                  ),
                e[0] &&
                  c.rect(
                    5,
                    e[e.length - 1].bounds.y1,
                    e[0].chart.width - 10,
                    e[0].bounds.height
                  ),
                c.clip(),
                t && 0 < t.length)
              )
                for (u = 0; u < t.length; u++)
                  t[u].calculateStripLinesThicknessInValues(),
                    t[u].calculateBreaksInPixels(),
                    t[u].renderLabelsTicksAndTitle();
              if (e && 0 < e.length)
                for (u = 0; u < e.length; u++)
                  e[u].calculateStripLinesThicknessInValues(),
                    e[u].calculateBreaksInPixels(),
                    e[u].renderLabelsTicksAndTitle();
              if ((c.restore(), i && 0 < i.length))
                for (u = 0; u < i.length; u++)
                  i[u].calculateStripLinesThicknessInValues(),
                    i[u].calculateBreaksInPixels(),
                    i[u].renderLabelsTicksAndTitle();
              if (a && 0 < a.length)
                for (u = 0; u < a.length; u++)
                  a[u].calculateStripLinesThicknessInValues(),
                    a[u].calculateBreaksInPixels(),
                    a[u].renderLabelsTicksAndTitle();
            } else {
              for (
                g = [], S = [], M = [], b = [], k = [], A = [], _ = [], B = [];
                m < 4;

              ) {
                if (
                  ((Y = X = O = D = W = z = V = s = E = F = I = L = 0),
                  t && 0 < t.length)
                )
                  for (M = [], u = X = 0; u < t.length; u++)
                    M.push(
                      Math.ceil(t[u] ? t[u].createLabelsAndCalculateWidth() : 0)
                    ),
                      (X += M[u]),
                      (s += t[u] ? t[u].margin : 0);
                else
                  M.push(
                    Math.ceil(t[0] ? t[0].createLabelsAndCalculateWidth() : 0)
                  );
                if ((_.push(M), e && 0 < e.length))
                  for (b = [], u = Y = 0; u < e.length; u++)
                    b.push(
                      Math.ceil(e[u] ? e[u].createLabelsAndCalculateWidth() : 0)
                    ),
                      (Y += b[u]),
                      (V += e[u] ? e[u].margin : 0);
                else
                  b.push(
                    Math.ceil(e[0] ? e[0].createLabelsAndCalculateWidth() : 0)
                  );
                if ((B.push(b), i && 0 < i.length))
                  for (u = 0; u < i.length; u++)
                    (i[u].lineCoordinates = {}),
                      (o = Math.round(n.x1 + X + s)),
                      (l = Math.round(
                        n.x2 - Y - V > d.width - 10
                          ? d.width - 10
                          : n.x2 - Y - V
                      )),
                      i[u].labelAutoFit &&
                        !U(w) &&
                        (0 < !t.length &&
                          (o =
                            i[u].labelAngle < 0
                              ? Math.max(o, w)
                              : 0 === i[u].labelAngle
                              ? Math.max(o, w / 2)
                              : o),
                        0 < !e.length &&
                          (l =
                            0 < i[u].labelAngle
                              ? l - T / 2
                              : 0 === i[u].labelAngle
                              ? l - T / 2
                              : l)),
                      (i[u].lineCoordinates.x1 = o),
                      (i[u].lineCoordinates.x2 = l),
                      (i[u].lineCoordinates.width = Math.abs(l - o)),
                      i[u].title &&
                        (i[u]._titleTextBlock.maxWidth =
                          0 < i[u].titleMaxWidth &&
                          i[u].titleMaxWidth < i[u].lineCoordinates.width
                            ? i[u].titleMaxWidth
                            : i[u].lineCoordinates.width);
                if (a && 0 < a.length)
                  for (u = 0; u < a.length; u++)
                    (a[u].lineCoordinates = {}),
                      (o = Math.round(n.x1 + X + s)),
                      (l = Math.round(
                        n.x2 - Y - V > a[u].chart.width - 10
                          ? a[u].chart.width - 10
                          : n.x2 - Y - V
                      )),
                      a[u] &&
                        a[u].labelAutoFit &&
                        !U(C) &&
                        (0 < !t.length &&
                          (o =
                            0 < a[u].labelAngle
                              ? Math.max(o, C)
                              : 0 === a[u].labelAngle
                              ? Math.max(o, C / 2)
                              : o),
                        0 < !e.length && (l -= P / 2)),
                      (a[u].lineCoordinates.x1 = o),
                      (a[u].lineCoordinates.x2 = l),
                      (a[u].lineCoordinates.width = Math.abs(l - o)),
                      a[u].title &&
                        (a[u]._titleTextBlock.maxWidth =
                          0 < a[u].titleMaxWidth &&
                          a[u].titleMaxWidth < a[u].lineCoordinates.width
                            ? a[u].titleMaxWidth
                            : a[u].lineCoordinates.width);
                if (i && 0 < i.length)
                  for (g = [], u = D = 0; u < i.length; u++)
                    g.push(
                      Math.ceil(
                        i[u] ? i[u].createLabelsAndCalculateHeight() : 0
                      )
                    ),
                      (D += g[u] + i[u].margin),
                      (z += i[u].margin);
                else
                  g.push(
                    Math.ceil(i[0] ? i[0].createLabelsAndCalculateHeight() : 0)
                  );
                if ((k.push(g), a && 0 < a.length))
                  for (S = [], u = O = 0; u < a.length; u++)
                    S.push(
                      Math.ceil(
                        a[u] ? a[u].createLabelsAndCalculateHeight() : 0
                      )
                    ),
                      (O += S[u]),
                      (W += a[u].margin);
                else
                  S.push(
                    Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0)
                  );
                if ((A.push(S), i && 0 < i.length))
                  for (u = 0; u < i.length; u++)
                    0 < i[u]._labels.length &&
                      ((h = i[u]._labels[0]),
                      (r = i[u]._labels[i[u]._labels.length - 1]),
                      (w =
                        h.textBlock.width *
                          Math.cos(
                            (Math.PI / 180) * Math.abs(h.textBlock.angle)
                          ) +
                        (h.textBlock.height - r.textBlock.fontSize / 2) *
                          Math.sin(
                            (Math.PI / 180) * Math.abs(h.textBlock.angle)
                          )),
                      (T =
                        r.textBlock.width *
                          Math.cos(
                            (Math.PI / 180) * Math.abs(r.textBlock.angle)
                          ) +
                        (r.textBlock.height - r.textBlock.fontSize / 2) *
                          Math.sin(
                            (Math.PI / 180) * Math.abs(r.textBlock.angle)
                          )));
                if (a && 0 < a.length)
                  for (u = 0; u < a.length; u++)
                    a[u] &&
                      0 < a[u]._labels.length &&
                      ((h = a[u]._labels[0]),
                      (r = a[u]._labels[a[u]._labels.length - 1]),
                      (C =
                        h.textBlock.width *
                          Math.cos(
                            (Math.PI / 180) * Math.abs(h.textBlock.angle)
                          ) +
                        (h.textBlock.height - r.textBlock.fontSize / 2) *
                          Math.sin(
                            (Math.PI / 180) * Math.abs(h.textBlock.angle)
                          )),
                      (P =
                        r.textBlock.width *
                          Math.cos(
                            (Math.PI / 180) * Math.abs(r.textBlock.angle)
                          ) +
                        (r.textBlock.height - r.textBlock.fontSize / 2) *
                          Math.sin(
                            (Math.PI / 180) * Math.abs(r.textBlock.angle)
                          )));
                if (d.panEnabled)
                  for (u = 0; u < i.length; u++)
                    g[u] = d.sessionVariables.axisY.height;
                else
                  for (u = 0; u < i.length; u++)
                    d.sessionVariables.axisY.height = g[u];
                if (i && 0 < i.length)
                  for (u = i.length - 1; 0 <= u; u--)
                    (r = Math.round(n.y2)),
                      (h = Math.round(
                        n.y2 > i[u].chart.height - 10
                          ? i[u].chart.height - 10
                          : n.y2
                      )),
                      (i[u].lineCoordinates.y1 = r - (g[u] + i[u].margin + L)),
                      (i[u].lineCoordinates.y2 = r - (g[u] + i[u].margin + L)),
                      (i[u].bounds = {
                        x1: o,
                        y1: r - (g[u] + L + i[u].margin),
                        x2: l,
                        y2: h - (L + i[u].margin),
                        width: l - o,
                        height: g[u],
                      }),
                      i[u].title &&
                        (i[u]._titleTextBlock.maxWidth =
                          0 < i[u].titleMaxWidth &&
                          i[u].titleMaxWidth < i[u].lineCoordinates.width
                            ? i[u].titleMaxWidth
                            : i[u].lineCoordinates.width),
                      (L += g[u] + i[u].margin);
                if (a && 0 < a.length)
                  for (u = a.length - 1; 0 <= u; u--)
                    a[u] &&
                      ((r = Math.round(n.y1)),
                      (h = Math.round(n.y1 + (S[u] + a[u].margin + I))),
                      (a[u].lineCoordinates.y1 = h),
                      (a[u].lineCoordinates.y2 = h),
                      (a[u].bounds = {
                        x1: o,
                        y1: r + (a[u].margin + I),
                        x2: l,
                        y2: h,
                        width: l - o,
                        height: O,
                      }),
                      a[u].title &&
                        (a[u]._titleTextBlock.maxWidth =
                          0 < a[u].titleMaxWidth &&
                          a[u].titleMaxWidth < a[u].lineCoordinates.width
                            ? a[u].titleMaxWidth
                            : a[u].lineCoordinates.width),
                      (I += S[u] + a[u].margin));
                if (t && 0 < t.length)
                  for (u = 0; u < t.length; u++) {
                    if (
                      ((z =
                        t[u]._labels && 0 < t[u]._labels.length
                          ? t[u]._labels[0].textBlock.fontSize / 2
                          : 0),
                      (o = Math.round(n.x1 + s)),
                      (r =
                        a && 0 < a.length
                          ? Math.round(
                              a[0]
                                ? a[0].lineCoordinates.y2
                                : n.y1 < Math.max(z, 10)
                                ? Math.max(z, 10)
                                : n.y1
                            )
                          : n.y1 < Math.max(z, 10)
                          ? Math.max(z, 10)
                          : n.y1),
                      (l = Math.round(n.x1 + X + s)),
                      (h =
                        i && 0 < i.length
                          ? Math.round(
                              i[0]
                                ? i[0].lineCoordinates.y1
                                : n.y2 - D > d.height - Math.max(z, 10)
                                ? d.height - Math.max(z, 10)
                                : n.y2 - D
                            )
                          : n.y2 > d.height - Math.max(z, 10)
                          ? d.height - Math.max(z, 10)
                          : n.y2),
                      i && 0 < i.length)
                    )
                      for (z = 0; z < i.length; z++)
                        i[z] &&
                          i[z].labelAutoFit &&
                          ((l =
                            i[z].labelAngle < 0
                              ? Math.max(l, w)
                              : 0 === i[z].labelAngle
                              ? Math.max(l, w / 2)
                              : l),
                          (o =
                            i[z].labelAngle < 0 || 0 === i[z].labelAngle
                              ? l - X
                              : o));
                    if (a && 0 < a.length)
                      for (z = 0; z < a.length; z++)
                        a[z] &&
                          a[z].labelAutoFit &&
                          (o = (l = a[z].lineCoordinates.x1) - X);
                    (t[u].lineCoordinates = {
                      x1: l - F,
                      y1: r,
                      x2: l - F,
                      y2: h,
                      height: Math.abs(h - r),
                    }),
                      (t[u].bounds = {
                        x1: l - (M[u] + F),
                        y1: r,
                        x2: l,
                        y2: h,
                        width: l - o,
                        height: h - r,
                      }),
                      t[u].title &&
                        (t[u]._titleTextBlock.maxWidth =
                          0 < t[u].titleMaxWidth &&
                          t[u].titleMaxWidth < t[u].lineCoordinates.height
                            ? t[u].titleMaxWidth
                            : t[u].lineCoordinates.height),
                      t[u].calculateValueToPixelConversionParameters(),
                      t[u].calculateBreaksSizeInValues(),
                      (F += M[u] + t[u].margin);
                  }
                if (e && 0 < e.length)
                  for (u = 0; u < e.length; u++) {
                    if (
                      ((z =
                        e[u]._labels && 0 < e[u]._labels.length
                          ? e[u]._labels[0].textBlock.fontSize / 2
                          : 0),
                      (o = Math.round(n.x1 - s)),
                      (r =
                        a && 0 < a.length
                          ? Math.round(
                              a[0]
                                ? a[0].lineCoordinates.y2
                                : n.y1 < Math.max(z, 10)
                                ? Math.max(z, 10)
                                : n.y1
                            )
                          : n.y1 < Math.max(z, 10)
                          ? Math.max(z, 10)
                          : n.y1),
                      (l = Math.round(n.x2 - Y - V)),
                      (h =
                        i && 0 < i.length
                          ? Math.round(
                              i[0]
                                ? i[0].lineCoordinates.y1
                                : n.y2 - D > d.height - Math.max(z, 10)
                                ? d.height - Math.max(z, 10)
                                : n.y2 - D
                            )
                          : n.y2 > d.height - Math.max(z, 10)
                          ? d.height - Math.max(z, 10)
                          : n.y2),
                      i && 0 < i.length)
                    )
                      for (z = 0; z < i.length; z++)
                        i[z] &&
                          i[z].labelAutoFit &&
                          ((l =
                            i[z].labelAngle < 0
                              ? Math.max(l, w)
                              : 0 === i[z].labelAngle
                              ? Math.max(l, w / 2)
                              : l),
                          (o =
                            i[z].labelAngle < 0 || 0 === i[z].labelAngle
                              ? l - Y
                              : o));
                    if (a && 0 < a.length)
                      for (z = 0; z < a.length; z++)
                        a[z] &&
                          a[z].labelAutoFit &&
                          (o = (l = a[z].lineCoordinates.x2) - Y);
                    (e[u].lineCoordinates = {
                      x1: l + E,
                      y1: r,
                      x2: l + E,
                      y2: h,
                      height: Math.abs(h - r),
                    }),
                      (e[u].bounds = {
                        x1: o,
                        y1: r,
                        x2: l + b[u] + E,
                        y2: h,
                        width: l - o,
                        height: h - r,
                      }),
                      e[u].title &&
                        (e[u]._titleTextBlock.maxWidth =
                          0 < e[u].titleMaxWidth &&
                          e[u].titleMaxWidth < e[u].lineCoordinates.height
                            ? e[u].titleMaxWidth
                            : e[u].lineCoordinates.height),
                      e[u].calculateValueToPixelConversionParameters(),
                      e[u].calculateBreaksSizeInValues(),
                      (E += b[u] + e[u].margin);
                  }
                for (u = 0; u < p.length; u++)
                  "axisY" === p[u].type &&
                    (p[u].calculateValueToPixelConversionParameters(),
                    p[u].calculateBreaksSizeInValues());
                if (0 < m) {
                  if (t && 0 < t.length)
                    for (u = 0; u < t.length; u++) x = _[m - 1][u] === _[m][u];
                  else x = !0;
                  if (e && 0 < e.length)
                    for (u = 0; u < e.length; u++) v = B[m - 1][u] === B[m][u];
                  else v = !0;
                  if (i && 0 < i.length)
                    for (u = 0; u < i.length; u++) f = k[m - 1][u] === k[m][u];
                  else f = !0;
                  if (a && 0 < a.length)
                    for (u = 0; u < a.length; u++) y = A[m - 1][u] === A[m][u];
                  else y = !0;
                }
                if (x && v && f && y) break;
                m++;
              }
              if (i && 0 < i.length)
                for (u = 0; u < i.length; u++)
                  i[u].calculateStripLinesThicknessInValues(),
                    i[u].calculateBreaksInPixels(),
                    i[u].renderLabelsTicksAndTitle();
              if (a && 0 < a.length)
                for (u = 0; u < a.length; u++)
                  a[u].calculateStripLinesThicknessInValues(),
                    a[u].calculateBreaksInPixels(),
                    a[u].renderLabelsTicksAndTitle();
              if (t && 0 < t.length)
                for (u = 0; u < t.length; u++)
                  t[u].calculateStripLinesThicknessInValues(),
                    t[u].calculateBreaksInPixels(),
                    t[u].renderLabelsTicksAndTitle();
              if (e && 0 < e.length)
                for (u = 0; u < e.length; u++)
                  e[u].calculateStripLinesThicknessInValues(),
                    e[u].calculateBreaksInPixels(),
                    e[u].renderLabelsTicksAndTitle();
            }
            if (
              (d.preparePlotArea(),
              (n = d.plotArea),
              c.save(),
              c.beginPath(),
              c.rect(n.x1, n.y1, Math.abs(n.x2 - n.x1), Math.abs(n.y2 - n.y1)),
              c.clip(),
              t && 0 < t.length)
            )
              for (u = 0; u < p.length; u++)
                p[u].renderStripLinesOfThicknessType("value");
            if (e && 0 < e.length)
              for (u = 0; u < e.length; u++)
                e[u].renderStripLinesOfThicknessType("value");
            if (i && 0 < i.length)
              for (u = 0; u < i.length; u++)
                i[u].renderStripLinesOfThicknessType("value");
            if (a && 0 < a.length)
              for (u = 0; u < a.length; u++)
                a[u].renderStripLinesOfThicknessType("value");
            if (t && 0 < t.length)
              for (u = 0; u < t.length; u++) t[u].renderInterlacedColors();
            if (e && 0 < e.length)
              for (u = 0; u < e.length; u++) e[u].renderInterlacedColors();
            if (i && 0 < i.length)
              for (u = 0; u < i.length; u++) i[u].renderInterlacedColors();
            if (a && 0 < a.length)
              for (u = 0; u < a.length; u++) a[u].renderInterlacedColors();
            if ((c.restore(), t && 0 < t.length))
              for (u = 0; u < t.length; u++)
                t[u].renderGrid(),
                  Z && (t[u].createMask(), t[u].renderBreaksBackground());
            if (e && 0 < e.length)
              for (u = 0; u < e.length; u++)
                e[u].renderGrid(),
                  Z && (e[u].createMask(), e[u].renderBreaksBackground());
            if (i && 0 < i.length)
              for (u = 0; u < i.length; u++)
                i[u].renderGrid(),
                  Z && (i[u].createMask(), i[u].renderBreaksBackground());
            if (a && 0 < a.length)
              for (u = 0; u < a.length; u++)
                a[u].renderGrid(),
                  Z && (a[u].createMask(), a[u].renderBreaksBackground());
            if (t && 0 < t.length)
              for (u = 0; u < t.length; u++) t[u].renderAxisLine();
            if (e && 0 < e.length)
              for (u = 0; u < e.length; u++) e[u].renderAxisLine();
            if (i && 0 < i.length)
              for (u = 0; u < i.length; u++) i[u].renderAxisLine();
            if (a && 0 < a.length)
              for (u = 0; u < a.length; u++) a[u].renderAxisLine();
            if (t && 0 < t.length)
              for (u = 0; u < t.length; u++)
                t[u].renderStripLinesOfThicknessType("pixel");
            if (e && 0 < e.length)
              for (u = 0; u < e.length; u++)
                e[u].renderStripLinesOfThicknessType("pixel");
            if (i && 0 < i.length)
              for (u = 0; u < i.length; u++)
                i[u].renderStripLinesOfThicknessType("pixel");
            if (a && 0 < a.length)
              for (u = 0; u < a.length; u++)
                a[u].renderStripLinesOfThicknessType("pixel");
          }),
          (v.prototype.calculateStripLinesThicknessInValues = function () {
            for (var t = 0; t < this.stripLines.length; t++)
              if (
                null !== this.stripLines[t].startValue &&
                null !== this.stripLines[t].endValue
              ) {
                var e = Math.min(
                    this.stripLines[t].startValue,
                    this.stripLines[t].endValue
                  ),
                  i = Math.max(
                    this.stripLines[t].startValue,
                    this.stripLines[t].endValue
                  );
                e = this.getApparentDifference(e, i);
                (this.stripLines[t].value = this.logarithmic
                  ? this.stripLines[t].value *
                    Math.sqrt(
                      Math.log(
                        this.stripLines[t].endValue /
                          this.stripLines[t].startValue
                      ) / Math.log(e)
                    )
                  : this.stripLines[t].value +
                    (Math.abs(
                      this.stripLines[t].endValue -
                        this.stripLines[t].startValue
                    ) -
                      e) /
                      2),
                  (this.stripLines[t].thickness = e),
                  (this.stripLines[t]._thicknessType = "value");
              }
          }),
          (v.prototype.calculateBreaksSizeInValues = function () {
            for (
              var t,
                e =
                  "left" === this._position || "right" === this._position
                    ? this.lineCoordinates.height || this.chart.height
                    : this.lineCoordinates.width || this.chart.width,
                i = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],
                a =
                  this.conversionParameters.pixelPerUnit ||
                  e /
                    (this.logarithmic
                      ? this.conversionParameters.maximum /
                        this.conversionParameters.minimum
                      : this.conversionParameters.maximum -
                        this.conversionParameters.minimum),
                s = this.scaleBreaks && !U(this.scaleBreaks.options.spacing),
                n = 0;
              n < i.length;
              n++
            )
              (t = s || !U(i[n].options.spacing)),
                (i[n].spacing =
                  l(i[n].spacing, e, 8, t ? 0.1 * e : 8, t ? 0 : 3) << 0),
                (i[n].size = i[n].spacing < 0 ? 0 : Math.abs(i[n].spacing / a)),
                this.logarithmic &&
                  (i[n].size = Math.pow(this.logarithmBase, i[n].size));
          }),
          (v.prototype.calculateBreaksInPixels = function () {
            if (
              !(this.scaleBreaks && this.scaleBreaks._appliedBreaks.length <= 0)
            ) {
              var t = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
              t.length &&
                (this.scaleBreaks.firstBreakIndex =
                  this.scaleBreaks.lastBreakIndex =
                    null);
              for (
                var e = 0;
                e < t.length &&
                !(t[e].startValue > this.conversionParameters.maximum);
                e++
              )
                t[e].endValue < this.conversionParameters.minimum ||
                  (U(this.scaleBreaks.firstBreakIndex) &&
                    (this.scaleBreaks.firstBreakIndex = e),
                  t[e].startValue >= this.conversionParameters.minimum &&
                    ((t[e].startPixel = this.convertValueToPixel(
                      t[e].startValue
                    )),
                    (this.scaleBreaks.lastBreakIndex = e)),
                  t[e].endValue <= this.conversionParameters.maximum &&
                    (t[e].endPixel = this.convertValueToPixel(t[e].endValue)));
            }
          }),
          (v.prototype.renderLabelsTicksAndTitle = function () {
            var e = this,
              i = !1,
              t = 0,
              a = 0,
              s = 1,
              n = 0;
            if (
              (0 !== this.labelAngle && 360 !== this.labelAngle && (s = 1.2),
              void 0 === this.options.interval)
            ) {
              if ("bottom" === this._position || "top" === this._position)
                if (
                  this.logarithmic &&
                  !this.equidistantInterval &&
                  this.labelAutoFit
                ) {
                  (t = []),
                    (s =
                      0 !== this.labelAngle && 360 !== this.labelAngle
                        ? 1
                        : 1.2);
                  for (
                    var o,
                      r = this.viewportMaximum,
                      l = this.lineCoordinates.width / Math.log(this.range),
                      h = this._labels.length - 1;
                    0 <= h &&
                    !((c = this._labels[h]).position < this.viewportMinimum);
                    h--
                  )
                    c.position > this.viewportMaximum ||
                      !(
                        h === this._labels.length - 1 ||
                        o < (Math.log(r / c.position) * l) / s
                      ) ||
                      (t.push(c),
                      (r = c.position),
                      (o =
                        c.textBlock.width *
                          Math.abs(
                            Math.cos((Math.PI / 180) * this.labelAngle)
                          ) +
                        c.textBlock.height *
                          Math.abs(
                            Math.sin((Math.PI / 180) * this.labelAngle)
                          )));
                  this._labels = t;
                } else {
                  for (h = 0; h < this._labels.length; h++)
                    (c = this._labels[h]).position < this.viewportMinimum ||
                      (t += o =
                        c.textBlock.width *
                          Math.abs(
                            Math.cos((Math.PI / 180) * this.labelAngle)
                          ) +
                        c.textBlock.height *
                          Math.abs(
                            Math.sin((Math.PI / 180) * this.labelAngle)
                          ));
                  t > this.lineCoordinates.width * s &&
                    this.labelAutoFit &&
                    (i = !0);
                }
              if ("left" === this._position || "right" === this._position)
                if (
                  this.logarithmic &&
                  !this.equidistantInterval &&
                  this.labelAutoFit
                ) {
                  var d;
                  for (
                    t = [],
                      r = this.viewportMaximum,
                      l = this.lineCoordinates.height / Math.log(this.range),
                      h = this._labels.length - 1;
                    0 <= h &&
                    !((c = this._labels[h]).position < this.viewportMinimum);
                    h--
                  )
                    c.position > this.viewportMaximum ||
                      !(
                        h === this._labels.length - 1 ||
                        d < Math.log(r / c.position) * l
                      ) ||
                      (t.push(c),
                      (r = c.position),
                      (d =
                        c.textBlock.height *
                          Math.abs(
                            Math.cos((Math.PI / 180) * this.labelAngle)
                          ) +
                        c.textBlock.width *
                          Math.abs(
                            Math.sin((Math.PI / 180) * this.labelAngle)
                          )));
                  this._labels = t;
                } else {
                  for (h = 0; h < this._labels.length; h++)
                    (c = this._labels[h]).position < this.viewportMinimum ||
                      (a += d =
                        c.textBlock.height *
                          Math.abs(
                            Math.cos((Math.PI / 180) * this.labelAngle)
                          ) +
                        c.textBlock.width *
                          Math.abs(
                            Math.sin((Math.PI / 180) * this.labelAngle)
                          ));
                  a > this.lineCoordinates.height * s &&
                    this.labelAutoFit &&
                    (i = !0);
                }
            }
            this.logarithmic &&
              !this.equidistantInterval &&
              this.labelAutoFit &&
              this._labels.sort(function (t, e) {
                return t.position - e.position;
              });
            var c, p;
            h = 0;
            if ("bottom" === this._position) {
              for (h = 0; h < this._labels.length; h++)
                (c = this._labels[h]).position < this.viewportMinimum ||
                  c.position > this.viewportMaximum ||
                  (i && 0 != n++ % 2 && this.labelAutoFit) ||
                  ((p = this.getPixelCoordinatesOnAxis(c.position)),
                  this.tickThickness &&
                    "inside" != this.labelPlacement &&
                    ((this.ctx.lineWidth = this.tickThickness),
                    (this.ctx.strokeStyle = this.tickColor),
                    (a =
                      1 == this.ctx.lineWidth % 2
                        ? 0.5 + (p.x << 0)
                        : p.x << 0),
                    this.ctx.beginPath(),
                    this.ctx.moveTo(a, p.y << 0),
                    this.ctx.lineTo(a, (p.y + this.tickLength) << 0),
                    this.ctx.stroke()),
                  0 === c.textBlock.angle
                    ? ((p.x -= c.textBlock.width / 2),
                      (p.y =
                        "inside" === this.labelPlacement
                          ? p.y - (this.tickLength + c.textBlock.fontSize / 2)
                          : p.y + this.tickLength + c.textBlock.fontSize / 2))
                    : ((p.x =
                        "inside" === this.labelPlacement
                          ? this.labelAngle < 0
                            ? p.x
                            : p.x -
                              c.textBlock.width *
                                Math.cos((Math.PI / 180) * this.labelAngle)
                          : p.x -
                            (this.labelAngle < 0
                              ? c.textBlock.width *
                                Math.cos((Math.PI / 180) * this.labelAngle)
                              : 0)),
                      (p.y =
                        "inside" === this.labelPlacement
                          ? this.labelAngle < 0
                            ? p.y - this.tickLength - 5
                            : p.y -
                              this.tickLength -
                              Math.abs(
                                c.textBlock.width *
                                  Math.sin((Math.PI / 180) * this.labelAngle) +
                                  5
                              )
                          : p.y +
                            this.tickLength +
                            Math.abs(
                              this.labelAngle < 0
                                ? c.textBlock.width *
                                    Math.sin(
                                      (Math.PI / 180) * this.labelAngle
                                    ) -
                                    5
                                : 5
                            ))),
                  (c.textBlock.x = p.x),
                  (c.textBlock.y = p.y));
              "inside" === this.labelPlacement &&
                this.chart.addEventListener(
                  "dataAnimationIterationEnd",
                  function () {
                    for (h = 0; h < e._labels.length; h++)
                      if (
                        !(
                          (c = e._labels[h]).position < e.viewportMinimum ||
                          c.position > e.viewportMaximum ||
                          (i && 0 != n++ % 2 && e.labelAutoFit)
                        ) &&
                        ((p = e.getPixelCoordinatesOnAxis(c.position)),
                        e.tickThickness)
                      ) {
                        (e.ctx.lineWidth = e.tickThickness),
                          (e.ctx.strokeStyle = e.tickColor);
                        var t =
                          1 == e.ctx.lineWidth % 2
                            ? 0.5 + (p.x << 0)
                            : p.x << 0;
                        e.ctx.save(),
                          e.ctx.beginPath(),
                          e.ctx.moveTo(t, p.y << 0),
                          e.ctx.lineTo(t, (p.y - e.tickLength) << 0),
                          e.ctx.stroke(),
                          e.ctx.restore();
                      }
                  },
                  this
                ),
                this.title &&
                  (this._titleTextBlock.measureText(),
                  (this._titleTextBlock.x =
                    this.lineCoordinates.x1 +
                    this.lineCoordinates.width / 2 -
                    this._titleTextBlock.width / 2),
                  (this._titleTextBlock.y =
                    this.bounds.y2 - this._titleTextBlock.height - 3),
                  (this.titleMaxWidth = this._titleTextBlock.maxWidth),
                  this._titleTextBlock.render(!0));
            } else if ("top" === this._position) {
              for (h = 0; h < this._labels.length; h++)
                (c = this._labels[h]).position < this.viewportMinimum ||
                  c.position > this.viewportMaximum ||
                  (i && 0 != n++ % 2 && this.labelAutoFit) ||
                  ((p = this.getPixelCoordinatesOnAxis(c.position)),
                  this.tickThickness &&
                    "inside" != this.labelPlacement &&
                    ((this.ctx.lineWidth = this.tickThickness),
                    (this.ctx.strokeStyle = this.tickColor),
                    (a =
                      1 == this.ctx.lineWidth % 2
                        ? 0.5 + (p.x << 0)
                        : p.x << 0),
                    this.ctx.beginPath(),
                    this.ctx.moveTo(a, p.y << 0),
                    this.ctx.lineTo(a, (p.y - this.tickLength) << 0),
                    this.ctx.stroke()),
                  0 === c.textBlock.angle
                    ? ((p.x -= c.textBlock.width / 2),
                      (p.y =
                        "inside" === this.labelPlacement
                          ? p.y + this.labelFontSize / 2 + this.tickLength + 5
                          : p.y -
                            (this.tickLength +
                              c.textBlock.height -
                              c.textBlock.fontSize / 2)))
                    : ((p.x =
                        "inside" === this.labelPlacement
                          ? 0 < this.labelAngle
                            ? p.x
                            : p.x -
                              c.textBlock.width *
                                Math.cos((Math.PI / 180) * this.labelAngle)
                          : p.x +
                            (c.textBlock.height -
                              this.tickLength -
                              this.labelFontSize) *
                              Math.sin((Math.PI / 180) * this.labelAngle) -
                            (0 < this.labelAngle
                              ? c.textBlock.width *
                                Math.cos((Math.PI / 180) * this.labelAngle)
                              : 0)),
                      (p.y =
                        "inside" === this.labelPlacement
                          ? 0 < this.labelAngle
                            ? p.y + this.tickLength + 5
                            : p.y -
                              c.textBlock.width *
                                Math.sin((Math.PI / 180) * this.labelAngle) +
                              this.tickLength +
                              5
                          : p.y -
                            (this.tickLength +
                              ((c.textBlock.height - c.textBlock.fontSize / 2) *
                                Math.cos((Math.PI / 180) * this.labelAngle) +
                                (0 < this.labelAngle
                                  ? c.textBlock.width *
                                    Math.sin((Math.PI / 180) * this.labelAngle)
                                  : 0))))),
                  (c.textBlock.x = p.x),
                  (c.textBlock.y = p.y));
              "inside" === this.labelPlacement &&
                this.chart.addEventListener(
                  "dataAnimationIterationEnd",
                  function () {
                    for (h = 0; h < e._labels.length; h++)
                      if (
                        !(
                          (c = e._labels[h]).position < e.viewportMinimum ||
                          c.position > e.viewportMaximum ||
                          (i && 0 != n++ % 2 && e.labelAutoFit)
                        ) &&
                        ((p = e.getPixelCoordinatesOnAxis(c.position)),
                        e.tickThickness)
                      ) {
                        (e.ctx.lineWidth = e.tickThickness),
                          (e.ctx.strokeStyle = e.tickColor);
                        var t =
                          1 == this.ctx.lineWidth % 2
                            ? 0.5 + (p.x << 0)
                            : p.x << 0;
                        e.ctx.save(),
                          e.ctx.beginPath(),
                          e.ctx.moveTo(t, p.y << 0),
                          e.ctx.lineTo(t, (p.y + e.tickLength) << 0),
                          e.ctx.stroke(),
                          e.ctx.restore();
                      }
                  },
                  this
                ),
                this.title &&
                  (this._titleTextBlock.measureText(),
                  (this._titleTextBlock.x =
                    this.lineCoordinates.x1 +
                    this.lineCoordinates.width / 2 -
                    this._titleTextBlock.width / 2),
                  (this._titleTextBlock.y = this.bounds.y1 + 1),
                  (this.titleMaxWidth = this._titleTextBlock.maxWidth),
                  this._titleTextBlock.render(!0));
            } else if ("left" === this._position) {
              for (h = 0; h < this._labels.length; h++)
                (c = this._labels[h]).position < this.viewportMinimum ||
                  c.position > this.viewportMaximum ||
                  (i && 0 != n++ % 2 && this.labelAutoFit) ||
                  ((p = this.getPixelCoordinatesOnAxis(c.position)),
                  this.tickThickness &&
                    "inside" != this.labelPlacement &&
                    ((this.ctx.lineWidth = this.tickThickness),
                    (this.ctx.strokeStyle = this.tickColor),
                    (a =
                      1 == this.ctx.lineWidth % 2
                        ? 0.5 + (p.y << 0)
                        : p.y << 0),
                    this.ctx.beginPath(),
                    this.ctx.moveTo(p.x << 0, a),
                    this.ctx.lineTo((p.x - this.tickLength) << 0, a),
                    this.ctx.stroke()),
                  0 === this.labelAngle
                    ? ((c.textBlock.y = p.y),
                      (c.textBlock.x =
                        "inside" === this.labelPlacement
                          ? p.x + this.tickLength + 5
                          : p.x -
                            c.textBlock.width *
                              Math.cos((Math.PI / 180) * this.labelAngle) -
                            this.tickLength -
                            5))
                    : ((c.textBlock.y =
                        "inside" === this.labelPlacement
                          ? p.y
                          : p.y -
                            c.textBlock.width *
                              Math.sin((Math.PI / 180) * this.labelAngle)),
                      (c.textBlock.x =
                        "inside" === this.labelPlacement
                          ? p.x + this.tickLength + 5
                          : 0 < this.labelAngle
                          ? p.x -
                            c.textBlock.width *
                              Math.cos((Math.PI / 180) * this.labelAngle) -
                            this.tickLength -
                            5
                          : p.x -
                            c.textBlock.width *
                              Math.cos((Math.PI / 180) * this.labelAngle) +
                            (c.textBlock.height -
                              c.textBlock.fontSize / 2 -
                              5) *
                              Math.sin((Math.PI / 180) * this.labelAngle) -
                            this.tickLength)));
              "inside" === this.labelPlacement &&
                this.chart.addEventListener(
                  "dataAnimationIterationEnd",
                  function () {
                    for (h = 0; h < e._labels.length; h++)
                      if (
                        !(
                          (c = e._labels[h]).position < e.viewportMinimum ||
                          c.position > e.viewportMaximum ||
                          (i && 0 != n++ % 2 && e.labelAutoFit)
                        ) &&
                        ((p = e.getPixelCoordinatesOnAxis(c.position)),
                        e.tickThickness)
                      ) {
                        (e.ctx.lineWidth = e.tickThickness),
                          (e.ctx.strokeStyle = e.tickColor);
                        var t =
                          1 == e.ctx.lineWidth % 2
                            ? 0.5 + (p.y << 0)
                            : p.y << 0;
                        e.ctx.save(),
                          e.ctx.beginPath(),
                          e.ctx.moveTo(p.x << 0, t),
                          e.ctx.lineTo((p.x + e.tickLength) << 0, t),
                          e.ctx.stroke(),
                          e.ctx.restore();
                      }
                  },
                  this
                ),
                this.title &&
                  (this._titleTextBlock.measureText(),
                  (this._titleTextBlock.x = this.bounds.x1 + 1),
                  (this._titleTextBlock.y =
                    this.lineCoordinates.height / 2 +
                    this._titleTextBlock.width / 2 +
                    this.lineCoordinates.y1),
                  (this.titleMaxWidth = this._titleTextBlock.maxWidth),
                  this._titleTextBlock.render(!0));
            } else if ("right" === this._position) {
              for (h = 0; h < this._labels.length; h++)
                (c = this._labels[h]).position < this.viewportMinimum ||
                  c.position > this.viewportMaximum ||
                  (i && 0 != n++ % 2 && this.labelAutoFit) ||
                  ((p = this.getPixelCoordinatesOnAxis(c.position)),
                  this.tickThickness &&
                    "inside" != this.labelPlacement &&
                    ((this.ctx.lineWidth = this.tickThickness),
                    (this.ctx.strokeStyle = this.tickColor),
                    (a =
                      1 == this.ctx.lineWidth % 2
                        ? 0.5 + (p.y << 0)
                        : p.y << 0),
                    this.ctx.beginPath(),
                    this.ctx.moveTo(p.x << 0, a),
                    this.ctx.lineTo((p.x + this.tickLength) << 0, a),
                    this.ctx.stroke()),
                  0 === this.labelAngle
                    ? ((c.textBlock.y = p.y),
                      (c.textBlock.x =
                        "inside" === this.labelPlacement
                          ? p.x - c.textBlock.width - this.tickLength - 5
                          : p.x + this.tickLength + 5))
                    : ((c.textBlock.y =
                        "inside" === this.labelPlacement
                          ? p.y -
                            c.textBlock.width *
                              Math.sin((Math.PI / 180) * this.labelAngle)
                          : this.labelAngle < 0
                          ? p.y
                          : p.y -
                            (c.textBlock.height -
                              c.textBlock.fontSize / 2 -
                              5) *
                              Math.cos((Math.PI / 180) * this.labelAngle)),
                      (c.textBlock.x =
                        "inside" === this.labelPlacement
                          ? p.x -
                            c.textBlock.width *
                              Math.cos((Math.PI / 180) * this.labelAngle) -
                            this.tickLength -
                            5
                          : 0 < this.labelAngle
                          ? p.x +
                            (c.textBlock.height -
                              c.textBlock.fontSize / 2 -
                              5) *
                              Math.sin((Math.PI / 180) * this.labelAngle) +
                            this.tickLength
                          : p.x + this.tickLength + 5)));
              "inside" === this.labelPlacement &&
                this.chart.addEventListener(
                  "dataAnimationIterationEnd",
                  function () {
                    for (h = 0; h < e._labels.length; h++)
                      if (
                        !(
                          (c = e._labels[h]).position < e.viewportMinimum ||
                          c.position > e.viewportMaximum ||
                          (i && 0 != n++ % 2 && e.labelAutoFit)
                        ) &&
                        ((p = e.getPixelCoordinatesOnAxis(c.position)),
                        e.tickThickness)
                      ) {
                        (e.ctx.lineWidth = e.tickThickness),
                          (e.ctx.strokeStyle = e.tickColor);
                        var t =
                          1 == e.ctx.lineWidth % 2
                            ? 0.5 + (p.y << 0)
                            : p.y << 0;
                        e.ctx.save(),
                          e.ctx.beginPath(),
                          e.ctx.moveTo(p.x << 0, t),
                          e.ctx.lineTo((p.x - e.tickLength) << 0, t),
                          e.ctx.stroke(),
                          e.ctx.restore();
                      }
                  },
                  this
                ),
                this.title &&
                  (this._titleTextBlock.measureText(),
                  (this._titleTextBlock.x = this.bounds.x2 - 1),
                  (this._titleTextBlock.y =
                    this.lineCoordinates.height / 2 -
                    this._titleTextBlock.width / 2 +
                    this.lineCoordinates.y1),
                  (this.titleMaxWidth = this._titleTextBlock.maxWidth),
                  this._titleTextBlock.render(!0));
            }
            if (((n = 0), "inside" === this.labelPlacement))
              this.chart.addEventListener(
                "dataAnimationIterationEnd",
                function () {
                  for (h = 0; h < e._labels.length; h++)
                    (c = e._labels[h]).position < e.viewportMinimum ||
                      c.position > e.viewportMaximum ||
                      (i && 0 != n++ % 2 && e.labelAutoFit) ||
                      (e.ctx.save(),
                      e.ctx.beginPath(),
                      c.textBlock.render(!0),
                      e.ctx.restore());
                },
                c.textBlock
              );
            else
              for (h = 0; h < this._labels.length; h++)
                (c = this._labels[h]).position < this.viewportMinimum ||
                  c.position > this.viewportMaximum ||
                  (i && 0 != n++ % 2 && this.labelAutoFit) ||
                  c.textBlock.render(!0);
          }),
          (v.prototype.renderInterlacedColors = function () {
            var t,
              e,
              i = this.chart.plotArea.ctx,
              a = this.chart.plotArea,
              s = 0;
            if (
              ((t = !0),
              ("bottom" !== this._position && "top" !== this._position) ||
                !this.interlacedColor)
            ) {
              if (
                ("left" === this._position || "right" === this._position) &&
                this.interlacedColor
              )
                for (
                  i.fillStyle = this.interlacedColor, s = 0;
                  s < this._labels.length;
                  s++
                )
                  t =
                    !t ||
                    ((e = this.getPixelCoordinatesOnAxis(
                      this._labels[s].position
                    )),
                    (t =
                      s + 1 > this._labels.length - 1
                        ? this.getPixelCoordinatesOnAxis(this.viewportMaximum)
                        : this.getPixelCoordinatesOnAxis(
                            this._labels[s + 1].position
                          )),
                    i.fillRect(
                      a.x1,
                      Math.min(e.y, t.y),
                      Math.abs(a.x1 - a.x2),
                      Math.abs(t.y - e.y)
                    ),
                    !1);
            } else
              for (
                i.fillStyle = this.interlacedColor, s = 0;
                s < this._labels.length;
                s++
              )
                t =
                  !t ||
                  ((t = this.getPixelCoordinatesOnAxis(
                    this._labels[s].position
                  )),
                  (e =
                    s + 1 > this._labels.length - 1
                      ? this.getPixelCoordinatesOnAxis(this.viewportMaximum)
                      : this.getPixelCoordinatesOnAxis(
                          this._labels[s + 1].position
                        )),
                  i.fillRect(
                    Math.min(e.x, t.x),
                    a.y1,
                    Math.abs(e.x - t.x),
                    Math.abs(a.y1 - a.y2)
                  ),
                  !1);
            i.beginPath();
          }),
          (v.prototype.renderStripLinesOfThicknessType = function (t) {
            if (this.stripLines && 0 < this.stripLines.length && t) {
              var e,
                i = this,
                a = 0,
                s = 0,
                n = !1,
                o = !1,
                r = [],
                l = [];
              for (o = !1, a = 0; a < this.stripLines.length; a++) {
                var h = this.stripLines[a];
                h._thicknessType === t &&
                  (("pixel" === t &&
                    (h.value < this.viewportMinimum ||
                      h.value > this.viewportMaximum ||
                      U(h.value) ||
                      isNaN(this.range))) ||
                    r.push(h));
              }
              for (a = 0; a < this._stripLineLabels.length; a++)
                if (
                  ((h = this.stripLines[a]),
                  !(
                    (e = this._stripLineLabels[a]).position <
                      this.viewportMinimum ||
                    e.position > this.viewportMaximum ||
                    isNaN(this.range)
                  ))
                ) {
                  if (
                    ((t = this.getPixelCoordinatesOnAxis(e.position)),
                    "outside" === e.stripLine.labelPlacement)
                  )
                    if (
                      (h &&
                        ((this.ctx.strokeStyle = h.color),
                        "pixel" === h._thicknessType &&
                          (this.ctx.lineWidth = h.thickness)),
                      "bottom" === this._position)
                    ) {
                      var d =
                        1 == this.ctx.lineWidth % 2
                          ? 0.5 + (t.x << 0)
                          : t.x << 0;
                      this.ctx.beginPath(),
                        this.ctx.moveTo(d, t.y << 0),
                        this.ctx.lineTo(d, (t.y + this.tickLength) << 0),
                        this.ctx.stroke(),
                        0 === this.labelAngle
                          ? ((t.x -= e.textBlock.width / 2),
                            (t.y += this.tickLength + e.textBlock.fontSize / 2))
                          : ((t.x -=
                              this.labelAngle < 0
                                ? e.textBlock.width *
                                  Math.cos((Math.PI / 180) * this.labelAngle)
                                : 0),
                            (t.y +=
                              this.tickLength +
                              Math.abs(
                                this.labelAngle < 0
                                  ? e.textBlock.width *
                                      Math.sin(
                                        (Math.PI / 180) * this.labelAngle
                                      ) -
                                      5
                                  : 5
                              )));
                    } else
                      "top" === this._position
                        ? ((d =
                            1 == this.ctx.lineWidth % 2
                              ? 0.5 + (t.x << 0)
                              : t.x << 0),
                          this.ctx.beginPath(),
                          this.ctx.moveTo(d, t.y << 0),
                          this.ctx.lineTo(d, (t.y - this.tickLength) << 0),
                          this.ctx.stroke(),
                          0 === this.labelAngle
                            ? ((t.x -= e.textBlock.width / 2),
                              (t.y -= this.tickLength + e.textBlock.height))
                            : ((t.x +=
                                (e.textBlock.height -
                                  this.tickLength -
                                  this.labelFontSize / 2) *
                                  Math.sin((Math.PI / 180) * this.labelAngle) -
                                (0 < this.labelAngle
                                  ? e.textBlock.width *
                                    Math.cos((Math.PI / 180) * this.labelAngle)
                                  : 0)),
                              (t.y -=
                                this.tickLength +
                                (e.textBlock.height *
                                  Math.cos((Math.PI / 180) * this.labelAngle) +
                                  (0 < this.labelAngle
                                    ? e.textBlock.width *
                                      Math.sin(
                                        (Math.PI / 180) * this.labelAngle
                                      )
                                    : 0)))))
                        : "left" === this._position
                        ? ((d =
                            1 == this.ctx.lineWidth % 2
                              ? 0.5 + (t.y << 0)
                              : t.y << 0),
                          this.ctx.beginPath(),
                          this.ctx.moveTo(t.x << 0, d),
                          this.ctx.lineTo((t.x - this.tickLength) << 0, d),
                          this.ctx.stroke(),
                          0 === this.labelAngle
                            ? (t.x =
                                t.x -
                                e.textBlock.width *
                                  Math.cos((Math.PI / 180) * this.labelAngle) -
                                this.tickLength -
                                5)
                            : ((t.y -=
                                e.textBlock.width *
                                Math.sin((Math.PI / 180) * this.labelAngle)),
                              (t.x =
                                0 < this.labelAngle
                                  ? t.x -
                                    e.textBlock.width *
                                      Math.cos(
                                        (Math.PI / 180) * this.labelAngle
                                      ) -
                                    this.tickLength -
                                    5
                                  : t.x -
                                    e.textBlock.width *
                                      Math.cos(
                                        (Math.PI / 180) * this.labelAngle
                                      ) +
                                    (e.textBlock.height -
                                      e.textBlock.fontSize / 2 -
                                      5) *
                                      Math.sin(
                                        (Math.PI / 180) * this.labelAngle
                                      ) -
                                    this.tickLength)))
                        : "right" === this._position &&
                          ((d =
                            1 == this.ctx.lineWidth % 2
                              ? 0.5 + (t.y << 0)
                              : t.y << 0),
                          this.ctx.beginPath(),
                          this.ctx.moveTo(t.x << 0, d),
                          this.ctx.lineTo((t.x + this.tickLength) << 0, d),
                          this.ctx.stroke(),
                          0 === this.labelAngle
                            ? (t.x = t.x + this.tickLength + 5)
                            : ((t.y =
                                this.labelAngle < 0
                                  ? t.y
                                  : t.y -
                                    (e.textBlock.height -
                                      e.textBlock.fontSize / 2 -
                                      5) *
                                      Math.cos(
                                        (Math.PI / 180) * this.labelAngle
                                      )),
                              (t.x =
                                0 < this.labelAngle
                                  ? t.x +
                                    (e.textBlock.height -
                                      e.textBlock.fontSize / 2 -
                                      5) *
                                      Math.sin(
                                        (Math.PI / 180) * this.labelAngle
                                      ) +
                                    this.tickLength
                                  : t.x + this.tickLength + 5)));
                  else
                    (e.textBlock.angle = -90),
                      "bottom" === this._position
                        ? ((e.textBlock.maxWidth = this.options.stripLines[a]
                            .labelMaxWidth
                            ? this.options.stripLines[a].labelMaxWidth
                            : this.chart.plotArea.height - 3),
                          e.textBlock.measureText(),
                          t.x - e.textBlock.height > this.chart.plotArea.x1
                            ? U(h.startValue)
                              ? (t.x -=
                                  e.textBlock.height - e.textBlock.fontSize / 2)
                              : (t.x -=
                                  e.textBlock.height / 2 -
                                  e.textBlock.fontSize / 2 +
                                  3)
                            : ((e.textBlock.angle = 90),
                              U(h.startValue)
                                ? (t.x +=
                                    e.textBlock.height -
                                    e.textBlock.fontSize / 2)
                                : (t.x +=
                                    e.textBlock.height / 2 -
                                    e.textBlock.fontSize / 2 +
                                    3)),
                          (t.y =
                            -90 === e.textBlock.angle
                              ? "near" === e.stripLine.labelAlign
                                ? this.chart.plotArea.y2 - 3
                                : "center" === e.stripLine.labelAlign
                                ? (this.chart.plotArea.y2 +
                                    this.chart.plotArea.y1 +
                                    e.textBlock.width) /
                                  2
                                : this.chart.plotArea.y1 + e.textBlock.width + 3
                              : "near" === e.stripLine.labelAlign
                              ? this.chart.plotArea.y2 - e.textBlock.width - 3
                              : "center" === e.stripLine.labelAlign
                              ? (this.chart.plotArea.y2 +
                                  this.chart.plotArea.y1 -
                                  e.textBlock.width) /
                                2
                              : this.chart.plotArea.y1 + 3))
                        : "top" === this._position
                        ? ((e.textBlock.maxWidth = this.options.stripLines[a]
                            .labelMaxWidth
                            ? this.options.stripLines[a].labelMaxWidth
                            : this.chart.plotArea.height - 3),
                          e.textBlock.measureText(),
                          t.x - e.textBlock.height > this.chart.plotArea.x1
                            ? U(h.startValue)
                              ? (t.x -=
                                  e.textBlock.height - e.textBlock.fontSize / 2)
                              : (t.x -=
                                  e.textBlock.height / 2 -
                                  e.textBlock.fontSize / 2 +
                                  3)
                            : ((e.textBlock.angle = 90),
                              U(h.startValue)
                                ? (t.x +=
                                    e.textBlock.height -
                                    e.textBlock.fontSize / 2)
                                : (t.x +=
                                    e.textBlock.height / 2 -
                                    e.textBlock.fontSize / 2 +
                                    3)),
                          (t.y =
                            -90 === e.textBlock.angle
                              ? "near" === e.stripLine.labelAlign
                                ? this.chart.plotArea.y1 + e.textBlock.width + 3
                                : "center" === e.stripLine.labelAlign
                                ? (this.chart.plotArea.y2 +
                                    this.chart.plotArea.y1 +
                                    e.textBlock.width) /
                                  2
                                : this.chart.plotArea.y2 - 3
                              : "near" === e.stripLine.labelAlign
                              ? this.chart.plotArea.y1 + 3
                              : "center" === e.stripLine.labelAlign
                              ? (this.chart.plotArea.y2 +
                                  this.chart.plotArea.y1 -
                                  e.textBlock.width) /
                                2
                              : this.chart.plotArea.y2 - e.textBlock.width - 3))
                        : "left" === this._position
                        ? ((e.textBlock.maxWidth = this.options.stripLines[a]
                            .labelMaxWidth
                            ? this.options.stripLines[a].labelMaxWidth
                            : this.chart.plotArea.width - 3),
                          (e.textBlock.angle = 0),
                          e.textBlock.measureText(),
                          t.y - e.textBlock.height > this.chart.plotArea.y1
                            ? U(h.startValue)
                              ? (t.y -=
                                  e.textBlock.height - e.textBlock.fontSize / 2)
                              : (t.y -=
                                  e.textBlock.height / 2 -
                                  e.textBlock.fontSize +
                                  3)
                            : t.y - e.textBlock.height < this.chart.plotArea.y2
                            ? (t.y += e.textBlock.fontSize / 2 + 3)
                            : U(h.startValue)
                            ? (t.y -=
                                e.textBlock.height - e.textBlock.fontSize / 2)
                            : (t.y -=
                                e.textBlock.height / 2 -
                                e.textBlock.fontSize +
                                3),
                          (t.x =
                            "near" === e.stripLine.labelAlign
                              ? this.chart.plotArea.x1 + 3
                              : "center" === e.stripLine.labelAlign
                              ? (this.chart.plotArea.x2 +
                                  this.chart.plotArea.x1) /
                                  2 -
                                e.textBlock.width / 2
                              : this.chart.plotArea.x2 - e.textBlock.width - 3))
                        : "right" === this._position &&
                          ((e.textBlock.maxWidth = this.options.stripLines[a]
                            .labelMaxWidth
                            ? this.options.stripLines[a].labelMaxWidth
                            : this.chart.plotArea.width - 3),
                          (e.textBlock.angle = 0),
                          e.textBlock.measureText(),
                          t.y - +e.textBlock.height > this.chart.plotArea.y1
                            ? U(h.startValue)
                              ? (t.y -=
                                  e.textBlock.height - e.textBlock.fontSize / 2)
                              : (t.y -=
                                  e.textBlock.height / 2 -
                                  e.textBlock.fontSize / 2 -
                                  3)
                            : t.y - e.textBlock.height < this.chart.plotArea.y2
                            ? (t.y += e.textBlock.fontSize / 2 + 3)
                            : U(h.startValue)
                            ? (t.y -=
                                e.textBlock.height - e.textBlock.fontSize / 2)
                            : (t.y -=
                                e.textBlock.height / 2 -
                                e.textBlock.fontSize / 2 +
                                3),
                          (t.x =
                            "near" === e.stripLine.labelAlign
                              ? this.chart.plotArea.x2 - e.textBlock.width - 3
                              : "center" === e.stripLine.labelAlign
                              ? (this.chart.plotArea.x2 +
                                  this.chart.plotArea.x1) /
                                  2 -
                                e.textBlock.width / 2
                              : this.chart.plotArea.x1 + 3));
                  (e.textBlock.x = t.x), (e.textBlock.y = t.y), l.push(e);
                }
              if (!o) {
                for (
                  o = !1,
                    this.ctx.save(),
                    this.ctx.beginPath(),
                    this.ctx.rect(
                      this.chart.plotArea.x1,
                      this.chart.plotArea.y1,
                      this.chart.plotArea.width,
                      this.chart.plotArea.height
                    ),
                    this.ctx.clip(),
                    a = 0;
                  a < r.length;
                  a++
                )
                  (h = r[a]).showOnTop
                    ? n ||
                      ((n = !0),
                      this.chart.addEventListener(
                        "dataAnimationIterationEnd",
                        function () {
                          for (
                            this.ctx.save(),
                              this.ctx.beginPath(),
                              this.ctx.rect(
                                this.chart.plotArea.x1,
                                this.chart.plotArea.y1,
                                this.chart.plotArea.width,
                                this.chart.plotArea.height
                              ),
                              this.ctx.clip(),
                              s = 0;
                            s < r.length;
                            s++
                          )
                            (h = r[s]).showOnTop && h.render();
                          this.ctx.restore();
                        },
                        h
                      ))
                    : h.render();
                for (a = 0; a < l.length; a++)
                  (e = l[a]).stripLine.showOnTop
                    ? o ||
                      ((o = !0),
                      this.chart.addEventListener(
                        "dataAnimationIterationEnd",
                        function () {
                          for (s = 0; s < l.length; s++)
                            "inside" === (e = l[s]).stripLine.labelPlacement &&
                              e.stripLine.showOnTop &&
                              (i.ctx.save(),
                              i.ctx.beginPath(),
                              i.ctx.rect(
                                i.chart.plotArea.x1,
                                i.chart.plotArea.y1,
                                i.chart.plotArea.width,
                                i.chart.plotArea.height
                              ),
                              i.ctx.clip(),
                              e.textBlock.render(!0),
                              i.ctx.restore());
                        },
                        e.textBlock
                      ))
                    : "inside" === e.stripLine.labelPlacement &&
                      e.textBlock.render(!0);
                this.ctx.restore(), (o = !0);
              }
              if (o)
                for (o = !1, a = 0; a < l.length; a++)
                  (e = l[a]).stripLine.showOnTop
                    ? o ||
                      ((o = !0),
                      this.chart.addEventListener(
                        "dataAnimationIterationEnd",
                        function () {
                          for (s = 0; s < l.length; s++)
                            "outside" === (e = l[s]).stripLine.labelPlacement &&
                              e.stripLine.showOnTop &&
                              e.textBlock.render(!0);
                        },
                        e.textBlock
                      ))
                    : "outside" === e.stripLine.labelPlacement &&
                      e.textBlock.render(!0);
            }
          }),
          (v.prototype.renderBreaksBackground = function () {
            this.chart._breaksCanvas &&
              this.scaleBreaks &&
              0 < this.scaleBreaks._appliedBreaks.length &&
              this.maskCanvas &&
              (this.chart._breaksCanvasCtx.save(),
              this.chart._breaksCanvasCtx.beginPath(),
              this.chart._breaksCanvasCtx.rect(
                this.chart.plotArea.x1,
                this.chart.plotArea.y1,
                this.chart.plotArea.width,
                this.chart.plotArea.height
              ),
              this.chart._breaksCanvasCtx.clip(),
              this.chart._breaksCanvasCtx.drawImage(
                this.maskCanvas,
                0,
                0,
                this.chart.width,
                this.chart.height
              ),
              this.chart._breaksCanvasCtx.restore());
          }),
          (v.prototype.createMask = function () {
            if (
              this.scaleBreaks &&
              0 < this.scaleBreaks._appliedBreaks.length
            ) {
              var t = this.scaleBreaks._appliedBreaks;
              (this.maskCtx = Z
                ? ((this.maskCanvas = k(this.chart.width, this.chart.height)),
                  this.maskCanvas.getContext("2d"))
                : ((this.maskCanvas = this.chart.plotArea.canvas),
                  this.chart.plotArea.ctx)),
                this.maskCtx.save(),
                this.maskCtx.beginPath(),
                this.maskCtx.rect(
                  this.chart.plotArea.x1,
                  this.chart.plotArea.y1,
                  this.chart.plotArea.width,
                  this.chart.plotArea.height
                ),
                this.maskCtx.clip();
              for (var e = 0; e < t.length; e++)
                t[e].endValue < this.viewportMinimum ||
                  t[e].startValue > this.viewportMaximum ||
                  isNaN(this.range) ||
                  t[e].render(this.maskCtx);
              this.maskCtx.restore();
            }
          }),
          (v.prototype.renderCrosshair = function (t, e) {
            this.crosshair.render(t, e);
          }),
          (v.prototype.renderGrid = function () {
            if (this.gridThickness && 0 < this.gridThickness) {
              var t = this.chart.ctx;
              t.save();
              var e,
                i = this.chart.plotArea;
              if (
                ((t.lineWidth = this.gridThickness),
                (t.strokeStyle = this.gridColor),
                t.setLineDash &&
                  t.setLineDash(K(this.gridDashType, this.gridThickness)),
                "bottom" === this._position || "top" === this._position)
              )
                for (a = 0; a < this._labels.length; a++)
                  this._labels[a].position < this.viewportMinimum ||
                    this._labels[a].position > this.viewportMaximum ||
                    this._labels[a].breaksLabelType ||
                    (t.beginPath(),
                    (e = this.getPixelCoordinatesOnAxis(
                      this._labels[a].position
                    )),
                    (e = 1 == t.lineWidth % 2 ? 0.5 + (e.x << 0) : e.x << 0),
                    t.moveTo(e, i.y1 << 0),
                    t.lineTo(e, i.y2 << 0),
                    t.stroke());
              else if ("left" === this._position || "right" === this._position)
                for (var a = 0; a < this._labels.length; a++)
                  this._labels[a].position < this.viewportMinimum ||
                    this._labels[a].position > this.viewportMaximum ||
                    this._labels[a].breaksLabelType ||
                    (t.beginPath(),
                    (e = this.getPixelCoordinatesOnAxis(
                      this._labels[a].position
                    )),
                    (e = 1 == t.lineWidth % 2 ? 0.5 + (e.y << 0) : e.y << 0),
                    t.moveTo(i.x1 << 0, e),
                    t.lineTo(i.x2 << 0, e),
                    t.stroke());
              t.restore();
            }
          }),
          (v.prototype.renderAxisLine = function () {
            var t,
              e,
              i = this.chart.ctx,
              a = Z ? this.chart._preRenderCtx : i,
              s = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)),
              n = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2));
            if (
              (a.save(),
              "bottom" === this._position || "top" === this._position)
            ) {
              if (this.lineThickness) {
                (e = this.reversed
                  ? ((t = this.lineCoordinates.x2), this.lineCoordinates.x1)
                  : ((t = this.lineCoordinates.x1), this.lineCoordinates.x2)),
                  (a.lineWidth = this.lineThickness),
                  (a.strokeStyle = this.lineColor ? this.lineColor : "black"),
                  a.setLineDash &&
                    a.setLineDash(K(this.lineDashType, this.lineThickness));
                var o =
                  1 == this.lineThickness % 2
                    ? 0.5 + (this.lineCoordinates.y1 << 0)
                    : this.lineCoordinates.y1 << 0;
                if (
                  (a.beginPath(),
                  this.scaleBreaks && !U(this.scaleBreaks.firstBreakIndex))
                )
                  if (U(this.scaleBreaks.lastBreakIndex))
                    t =
                      this.scaleBreaks._appliedBreaks[
                        this.scaleBreaks.firstBreakIndex
                      ].endPixel + n;
                  else
                    for (
                      var r = this.scaleBreaks.firstBreakIndex;
                      r <= this.scaleBreaks.lastBreakIndex;
                      r++
                    )
                      a.moveTo(t, o),
                        a.lineTo(
                          this.scaleBreaks._appliedBreaks[r].startPixel + s,
                          o
                        ),
                        (t = this.scaleBreaks._appliedBreaks[r].endPixel + n);
                t && (a.moveTo(t, o), a.lineTo(e, o)), a.stroke();
              }
            } else if (
              ("left" === this._position || "right" === this._position) &&
              this.lineThickness
            ) {
              if (
                ((e = this.reversed
                  ? ((t = this.lineCoordinates.y1), this.lineCoordinates.y2)
                  : ((t = this.lineCoordinates.y2), this.lineCoordinates.y1)),
                (a.lineWidth = this.lineThickness),
                (a.strokeStyle = this.lineColor),
                a.setLineDash &&
                  a.setLineDash(K(this.lineDashType, this.lineThickness)),
                (o =
                  1 == this.lineThickness % 2
                    ? 0.5 + (this.lineCoordinates.x1 << 0)
                    : this.lineCoordinates.x1 << 0),
                a.beginPath(),
                this.scaleBreaks && !U(this.scaleBreaks.firstBreakIndex))
              )
                if (U(this.scaleBreaks.lastBreakIndex))
                  t =
                    this.scaleBreaks._appliedBreaks[
                      this.scaleBreaks.firstBreakIndex
                    ].endPixel + s;
                else
                  for (
                    r = this.scaleBreaks.firstBreakIndex;
                    r <= this.scaleBreaks.lastBreakIndex;
                    r++
                  )
                    a.moveTo(o, t),
                      a.lineTo(
                        o,
                        this.scaleBreaks._appliedBreaks[r].startPixel + n
                      ),
                      (t = this.scaleBreaks._appliedBreaks[r].endPixel + s);
              t && (a.moveTo(o, t), a.lineTo(o, e)), a.stroke();
            }
            Z &&
              (i.drawImage(
                this.chart._preRenderCanvas,
                0,
                0,
                this.chart.width,
                this.chart.height
              ),
              this.chart._breaksCanvasCtx &&
                this.chart._breaksCanvasCtx.drawImage(
                  this.chart._preRenderCanvas,
                  0,
                  0,
                  this.chart.width,
                  this.chart.height
                ),
              a.clearRect(0, 0, this.chart.width, this.chart.height)),
              a.restore();
          }),
          (v.prototype.getPixelCoordinatesOnAxis = function (t) {
            var e = {};
            return (
              ("bottom" !== this._position && "top" !== this._position) ||
                ((e.x = this.convertValueToPixel(t)),
                (e.y = this.lineCoordinates.y1)),
              ("left" !== this._position && "right" !== this._position) ||
                ((e.y = this.convertValueToPixel(t)),
                (e.x = this.lineCoordinates.x2)),
              e
            );
          }),
          (v.prototype.convertPixelToValue = function (t) {
            if (void 0 === t) return null;
            var e,
              i = 0,
              a = 0,
              s =
                ((i = !0),
                this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []);
            a =
              "number" == typeof t
                ? t
                : "left" === this._position || "right" === this._position
                ? t.y
                : t.x;
            if (this.logarithmic) {
              if (
                ((t = e =
                  Math.pow(
                    this.logarithmBase,
                    (a - this.conversionParameters.reference) /
                      this.conversionParameters.pixelPerUnit
                  )),
                (a <= this.conversionParameters.reference ==
                  ("left" === this._position || "right" === this._position)) !==
                  this.reversed)
              ) {
                for (a = 0; a < s.length; a++)
                  if (!(s[a].endValue < this.conversionParameters.minimum))
                    if (i)
                      if (s[a].startValue < this.conversionParameters.minimum) {
                        if (
                          1 < s[a].size &&
                          this.conversionParameters.minimum *
                            Math.pow(
                              s[a].endValue / s[a].startValue,
                              Math.log(e) / Math.log(s[a].size)
                            ) <
                            s[a].endValue
                        ) {
                          t = Math.pow(
                            s[a].endValue / s[a].startValue,
                            Math.log(e) / Math.log(s[a].size)
                          );
                          break;
                        }
                        (t *=
                          s[a].endValue /
                          this.conversionParameters.minimum /
                          Math.pow(
                            s[a].size,
                            Math.log(
                              s[a].endValue / this.conversionParameters.minimum
                            ) / Math.log(s[a].endValue / s[a].startValue)
                          )),
                          (e /= Math.pow(
                            s[a].size,
                            Math.log(
                              s[a].endValue / this.conversionParameters.minimum
                            ) / Math.log(s[a].endValue / s[a].startValue)
                          )),
                          (i = !1);
                      } else {
                        if (
                          !(
                            e >
                            s[a].startValue / this.conversionParameters.minimum
                          )
                        )
                          break;
                        if (
                          (e /=
                            s[a].startValue /
                            this.conversionParameters.minimum) < s[a].size
                        ) {
                          t *=
                            Math.pow(
                              s[a].endValue / s[a].startValue,
                              1 === s[a].size
                                ? 1
                                : Math.log(e) / Math.log(s[a].size)
                            ) / e;
                          break;
                        }
                        (t *= s[a].endValue / s[a].startValue / s[a].size),
                          (e /= s[a].size),
                          (i = !1);
                      }
                    else {
                      if (!(e > s[a].startValue / s[a - 1].endValue)) break;
                      if (
                        (e /= s[a].startValue / s[a - 1].endValue) < s[a].size
                      ) {
                        t *=
                          Math.pow(
                            s[a].endValue / s[a].startValue,
                            1 === s[a].size
                              ? 1
                              : Math.log(e) / Math.log(s[a].size)
                          ) / e;
                        break;
                      }
                      (t *= s[a].endValue / s[a].startValue / s[a].size),
                        (e /= s[a].size);
                    }
              } else
                for (a = s.length - 1; 0 <= a; a--)
                  if (!(s[a].startValue > this.conversionParameters.minimum))
                    if (i)
                      if (s[a].endValue > this.conversionParameters.minimum) {
                        if (
                          1 < s[a].size &&
                          this.conversionParameters.minimum *
                            Math.pow(
                              s[a].endValue / s[a].startValue,
                              Math.log(e) / Math.log(s[a].size)
                            ) >
                            s[a].startValue
                        ) {
                          t = Math.pow(
                            s[a].endValue / s[a].startValue,
                            Math.log(e) / Math.log(s[a].size)
                          );
                          break;
                        }
                        (t *=
                          (s[a].startValue /
                            this.conversionParameters.minimum) *
                          Math.pow(
                            s[a].size,
                            Math.log(
                              s[a].startValue /
                                this.conversionParameters.minimum
                            ) / Math.log(s[a].endValue / s[a].startValue)
                          ) *
                          e),
                          (e *= Math.pow(
                            s[a].size,
                            Math.log(
                              this.conversionParameters.minimum /
                                s[a].startValue
                            ) / Math.log(s[a].endValue / s[a].startValue)
                          )),
                          (i = !1);
                      } else {
                        if (
                          !(
                            e <
                            s[a].endValue / this.conversionParameters.minimum
                          )
                        )
                          break;
                        if (
                          (e /=
                            s[a].endValue / this.conversionParameters.minimum) >
                          1 / s[a].size
                        ) {
                          t *=
                            Math.pow(
                              s[a].endValue / s[a].startValue,
                              s[a].size <= 1
                                ? 1
                                : Math.log(e) / Math.log(s[a].size)
                            ) * e;
                          break;
                        }
                        (t /= s[a].endValue / s[a].startValue / s[a].size),
                          (e *= s[a].size),
                          (i = !1);
                      }
                    else {
                      if (!(e < s[a].endValue / s[a + 1].startValue)) break;
                      if (
                        (e /= s[a].endValue / s[a + 1].startValue) >
                        1 / s[a].size
                      ) {
                        t *=
                          Math.pow(
                            s[a].endValue / s[a].startValue,
                            s[a].size <= 1
                              ? 1
                              : Math.log(e) / Math.log(s[a].size)
                          ) * e;
                        break;
                      }
                      (t /= s[a].endValue / s[a].startValue / s[a].size),
                        (e *= s[a].size);
                    }
              i = t * this.viewportMinimum;
            } else {
              if (
                ((t = e =
                  (a - this.conversionParameters.reference) /
                  this.conversionParameters.pixelPerUnit),
                (a <= this.conversionParameters.reference ==
                  ("left" === this._position || "right" === this._position)) !==
                  this.reversed)
              ) {
                for (a = 0; a < s.length; a++)
                  if (!(s[a].endValue < this.conversionParameters.minimum))
                    if (i)
                      if (s[a].startValue < this.conversionParameters.minimum) {
                        if (
                          s[a].size &&
                          this.conversionParameters.minimum +
                            (e * (s[a].endValue - s[a].startValue)) /
                              s[a].size <
                            s[a].endValue
                        ) {
                          t =
                            s[a].size <= 0
                              ? 0
                              : (e * (s[a].endValue - s[a].startValue)) /
                                s[a].size;
                          break;
                        }
                        (t +=
                          s[a].endValue -
                          this.conversionParameters.minimum -
                          (s[a].size *
                            (s[a].endValue -
                              this.conversionParameters.minimum)) /
                            (s[a].endValue - s[a].startValue)),
                          (e -=
                            (s[a].size *
                              (s[a].endValue -
                                this.conversionParameters.minimum)) /
                            (s[a].endValue - s[a].startValue)),
                          (i = !1);
                      } else {
                        if (
                          !(
                            e >
                            s[a].startValue - this.conversionParameters.minimum
                          )
                        )
                          break;
                        if (
                          (e -=
                            s[a].startValue -
                            this.conversionParameters.minimum) < s[a].size
                        ) {
                          t +=
                            (s[a].endValue - s[a].startValue) *
                              (0 === s[a].size ? 1 : e / s[a].size) -
                            e;
                          break;
                        }
                        (t += s[a].endValue - s[a].startValue - s[a].size),
                          (e -= s[a].size),
                          (i = !1);
                      }
                    else {
                      if (!(e > s[a].startValue - s[a - 1].endValue)) break;
                      if (
                        (e -= s[a].startValue - s[a - 1].endValue) < s[a].size
                      ) {
                        t +=
                          (s[a].endValue - s[a].startValue) *
                            (0 === s[a].size ? 1 : e / s[a].size) -
                          e;
                        break;
                      }
                      (t += s[a].endValue - s[a].startValue - s[a].size),
                        (e -= s[a].size);
                    }
              } else
                for (a = s.length - 1; 0 <= a; a--)
                  if (!(s[a].startValue > this.conversionParameters.minimum))
                    if (i)
                      if (s[a].endValue > this.conversionParameters.minimum) {
                        if (
                          s[a].size &&
                          this.conversionParameters.minimum +
                            (e * (s[a].endValue - s[a].startValue)) /
                              s[a].size >
                            s[a].startValue
                        ) {
                          t =
                            s[a].size <= 0
                              ? 0
                              : (e * (s[a].endValue - s[a].startValue)) /
                                s[a].size;
                          break;
                        }
                        (t +=
                          s[a].startValue -
                          this.conversionParameters.minimum +
                          (s[a].size *
                            (this.conversionParameters.minimum -
                              s[a].startValue)) /
                            (s[a].endValue - s[a].startValue)),
                          (e +=
                            (s[a].size *
                              (this.conversionParameters.minimum -
                                s[a].startValue)) /
                            (s[a].endValue - s[a].startValue)),
                          (i = !1);
                      } else {
                        if (
                          !(
                            e <
                            s[a].endValue - this.conversionParameters.minimum
                          )
                        )
                          break;
                        if (
                          (e -=
                            s[a].endValue - this.conversionParameters.minimum) >
                          -1 * s[a].size
                        ) {
                          t +=
                            (s[a].endValue - s[a].startValue) *
                              (0 === s[a].size ? 1 : e / s[a].size) +
                            e;
                          break;
                        }
                        (t -= s[a].endValue - s[a].startValue - s[a].size),
                          (e += s[a].size),
                          (i = !1);
                      }
                    else {
                      if (!(e < s[a].endValue - s[a + 1].startValue)) break;
                      if (
                        (e -= s[a].endValue - s[a + 1].startValue) >
                        -1 * s[a].size
                      ) {
                        t +=
                          (s[a].endValue - s[a].startValue) *
                            (0 === s[a].size ? 1 : e / s[a].size) +
                          e;
                        break;
                      }
                      (t -= s[a].endValue - s[a].startValue - s[a].size),
                        (e += s[a].size);
                    }
              i = this.conversionParameters.minimum + t;
            }
            return i;
          }),
          (v.prototype.convertValueToPixel = function (t) {
            return (
              (t = this.getApparentDifference(
                this.conversionParameters.minimum,
                t,
                t
              )),
              this.logarithmic
                ? (this.conversionParameters.reference +
                    (this.conversionParameters.pixelPerUnit *
                      Math.log(t / this.conversionParameters.minimum)) /
                      this.conversionParameters.lnLogarithmBase +
                    0.5) <<
                  0
                : "axisX" === this.type
                ? (this.conversionParameters.reference +
                    this.conversionParameters.pixelPerUnit *
                      (t - this.conversionParameters.minimum) +
                    0.5) <<
                  0
                : this.conversionParameters.reference +
                  this.conversionParameters.pixelPerUnit *
                    (t - this.conversionParameters.minimum) +
                  0.5
            );
          }),
          (v.prototype.getApparentDifference = function (t, e, i, a) {
            var s = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
            if (this.logarithmic) {
              i = U(i) ? e / t : i;
              for (var n = 0; n < s.length && !(e < s[n].startValue); n++)
                t > s[n].endValue ||
                  (t <= s[n].startValue && e >= s[n].endValue
                    ? (i = (i / s[n].endValue) * s[n].startValue * s[n].size)
                    : t >= s[n].startValue && e >= s[n].endValue
                    ? (i =
                        (i / s[n].endValue) *
                        t *
                        Math.pow(
                          s[n].size,
                          Math.log(s[n].endValue / t) /
                            Math.log(s[n].endValue / s[n].startValue)
                        ))
                    : t <= s[n].startValue && e <= s[n].endValue
                    ? (i =
                        (i / e) *
                        s[n].startValue *
                        Math.pow(
                          s[n].size,
                          Math.log(e / s[n].startValue) /
                            Math.log(s[n].endValue / s[n].startValue)
                        ))
                    : !a &&
                      t > s[n].startValue &&
                      e < s[n].endValue &&
                      (i =
                        t *
                        Math.pow(
                          s[n].size,
                          Math.log(e / t) /
                            Math.log(s[n].endValue / s[n].startValue)
                        )));
            } else
              for (
                i = U(i) ? Math.abs(e - t) : i, n = 0;
                n < s.length && !(e < s[n].startValue);
                n++
              )
                t > s[n].endValue ||
                  (t <= s[n].startValue && e >= s[n].endValue
                    ? (i = i - s[n].endValue + s[n].startValue + s[n].size)
                    : t > s[n].startValue && e >= s[n].endValue
                    ? (i =
                        i -
                        s[n].endValue +
                        t +
                        (s[n].size * (s[n].endValue - t)) /
                          (s[n].endValue - s[n].startValue))
                    : t <= s[n].startValue && e < s[n].endValue
                    ? (i =
                        i -
                        e +
                        s[n].startValue +
                        (s[n].size * (e - s[n].startValue)) /
                          (s[n].endValue - s[n].startValue))
                    : !a &&
                      t > s[n].startValue &&
                      e < s[n].endValue &&
                      (i =
                        t +
                        (s[n].size * (e - t)) /
                          (s[n].endValue - s[n].startValue)));
            return i;
          }),
          (v.prototype.setViewPortRange = function (t, e) {
            (this.sessionVariables.newViewportMinimum = this.viewportMinimum =
              Math.min(t, e)),
              (this.sessionVariables.newViewportMaximum = this.viewportMaximum =
                Math.max(t, e));
          }),
          (v.prototype.getXValueAt = function (t) {
            if (!t) return null;
            var e = null;
            return (
              "left" === this._position
                ? (e = this.convertPixelToValue(t.y))
                : "bottom" === this._position &&
                  (e = this.convertPixelToValue(t.x)),
              e
            );
          }),
          (v.prototype.calculateValueToPixelConversionParameters = function (
            t
          ) {
            t = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
            var e = { pixelPerUnit: null, minimum: null, reference: null },
              i = this.lineCoordinates.width,
              a = this.lineCoordinates.height;
            (i =
              "bottom" === this._position || "top" === this._position ? i : a),
              (a = Math.abs(this.range));
            if (this.logarithmic)
              for (
                var s = 0;
                s < t.length && !(this.viewportMaximum < t[s].startValue);
                s++
              )
                this.viewportMinimum > t[s].endValue ||
                  (this.viewportMinimum >= t[s].startValue &&
                  this.viewportMaximum <= t[s].endValue
                    ? (i = 0)
                    : this.viewportMinimum <= t[s].startValue &&
                      this.viewportMaximum >= t[s].endValue
                    ? ((a = (a / t[s].endValue) * t[s].startValue),
                      (i =
                        0 < t[s].spacing.toString().indexOf("%")
                          ? i * (1 - parseFloat(t[s].spacing) / 100)
                          : i - Math.min(t[s].spacing, 0.1 * i)))
                    : this.viewportMinimum > t[s].startValue &&
                      this.viewportMaximum >= t[s].endValue
                    ? ((a = (a / t[s].endValue) * this.viewportMinimum),
                      (i =
                        0 < t[s].spacing.toString().indexOf("%")
                          ? i *
                            (1 -
                              ((parseFloat(t[s].spacing) / 100) *
                                Math.log(
                                  t[s].endValue / this.viewportMinimum
                                )) /
                                Math.log(t[s].endValue / t[s].startValue))
                          : i -
                            (Math.min(t[s].spacing, 0.1 * i) *
                              Math.log(t[s].endValue / this.viewportMinimum)) /
                              Math.log(t[s].endValue / t[s].startValue)))
                    : this.viewportMinimum <= t[s].startValue &&
                      this.viewportMaximum < t[s].endValue &&
                      ((a = (a / this.viewportMaximum) * t[s].startValue),
                      (i =
                        0 < t[s].spacing.toString().indexOf("%")
                          ? i *
                            (1 -
                              ((parseFloat(t[s].spacing) / 100) *
                                Math.log(
                                  this.viewportMaximum / t[s].startValue
                                )) /
                                Math.log(t[s].endValue / t[s].startValue))
                          : i -
                            (Math.min(t[s].spacing, 0.1 * i) *
                              Math.log(
                                this.viewportMaximum / t[s].startValue
                              )) /
                              Math.log(t[s].endValue / t[s].startValue))));
            else
              for (
                s = 0;
                s < t.length && !(this.viewportMaximum < t[s].startValue);
                s++
              )
                this.viewportMinimum > t[s].endValue ||
                  (this.viewportMinimum >= t[s].startValue &&
                  this.viewportMaximum <= t[s].endValue
                    ? (i = 0)
                    : this.viewportMinimum <= t[s].startValue &&
                      this.viewportMaximum >= t[s].endValue
                    ? ((a = a - t[s].endValue + t[s].startValue),
                      (i =
                        0 < t[s].spacing.toString().indexOf("%")
                          ? i * (1 - parseFloat(t[s].spacing) / 100)
                          : i - Math.min(t[s].spacing, 0.1 * i)))
                    : this.viewportMinimum > t[s].startValue &&
                      this.viewportMaximum >= t[s].endValue
                    ? ((a = a - t[s].endValue + this.viewportMinimum),
                      (i =
                        0 < t[s].spacing.toString().indexOf("%")
                          ? i *
                            (1 -
                              ((parseFloat(t[s].spacing) / 100) *
                                (t[s].endValue - this.viewportMinimum)) /
                                (t[s].endValue - t[s].startValue))
                          : i -
                            (Math.min(t[s].spacing, 0.1 * i) *
                              (t[s].endValue - this.viewportMinimum)) /
                              (t[s].endValue - t[s].startValue)))
                    : this.viewportMinimum <= t[s].startValue &&
                      this.viewportMaximum < t[s].endValue &&
                      ((a = a - this.viewportMaximum + t[s].startValue),
                      (i =
                        0 < t[s].spacing.toString().indexOf("%")
                          ? i *
                            (1 -
                              ((parseFloat(t[s].spacing) / 100) *
                                (this.viewportMaximum - t[s].startValue)) /
                                (t[s].endValue - t[s].startValue))
                          : i -
                            (Math.min(t[s].spacing, 0.1 * i) *
                              (this.viewportMaximum - t[s].startValue)) /
                              (t[s].endValue - t[s].startValue))));
            (e.minimum = this.viewportMinimum),
              (e.maximum = this.viewportMaximum),
              (e.range = a),
              ("bottom" !== this._position && "top" !== this._position) ||
                (this.logarithmic
                  ? ((e.lnLogarithmBase = Math.log(this.logarithmBase)),
                    (e.pixelPerUnit =
                      ((this.reversed ? -1 : 1) * i * e.lnLogarithmBase) /
                      Math.log(Math.abs(a))))
                  : (e.pixelPerUnit =
                      ((this.reversed ? -1 : 1) * i) / Math.abs(a)),
                (e.reference = this.reversed
                  ? this.lineCoordinates.x2
                  : this.lineCoordinates.x1)),
              ("left" !== this._position && "right" !== this._position) ||
                (this.logarithmic
                  ? ((e.lnLogarithmBase = Math.log(this.logarithmBase)),
                    (e.pixelPerUnit =
                      ((this.reversed ? 1 : -1) * i * e.lnLogarithmBase) /
                      Math.log(Math.abs(a))))
                  : (e.pixelPerUnit =
                      ((this.reversed ? 1 : -1) * i) / Math.abs(a)),
                (e.reference = this.reversed
                  ? this.lineCoordinates.y1
                  : this.lineCoordinates.y2)),
              (this.conversionParameters = e);
          }),
          (v.prototype.calculateAxisParameters = function () {
            if (this.logarithmic) this.calculateLogarithmicAxisParameters();
            else {
              var t = this.chart.layoutManager.getFreeSpace(),
                e = !1,
                i = !1;
              "bottom" === this._position || "top" === this._position
                ? ((this.maxWidth = t.width), (this.maxHeight = t.height))
                : ((this.maxWidth = t.height), (this.maxHeight = t.width));
              t =
                "axisX" === this.type
                  ? "xySwapped" === this.chart.plotInfo.axisPlacement
                    ? 62
                    : 70
                  : "xySwapped" === this.chart.plotInfo.axisPlacement
                  ? 50
                  : 40;
              var a = 4;
              "axisX" === this.type && (a = this.maxWidth < 600 ? 8 : 6);
              var s, n, o;
              (t = Math.max(a, Math.floor(this.maxWidth / t))), (a = 0);
              if (
                (!U(this.options.viewportMinimum) &&
                  !U(this.options.viewportMaximum) &&
                  this.options.viewportMinimum >=
                    this.options.viewportMaximum &&
                  (this.viewportMinimum = this.viewportMaximum = null),
                !U(this.options.viewportMinimum) ||
                U(this.sessionVariables.newViewportMinimum) ||
                isNaN(this.sessionVariables.newViewportMinimum)
                  ? (null === this.viewportMinimum ||
                      isNaN(this.viewportMinimum)) &&
                    (this.viewportMinimum = this.minimum)
                  : (this.viewportMinimum =
                      this.sessionVariables.newViewportMinimum),
                !U(this.options.viewportMaximum) ||
                U(this.sessionVariables.newViewportMaximum) ||
                isNaN(this.sessionVariables.newViewportMaximum)
                  ? (null === this.viewportMaximum ||
                      isNaN(this.viewportMaximum)) &&
                    (this.viewportMaximum = this.maximum)
                  : (this.viewportMaximum =
                      this.sessionVariables.newViewportMaximum),
                this.scaleBreaks)
              )
                for (a = 0; a < this.scaleBreaks._appliedBreaks.length; a++)
                  if (
                    ((!U(this.sessionVariables.newViewportMinimum) &&
                      this.sessionVariables.newViewportMinimum >=
                        this.scaleBreaks._appliedBreaks[a].startValue) ||
                      (!U(this.options.minimum) &&
                        this.options.minimum >=
                          this.scaleBreaks._appliedBreaks[a].startValue) ||
                      (!U(this.options.viewportMinimum) &&
                        this.viewportMinimum >=
                          this.scaleBreaks._appliedBreaks[a].startValue)) &&
                    ((!U(this.sessionVariables.newViewportMaximum) &&
                      this.sessionVariables.newViewportMaximum <=
                        this.scaleBreaks._appliedBreaks[a].endValue) ||
                      (!U(this.options.maximum) &&
                        this.options.maximum <=
                          this.scaleBreaks._appliedBreaks[a].endValue) ||
                      (!U(this.options.viewportMaximum) &&
                        this.viewportMaximum <=
                          this.scaleBreaks._appliedBreaks[a].endValue))
                  ) {
                    this.scaleBreaks._appliedBreaks.splice(a, 1);
                    break;
                  }
              if ("axisX" === this.type) {
                if (this.dataSeries && 0 < this.dataSeries.length)
                  for (s = 0; s < this.dataSeries.length; s++)
                    "dateTime" === this.dataSeries[s].xValueType && (i = !0);
                (s =
                  null !== this.viewportMinimum
                    ? this.viewportMinimum
                    : this.dataInfo.viewPortMin),
                  0 ==
                    (n =
                      null !== this.viewportMaximum
                        ? this.viewportMaximum
                        : this.dataInfo.viewPortMax) -
                      s &&
                    ((n += a =
                      void 0 === this.options.interval
                        ? 0.4
                        : this.options.interval),
                    (s -= a)),
                  1 / 0 !== this.dataInfo.minDiff
                    ? (o = this.dataInfo.minDiff)
                    : 1 < n - s
                    ? (o = 0.5 * Math.abs(n - s))
                    : ((o = 1), i && (e = !0));
              } else
                "axisY" === this.type &&
                  ((s =
                    null !== this.viewportMinimum
                      ? this.viewportMinimum
                      : this.dataInfo.viewPortMin),
                  (n =
                    null !== this.viewportMaximum
                      ? this.viewportMaximum
                      : this.dataInfo.viewPortMax),
                  isFinite(s) || isFinite(n)
                    ? isFinite(s)
                      ? isFinite(n) || (n = s)
                      : (s = n)
                    : ((n =
                        void 0 === this.options.interval
                          ? -1 / 0
                          : this.options.interval),
                      (s =
                        void 0 !== this.options.interval ||
                        isFinite(this.dataInfo.minDiff)
                          ? 0
                          : 1 / 0)),
                  0 === s && 0 === n
                    ? ((n += 9), (s = 0))
                    : 0 == n - s
                    ? ((n += a = Math.min(Math.abs(0.01 * Math.abs(n)), 5)),
                      (s -= a))
                    : n < s
                    ? ((a = Math.min(
                        0.01 *
                          Math.abs(this.getApparentDifference(n, s, null, !0)),
                        5
                      )),
                      0 <= n ? (s = n - a) : (n = isFinite(s) ? s + a : 0))
                    : ((a = Math.min(
                        0.01 *
                          Math.abs(this.getApparentDifference(s, n, null, !0)),
                        0.05
                      )),
                      0 !== n && (n += a),
                      0 !== s && (s -= a)),
                  (o =
                    1 / 0 !== this.dataInfo.minDiff
                      ? this.dataInfo.minDiff
                      : 1 < n - s
                      ? 0.5 * Math.abs(n - s)
                      : 1),
                  this.includeZero &&
                    (null === this.viewportMinimum ||
                      isNaN(this.viewportMinimum)) &&
                    0 < s &&
                    (s = 0),
                  this.includeZero &&
                    (null === this.viewportMaximum ||
                      isNaN(this.viewportMaximum)) &&
                    n < 0 &&
                    (n = 0));
              (a = this.getApparentDifference(
                isNaN(this.viewportMinimum) || null === this.viewportMinimum
                  ? s
                  : this.viewportMinimum,
                isNaN(this.viewportMaximum) || null === this.viewportMaximum
                  ? n
                  : this.viewportMaximum,
                null,
                !0
              )),
                "axisX" === this.type && i
                  ? (this.intervalType ||
                      (this.intervalType =
                        a / 1 <= t
                          ? ((this.interval = 1), "millisecond")
                          : a / 2 <= t
                          ? ((this.interval = 2), "millisecond")
                          : a / 5 <= t
                          ? ((this.interval = 5), "millisecond")
                          : a / 10 <= t
                          ? ((this.interval = 10), "millisecond")
                          : a / 20 <= t
                          ? ((this.interval = 20), "millisecond")
                          : a / 50 <= t
                          ? ((this.interval = 50), "millisecond")
                          : a / 100 <= t
                          ? ((this.interval = 100), "millisecond")
                          : a / 200 <= t
                          ? ((this.interval = 200), "millisecond")
                          : a / 250 <= t
                          ? ((this.interval = 250), "millisecond")
                          : a / 300 <= t
                          ? ((this.interval = 300), "millisecond")
                          : a / 400 <= t
                          ? ((this.interval = 400), "millisecond")
                          : a / 500 <= t
                          ? ((this.interval = 500), "millisecond")
                          : a / (1 * tt.secondDuration) <= t
                          ? ((this.interval = 1), "second")
                          : a / (2 * tt.secondDuration) <= t
                          ? ((this.interval = 2), "second")
                          : a / (5 * tt.secondDuration) <= t
                          ? ((this.interval = 5), "second")
                          : a / (10 * tt.secondDuration) <= t
                          ? ((this.interval = 10), "second")
                          : a / (15 * tt.secondDuration) <= t
                          ? ((this.interval = 15), "second")
                          : a / (20 * tt.secondDuration) <= t
                          ? ((this.interval = 20), "second")
                          : a / (30 * tt.secondDuration) <= t
                          ? ((this.interval = 30), "second")
                          : a / (1 * tt.minuteDuration) <= t
                          ? ((this.interval = 1), "minute")
                          : a / (2 * tt.minuteDuration) <= t
                          ? ((this.interval = 2), "minute")
                          : a / (5 * tt.minuteDuration) <= t
                          ? ((this.interval = 5), "minute")
                          : a / (10 * tt.minuteDuration) <= t
                          ? ((this.interval = 10), "minute")
                          : a / (15 * tt.minuteDuration) <= t
                          ? ((this.interval = 15), "minute")
                          : a / (20 * tt.minuteDuration) <= t
                          ? ((this.interval = 20), "minute")
                          : a / (30 * tt.minuteDuration) <= t
                          ? ((this.interval = 30), "minute")
                          : a / (1 * tt.hourDuration) <= t
                          ? ((this.interval = 1), "hour")
                          : a / (2 * tt.hourDuration) <= t
                          ? ((this.interval = 2), "hour")
                          : a / (3 * tt.hourDuration) <= t
                          ? ((this.interval = 3), "hour")
                          : a / (6 * tt.hourDuration) <= t
                          ? ((this.interval = 6), "hour")
                          : a / (1 * tt.dayDuration) <= t
                          ? ((this.interval = 1), "day")
                          : a / (2 * tt.dayDuration) <= t
                          ? ((this.interval = 2), "day")
                          : a / (4 * tt.dayDuration) <= t
                          ? ((this.interval = 4), "day")
                          : a / (1 * tt.weekDuration) <= t
                          ? ((this.interval = 1), "week")
                          : a / (2 * tt.weekDuration) <= t
                          ? ((this.interval = 2), "week")
                          : a / (3 * tt.weekDuration) <= t
                          ? ((this.interval = 3), "week")
                          : a / (1 * tt.monthDuration) <= t
                          ? ((this.interval = 1), "month")
                          : a / (2 * tt.monthDuration) <= t
                          ? ((this.interval = 2), "month")
                          : a / (3 * tt.monthDuration) <= t
                          ? ((this.interval = 3), "month")
                          : a / (6 * tt.monthDuration) <= t
                          ? ((this.interval = 6), "month")
                          : ((this.interval =
                              a / (1 * tt.yearDuration) <= t
                                ? 1
                                : a / (2 * tt.yearDuration) <= t
                                ? 2
                                : a / (4 * tt.yearDuration) <= t
                                ? 4
                                : Math.floor(
                                    v.getNiceNumber(a / (t - 1), !0) /
                                      tt.yearDuration
                                  )),
                            "year")),
                    (null === this.viewportMinimum ||
                      isNaN(this.viewportMinimum)) &&
                      (this.viewportMinimum = s - o / 2),
                    (null === this.viewportMaximum ||
                      isNaN(this.viewportMaximum)) &&
                      (this.viewportMaximum = n + o / 2),
                    e
                      ? (this.autoValueFormatString = "MMM DD YYYY HH:mm")
                      : "year" === this.intervalType
                      ? (this.autoValueFormatString = "YYYY")
                      : "month" === this.intervalType
                      ? (this.autoValueFormatString = "MMM YYYY")
                      : "week" === this.intervalType
                      ? (this.autoValueFormatString = "MMM DD YYYY")
                      : "day" === this.intervalType
                      ? (this.autoValueFormatString = "MMM DD YYYY")
                      : "hour" === this.intervalType
                      ? (this.autoValueFormatString = "hh:mm TT")
                      : "minute" === this.intervalType
                      ? (this.autoValueFormatString = "hh:mm TT")
                      : "second" === this.intervalType
                      ? (this.autoValueFormatString = "hh:mm:ss TT")
                      : "millisecond" === this.intervalType &&
                        (this.autoValueFormatString = "fff'ms'"),
                    this.valueFormatString ||
                      (this.valueFormatString = this.autoValueFormatString))
                  : ((this.intervalType = "number"),
                    (a = v.getNiceNumber(a, !1)),
                    (this.interval =
                      this.options && 0 < this.options.interval
                        ? this.options.interval
                        : v.getNiceNumber(a / (t - 1), !0)),
                    (null === this.viewportMinimum ||
                      isNaN(this.viewportMinimum)) &&
                      (this.viewportMinimum =
                        "axisX" === this.type
                          ? s - o / 2
                          : Math.floor(s / this.interval) * this.interval),
                    (null === this.viewportMaximum ||
                      isNaN(this.viewportMaximum)) &&
                      (this.viewportMaximum =
                        "axisX" === this.type
                          ? n + o / 2
                          : Math.ceil(n / this.interval) * this.interval),
                    0 === this.viewportMaximum &&
                      0 === this.viewportMinimum &&
                      (0 === this.options.viewportMinimum
                        ? (this.viewportMaximum += 10)
                        : 0 === this.options.viewportMaximum &&
                          (this.viewportMinimum -= 10),
                      this.options &&
                        void 0 === this.options.interval &&
                        (this.interval = v.getNiceNumber(
                          (this.viewportMaximum - this.viewportMinimum) /
                            (t - 1),
                          !0
                        )))),
                (null !== this.minimum && null !== this.maximum) ||
                  ("axisX" === this.type
                    ? ((s =
                        null !== this.minimum
                          ? this.minimum
                          : this.dataInfo.min),
                      0 ==
                        (n =
                          null !== this.maximum
                            ? this.maximum
                            : this.dataInfo.max) -
                          s &&
                        ((n += a =
                          void 0 === this.options.interval
                            ? 0.4
                            : this.options.interval),
                        (s -= a)),
                      (o =
                        1 / 0 !== this.dataInfo.minDiff
                          ? this.dataInfo.minDiff
                          : 1 < n - s
                          ? 0.5 * Math.abs(n - s)
                          : 1))
                    : "axisY" === this.type &&
                      ((s =
                        null !== this.minimum
                          ? this.minimum
                          : this.dataInfo.min),
                      (n =
                        null !== this.maximum
                          ? this.maximum
                          : this.dataInfo.max),
                      isFinite(s) || isFinite(n)
                        ? 0 === s && 0 === n
                          ? ((n += 9), (s = 0))
                          : 0 == n - s
                          ? ((n += a =
                              Math.min(Math.abs(0.01 * Math.abs(n)), 5)),
                            (s -= a))
                          : n < s
                          ? ((a = Math.min(
                              0.01 *
                                Math.abs(
                                  this.getApparentDifference(n, s, null, !0)
                                ),
                              5
                            )),
                            0 <= n
                              ? (s = n - a)
                              : (n = isFinite(s) ? s + a : 0))
                          : ((a = Math.min(
                              0.01 *
                                Math.abs(
                                  this.getApparentDifference(s, n, null, !0)
                                ),
                              0.05
                            )),
                            0 !== n && (n += a),
                            0 !== s && (s -= a))
                        : ((n =
                            void 0 === this.options.interval
                              ? -1 / 0
                              : this.options.interval),
                          (s =
                            void 0 !== this.options.interval ||
                            isFinite(this.dataInfo.minDiff)
                              ? 0
                              : 1 / 0)),
                      (o =
                        1 / 0 !== this.dataInfo.minDiff
                          ? this.dataInfo.minDiff
                          : 1 < n - s
                          ? 0.5 * Math.abs(n - s)
                          : 1),
                      this.includeZero &&
                        (null === this.minimum || isNaN(this.minimum)) &&
                        0 < s &&
                        (s = 0),
                      this.includeZero &&
                        (null === this.maximum || isNaN(this.maximum)) &&
                        n < 0 &&
                        (n = 0)),
                  Math.abs(this.getApparentDifference(s, n, null, !0)),
                  "axisX" === this.type && i
                    ? ((this.valueType = "dateTime"),
                      (null === this.minimum || isNaN(this.minimum)) &&
                        (this.minimum = s - o / 2),
                      (null === this.maximum || isNaN(this.maximum)) &&
                        (this.maximum = n + o / 2))
                    : ((this.intervalType = this.valueType = "number"),
                      null === this.minimum &&
                        ((this.minimum =
                          "axisX" === this.type
                            ? s - o / 2
                            : Math.floor(s / this.interval) * this.interval),
                        (this.minimum = Math.min(
                          this.minimum,
                          null === this.sessionVariables.viewportMinimum ||
                            isNaN(this.sessionVariables.viewportMinimum)
                            ? 1 / 0
                            : this.sessionVariables.viewportMinimum
                        ))),
                      null === this.maximum &&
                        ((this.maximum =
                          "axisX" === this.type
                            ? n + o / 2
                            : Math.ceil(n / this.interval) * this.interval),
                        (this.maximum = Math.max(
                          this.maximum,
                          null === this.sessionVariables.viewportMaximum ||
                            isNaN(this.sessionVariables.viewportMaximum)
                            ? -1 / 0
                            : this.sessionVariables.viewportMaximum
                        ))),
                      0 === this.maximum &&
                        0 === this.minimum &&
                        (0 === this.options.minimum
                          ? (this.maximum += 10)
                          : 0 === this.options.maximum &&
                            (this.minimum -= 10)))),
                U(this.sessionVariables.newViewportMinimum) &&
                  (this.viewportMinimum = Math.max(
                    this.viewportMinimum,
                    this.minimum
                  )),
                U(this.sessionVariables.newViewportMaximum) &&
                  (this.viewportMaximum = Math.min(
                    this.viewportMaximum,
                    this.maximum
                  )),
                (this.range = this.viewportMaximum - this.viewportMinimum),
                (this.intervalStartPosition =
                  "axisX" === this.type && i
                    ? this.getLabelStartPoint(
                        new Date(this.viewportMinimum),
                        this.intervalType,
                        this.interval
                      )
                    : Math.floor(
                        (this.viewportMinimum + 0.2 * this.interval) /
                          this.interval
                      ) * this.interval),
                this.valueFormatString ||
                  (this.valueFormatString = v.generateValueFormatString(
                    this.range,
                    2
                  ));
            }
          }),
          (v.prototype.calculateLogarithmicAxisParameters = function () {
            var t,
              e = this.chart.layoutManager.getFreeSpace(),
              i = Math.log(this.logarithmBase);
            "bottom" === this._position || "top" === this._position
              ? ((this.maxWidth = e.width), (this.maxHeight = e.height))
              : ((this.maxWidth = e.height), (this.maxHeight = e.width));
            var a, s, n, o;
            e =
              "axisX" === this.type
                ? this.maxWidth < 500
                  ? 7
                  : Math.max(7, Math.floor(this.maxWidth / 100))
                : Math.max(Math.floor(this.maxWidth / 50), 3);
            if (
              ((o = 1),
              (null === this.viewportMinimum || isNaN(this.viewportMinimum)) &&
                (this.viewportMinimum = this.minimum),
              (null === this.viewportMaximum || isNaN(this.viewportMaximum)) &&
                (this.viewportMaximum = this.maximum),
              this.scaleBreaks)
            )
              for (o = 0; o < this.scaleBreaks._appliedBreaks.length; o++)
                if (
                  ((!U(this.sessionVariables.newViewportMinimum) &&
                    this.sessionVariables.newViewportMinimum >=
                      this.scaleBreaks._appliedBreaks[o].startValue) ||
                    (!U(this.options.minimum) &&
                      this.options.minimum >=
                        this.scaleBreaks._appliedBreaks[o].startValue) ||
                    (!U(this.options.viewportMinimum) &&
                      this.viewportMinimum >=
                        this.scaleBreaks._appliedBreaks[o].startValue)) &&
                  ((!U(this.sessionVariables.newViewportMaximum) &&
                    this.sessionVariables.newViewportMaximum <=
                      this.scaleBreaks._appliedBreaks[o].endValue) ||
                    (!U(this.options.maximum) &&
                      this.options.maximum <=
                        this.scaleBreaks._appliedBreaks[o].endValue) ||
                    (!U(this.options.viewportMaximum) &&
                      this.viewportMaximum <=
                        this.scaleBreaks._appliedBreaks[o].endValue))
                ) {
                  this.scaleBreaks._appliedBreaks.splice(o, 1);
                  break;
                }
            if (
              ("axisX" === this.type
                ? ((a =
                    null !== this.viewportMinimum
                      ? this.viewportMinimum
                      : this.dataInfo.viewPortMin),
                  1 ==
                    (s =
                      null !== this.viewportMaximum
                        ? this.viewportMaximum
                        : this.dataInfo.viewPortMax) /
                      a &&
                    ((s *= o =
                      Math.pow(
                        this.logarithmBase,
                        void 0 === this.options.interval
                          ? 0.4
                          : this.options.interval
                      )),
                    (a /= o)),
                  (n =
                    1 / 0 !== this.dataInfo.minDiff
                      ? this.dataInfo.minDiff
                      : s / a > this.logarithmBase
                      ? (s / a) * Math.pow(this.logarithmBase, 0.5)
                      : this.logarithmBase))
                : "axisY" === this.type &&
                  ((a =
                    null !== this.viewportMinimum
                      ? this.viewportMinimum
                      : this.dataInfo.viewPortMin),
                  (s =
                    null !== this.viewportMaximum
                      ? this.viewportMaximum
                      : this.dataInfo.viewPortMax),
                  a <= 0 && !isFinite(s)
                    ? ((s =
                        void 0 === this.options.interval
                          ? 0
                          : this.options.interval),
                      (a = 1))
                    : a <= 0
                    ? (a = s)
                    : isFinite(s) || (s = a),
                  1 === a && 1 === s
                    ? ((s *= this.logarithmBase - 1 / this.logarithmBase),
                      (a = 1))
                    : 1 == s / a
                    ? ((s *= o =
                        Math.min(
                          s * Math.pow(this.logarithmBase, 0.01),
                          Math.pow(this.logarithmBase, 5)
                        )),
                      (a /= o))
                    : s < a
                    ? ((o = Math.min(
                        (a / s) * Math.pow(this.logarithmBase, 0.01),
                        Math.pow(this.logarithmBase, 5)
                      )),
                      1 <= s ? (a = s / o) : (s = a * o))
                    : ((o = Math.min(
                        (s / a) * Math.pow(this.logarithmBase, 0.01),
                        Math.pow(this.logarithmBase, 0.04)
                      )),
                      1 !== s && (s *= o),
                      1 !== a && (a /= o)),
                  (n =
                    1 / 0 !== this.dataInfo.minDiff
                      ? this.dataInfo.minDiff
                      : s / a > this.logarithmBase
                      ? (s / a) * Math.pow(this.logarithmBase, 0.5)
                      : this.logarithmBase),
                  this.includeZero &&
                    (null === this.viewportMinimum ||
                      isNaN(this.viewportMinimum)) &&
                    1 < a &&
                    (a = 1),
                  this.includeZero &&
                    (null === this.viewportMaximum ||
                      isNaN(this.viewportMaximum)) &&
                    s < 1 &&
                    (s = 1)),
              (o =
                (isNaN(this.viewportMaximum) || null === this.viewportMaximum
                  ? s
                  : this.viewportMaximum) /
                (isNaN(this.viewportMinimum) || null === this.viewportMinimum
                  ? a
                  : this.viewportMinimum)),
              (linearRange =
                (isNaN(this.viewportMaximum) || null === this.viewportMaximum
                  ? s
                  : this.viewportMaximum) -
                (isNaN(this.viewportMinimum) || null === this.viewportMinimum
                  ? a
                  : this.viewportMinimum)),
              (this.intervalType = "number"),
              (o = Math.pow(
                this.logarithmBase,
                v.getNiceNumber(Math.abs(Math.log(o) / i), !1)
              )),
              this.options && 0 < this.options.interval
                ? (this.interval = this.options.interval)
                : ((this.interval = v.getNiceExponent(
                    Math.log(o) / i / (e - 1),
                    !0
                  )),
                  (t = v.getNiceNumber(linearRange / (e - 1), !0))),
              (null === this.viewportMinimum || isNaN(this.viewportMinimum)) &&
                (this.viewportMinimum =
                  "axisX" === this.type
                    ? a / Math.sqrt(n)
                    : Math.pow(
                        this.logarithmBase,
                        this.interval *
                          Math.floor(Math.log(a) / i / this.interval)
                      )),
              (null === this.viewportMaximum || isNaN(this.viewportMaximum)) &&
                (this.viewportMaximum =
                  "axisX" === this.type
                    ? s * Math.sqrt(n)
                    : Math.pow(
                        this.logarithmBase,
                        this.interval *
                          Math.ceil(Math.log(s) / i / this.interval)
                      )),
              1 === this.viewportMaximum &&
                1 === this.viewportMinimum &&
                (1 === this.options.viewportMinimum
                  ? (this.viewportMaximum *=
                      this.logarithmBase - 1 / this.logarithmBase)
                  : 1 === this.options.viewportMaximum &&
                    (this.viewportMinimum /=
                      this.logarithmBase - 1 / this.logarithmBase),
                this.options &&
                  void 0 === this.options.interval &&
                  ((this.interval = v.getNiceExponent(
                    Math.ceil(Math.log(o) / i) / (e - 1)
                  )),
                  (t = v.getNiceNumber(
                    (this.viewportMaximum - this.viewportMinimum) / (e - 1),
                    !0
                  )))),
              (null !== this.minimum && null !== this.maximum) ||
                ("axisX" === this.type
                  ? ((a =
                      null !== this.minimum ? this.minimum : this.dataInfo.min),
                    1 ==
                      (s =
                        null !== this.maximum
                          ? this.maximum
                          : this.dataInfo.max) /
                        a &&
                      ((s *= o =
                        Math.pow(
                          this.logarithmBase,
                          void 0 === this.options.interval
                            ? 0.4
                            : this.options.interval
                        )),
                      (a /= o)),
                    (n =
                      1 / 0 !== this.dataInfo.minDiff
                        ? this.dataInfo.minDiff
                        : s / a > this.logarithmBase
                        ? (s / a) * Math.pow(this.logarithmBase, 0.5)
                        : this.logarithmBase))
                  : "axisY" === this.type &&
                    ((a =
                      null !== this.minimum ? this.minimum : this.dataInfo.min),
                    (s =
                      null !== this.maximum ? this.maximum : this.dataInfo.max),
                    isFinite(a) || isFinite(s)
                      ? 1 === a && 1 === s
                        ? ((s *= this.logarithmBase), (a /= this.logarithmBase))
                        : 1 == s / a
                        ? ((s *= o =
                            Math.pow(this.logarithmBase, this.interval)),
                          (a /= o))
                        : s < a
                        ? ((o = Math.min((a / s) * 0.01, 5)),
                          1 <= s ? (a = s / o) : (s = a * o))
                        : ((o = Math.min(
                            (s / a) * Math.pow(this.logarithmBase, 0.01),
                            Math.pow(this.logarithmBase, 0.04)
                          )),
                          1 !== s && (s *= o),
                          1 !== a && (a /= o))
                      : ((s =
                          void 0 === this.options.interval
                            ? 0
                            : this.options.interval),
                        (a = 1)),
                    (n =
                      1 / 0 !== this.dataInfo.minDiff
                        ? this.dataInfo.minDiff
                        : s / a > this.logarithmBase
                        ? (s / a) * Math.pow(this.logarithmBase, 0.5)
                        : this.logarithmBase),
                    this.includeZero &&
                      (null === this.minimum || isNaN(this.minimum)) &&
                      1 < a &&
                      (a = 1),
                    this.includeZero &&
                      (null === this.maximum || isNaN(this.maximum)) &&
                      s < 1 &&
                      (s = 1)),
                (this.intervalType = "number"),
                null === this.minimum &&
                  ((this.minimum =
                    "axisX" === this.type
                      ? a / Math.sqrt(n)
                      : Math.pow(
                          this.logarithmBase,
                          this.interval *
                            Math.floor(Math.log(a) / i / this.interval)
                        )),
                  (this.minimum = Math.min(
                    this.minimum,
                    null === this.sessionVariables.viewportMinimum ||
                      isNaN(this.sessionVariables.viewportMinimum)
                      ? void 0 === this.sessionVariables.newViewportMinimum
                        ? 1 / 0
                        : this.sessionVariables.newViewportMinimum
                      : this.sessionVariables.viewportMinimum
                  ))),
                null === this.maximum &&
                  ((this.maximum =
                    "axisX" === this.type
                      ? s * Math.sqrt(n)
                      : Math.pow(
                          this.logarithmBase,
                          this.interval *
                            Math.ceil(Math.log(s) / i / this.interval)
                        )),
                  (this.maximum = Math.max(
                    this.maximum,
                    null === this.sessionVariables.viewportMaximum ||
                      isNaN(this.sessionVariables.viewportMaximum)
                      ? void 0 === this.sessionVariables.newViewportMaximum
                        ? 0
                        : this.sessionVariables.newViewportMaximum
                      : this.sessionVariables.viewportMaximum
                  ))),
                1 === this.maximum &&
                  1 === this.minimum &&
                  (1 === this.options.minimum
                    ? (this.maximum *=
                        this.logarithmBase - 1 / this.logarithmBase)
                    : 1 === this.options.maximum &&
                      (this.minimum /=
                        this.logarithmBase - 1 / this.logarithmBase))),
              (this.viewportMinimum = Math.max(
                this.viewportMinimum,
                this.minimum
              )),
              (this.viewportMaximum = Math.min(
                this.viewportMaximum,
                this.maximum
              )),
              this.viewportMinimum > this.viewportMaximum &&
                ((!this.options.viewportMinimum && !this.options.minimum) ||
                this.options.viewportMaximum ||
                this.options.maximum
                  ? this.options.viewportMinimum ||
                    this.options.minimum ||
                    (!this.options.viewportMaximum && !this.options.maximum) ||
                    (this.viewportMinimum = this.minimum =
                      (this.options.viewportMaximum || this.options.maximum) /
                      Math.pow(
                        this.logarithmBase,
                        2 * Math.ceil(this.interval)
                      ))
                  : (this.viewportMaximum = this.maximum =
                      this.options.viewportMinimum || this.options.minimum)),
              (a = Math.pow(
                this.logarithmBase,
                Math.floor(
                  Math.log(this.viewportMinimum) / (i * this.interval) + 0.2
                ) * this.interval
              )),
              (this.range = this.viewportMaximum / this.viewportMinimum),
              (this.noTicks = e),
              !this.options.interval &&
                this.range <
                  Math.pow(
                    this.logarithmBase,
                    this.viewportMaximum < 8 || e < 3 ? 2 : 3
                  ))
            ) {
              for (
                i = Math.floor(this.viewportMinimum / t + 0.5) * t;
                i < this.viewportMinimum;

              )
                i += t;
              (this.equidistantInterval = !1),
                (this.intervalStartPosition = i),
                (this.interval = t);
            } else
              this.options.interval ||
                ((t = Math.ceil(this.interval)),
                this.range > this.interval &&
                  ((this.interval = t),
                  (a = Math.pow(
                    this.logarithmBase,
                    Math.floor(
                      Math.log(this.viewportMinimum) / (i * this.interval) + 0.2
                    ) * this.interval
                  )))),
                (this.equidistantInterval = !0),
                (this.intervalStartPosition = a);
            if (
              !this.valueFormatString &&
              ((this.valueFormatString = "#,##0.##"),
              this.viewportMinimum < 1) &&
              ((i =
                Math.floor(
                  Math.abs(Math.log(this.viewportMinimum) / Math.LN10)
                ) + 2),
              (!isNaN(i) && isFinite(i)) || (i = 2),
              2 < i)
            )
              for (o = 0; o < i - 2; o++) this.valueFormatString += "#";
          }),
          (v.generateValueFormatString = function (t, e) {
            var i = "#,##0.",
              a = e;
            t < 1 &&
              ((a += Math.floor(Math.abs(Math.log(t) / Math.LN10))),
              isNaN(a) || !isFinite(a)) &&
              (a = e);
            for (var s = 0; s < a; s++) i += "#";
            return i;
          }),
          (v.getNiceExponent = function (t, e) {
            var i = Math.floor(Math.log(t) / Math.LN10),
              a = t / Math.pow(10, i);
            a =
              i < 0
                ? a <= 1
                  ? 1
                  : a <= 5
                  ? 5
                  : 10
                : Math.max(Math.floor(a), 1);
            return i < -20
              ? Number(a * Math.pow(10, i))
              : Number((a * Math.pow(10, i)).toFixed(20));
          }),
          (v.getNiceNumber = function (t, e) {
            var i = Math.floor(Math.log(t) / Math.LN10),
              a = t / Math.pow(10, i);
            a = e
              ? a < 1.5
                ? 1
                : a < 3
                ? 2
                : a < 7
                ? 5
                : 10
              : a <= 1
              ? 1
              : a <= 2
              ? 2
              : a <= 5
              ? 5
              : 10;
            return i < -20
              ? Number(a * Math.pow(10, i))
              : Number((a * Math.pow(10, i)).toFixed(20));
          }),
          (v.prototype.getLabelStartPoint = function () {
            var t = tt[this.intervalType + "Duration"] * this.interval;
            t = new Date(Math.floor(this.viewportMinimum / t) * t);
            return (
              "millisecond" !== this.intervalType &&
                ("second" === this.intervalType
                  ? 0 < t.getMilliseconds() &&
                    (t.setSeconds(t.getSeconds() + 1), t.setMilliseconds(0))
                  : "minute" === this.intervalType
                  ? (0 < t.getSeconds() || 0 < t.getMilliseconds()) &&
                    (t.setMinutes(t.getMinutes() + 1),
                    t.setSeconds(0),
                    t.setMilliseconds(0))
                  : "hour" === this.intervalType
                  ? (0 < t.getMinutes() ||
                      0 < t.getSeconds() ||
                      0 < t.getMilliseconds()) &&
                    (t.setHours(t.getHours() + 1),
                    t.setMinutes(0),
                    t.setSeconds(0),
                    t.setMilliseconds(0))
                  : "day" === this.intervalType
                  ? (0 < t.getHours() ||
                      0 < t.getMinutes() ||
                      0 < t.getSeconds() ||
                      0 < t.getMilliseconds()) &&
                    (t.setDate(t.getDate() + 1),
                    t.setHours(0),
                    t.setMinutes(0),
                    t.setSeconds(0),
                    t.setMilliseconds(0))
                  : "week" === this.intervalType
                  ? (0 < t.getDay() ||
                      0 < t.getHours() ||
                      0 < t.getMinutes() ||
                      0 < t.getSeconds() ||
                      0 < t.getMilliseconds()) &&
                    (t.setDate(t.getDate() + (7 - t.getDay())),
                    t.setHours(0),
                    t.setMinutes(0),
                    t.setSeconds(0),
                    t.setMilliseconds(0))
                  : "month" === this.intervalType
                  ? (1 < t.getDate() ||
                      0 < t.getHours() ||
                      0 < t.getMinutes() ||
                      0 < t.getSeconds() ||
                      0 < t.getMilliseconds()) &&
                    (t.setMonth(t.getMonth() + 1),
                    t.setDate(1),
                    t.setHours(0),
                    t.setMinutes(0),
                    t.setSeconds(0),
                    t.setMilliseconds(0))
                  : "year" === this.intervalType &&
                    (0 < t.getMonth() ||
                      1 < t.getDate() ||
                      0 < t.getHours() ||
                      0 < t.getMinutes() ||
                      0 < t.getSeconds() ||
                      0 < t.getMilliseconds()) &&
                    (t.setFullYear(t.getFullYear() + 1),
                    t.setMonth(0),
                    t.setDate(1),
                    t.setHours(0),
                    t.setMinutes(0),
                    t.setSeconds(0),
                    t.setMilliseconds(0))),
              t
            );
          }),
          t(h, L),
          t(x, L),
          (x.prototype.createUserOptions = function (t) {
            if (void 0 !== t || this.options._isPlaceholder) {
              var e = 0;
              this.parent.options._isPlaceholder &&
                this.parent.createUserOptions(),
                this.options._isPlaceholder ||
                  (q(this.parent[this.optionsName]),
                  (e = this.parent.options[this.optionsName].indexOf(
                    this.options
                  ))),
                (this.options = void 0 === t ? {} : t),
                (this.parent.options[this.optionsName][e] = this.options);
            }
          }),
          (x.prototype.render = function (t) {
            if (
              0 !== this.spacing ||
              (0 !== this.options.lineThickness &&
                (void 0 !== this.options.lineThickness ||
                  0 !== this.parent.lineThickness))
            ) {
              var e = this.ctx,
                i = this.ctx.globalAlpha;
              (this.ctx = t || this.ctx),
                this.ctx.save(),
                this.ctx.beginPath(),
                this.ctx.rect(
                  this.chart.plotArea.x1,
                  this.chart.plotArea.y1,
                  this.chart.plotArea.width,
                  this.chart.plotArea.height
                ),
                this.ctx.clip();
              var a,
                s,
                n,
                o,
                r,
                l,
                h = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(
                  this.startValue
                ),
                d = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(
                  this.endValue
                );
              (this.ctx.strokeStyle = this.lineColor),
                (this.ctx.fillStyle = this.color),
                this.ctx.beginPath(),
                (this.ctx.globalAlpha = 1),
                N(this.id),
                (t = Math.max(this.spacing, 3));
              var c = Math.max(0, this.lineThickness);
              if (
                ((this.ctx.lineWidth = c),
                this.ctx.setLineDash &&
                  this.ctx.setLineDash(K(this.lineDashType, c)),
                "bottom" === this.scaleBreaks.parent._position ||
                  "top" === this.scaleBreaks.parent._position)
              ) {
                if (
                  ((h = 1 == c % 2 ? 0.5 + (h.x << 0) : h.x << 0),
                  (s = 1 == c % 2 ? 0.5 + (d.x << 0) : d.x << 0),
                  "top" === this.scaleBreaks.parent._position
                    ? ((d = this.chart.plotArea.y1),
                      (n = (this.chart.plotArea.y2 + c / 2 + 0.5) << 0))
                    : ((d = this.chart.plotArea.y2),
                      (n = (this.chart.plotArea.y1 - c / 2 + 0.5) << 0),
                      (t *= -1)),
                  (this.bounds = {
                    x1: h - c / 2,
                    y1: d,
                    x2: s + c / 2,
                    y2: n,
                  }),
                  this.ctx.moveTo(h, d),
                  "straight" === this.type ||
                    ("top" === this.scaleBreaks.parent._position && t <= 0) ||
                    ("bottom" === this.scaleBreaks.parent._position && 0 <= t))
                )
                  this.ctx.lineTo(h, n),
                    this.ctx.lineTo(s, n),
                    this.ctx.lineTo(s, d);
                else if ("wavy" === this.type) {
                  (o = h), (a = 0.5), (l = (n - (r = d)) / t / 3);
                  for (var p = 0; p < l; p++)
                    this.ctx.bezierCurveTo(
                      o + a * t,
                      r + t,
                      o + a * t,
                      r + 2 * t,
                      o,
                      r + 3 * t
                    ),
                      (r += 3 * t),
                      (a *= -1);
                  for (
                    this.ctx.bezierCurveTo(
                      o + a * t,
                      r + t,
                      o + a * t,
                      r + 2 * t,
                      o,
                      r + 3 * t
                    ),
                      o = s,
                      a *= -1,
                      this.ctx.lineTo(o, r),
                      p = 0;
                    p < l;
                    p++
                  )
                    this.ctx.bezierCurveTo(
                      o + a * t,
                      r - t,
                      o + a * t,
                      r - 2 * t,
                      o,
                      r - 3 * t
                    ),
                      (r -= 3 * t),
                      (a *= -1);
                } else if ("zigzag" === this.type) {
                  for (
                    a = -1, o = h + t, l = (n - (r = d + t)) / t / 2, p = 0;
                    p < l;
                    p++
                  )
                    this.ctx.lineTo(o, r),
                      (o += 2 * a * t),
                      (r += 2 * t),
                      (a *= -1);
                  for (this.ctx.lineTo(o, r), o += s - h, p = 0; p < l + 1; p++)
                    this.ctx.lineTo(o, r),
                      (o += 2 * a * t),
                      (r -= 2 * t),
                      (a *= -1);
                  this.ctx.lineTo(o + a * t, r + t);
                }
              } else if (
                "left" === this.scaleBreaks.parent._position ||
                "right" === this.scaleBreaks.parent._position
              )
                if (
                  ((d = 1 == c % 2 ? 0.5 + (d.y << 0) : d.y << 0),
                  (n = 1 == c % 2 ? 0.5 + (h.y << 0) : h.y << 0),
                  "left" === this.scaleBreaks.parent._position
                    ? ((h = this.chart.plotArea.x1),
                      (s = (this.chart.plotArea.x2 + c / 2 + 0.5) << 0))
                    : ((h = this.chart.plotArea.x2),
                      (s = (this.chart.plotArea.x1 - c / 2 + 0.5) << 0),
                      (t *= -1)),
                  (this.bounds = {
                    x1: h,
                    y1: d - c / 2,
                    x2: s,
                    y2: n + c / 2,
                  }),
                  this.ctx.moveTo(h, d),
                  "straight" === this.type ||
                    ("left" === this.scaleBreaks.parent._position && t <= 0) ||
                    ("right" === this.scaleBreaks.parent._position && 0 <= t))
                )
                  this.ctx.lineTo(s, d),
                    this.ctx.lineTo(s, n),
                    this.ctx.lineTo(h, n);
                else if ("wavy" === this.type) {
                  for (
                    r = d, a = 0.5, l = (s - (o = h)) / t / 3, p = 0;
                    p < l;
                    p++
                  )
                    this.ctx.bezierCurveTo(
                      o + t,
                      r + a * t,
                      o + 2 * t,
                      r + a * t,
                      o + 3 * t,
                      r
                    ),
                      (o += 3 * t),
                      (a *= -1);
                  for (
                    this.ctx.bezierCurveTo(
                      o + t,
                      r + a * t,
                      o + 2 * t,
                      r + a * t,
                      o + 3 * t,
                      r
                    ),
                      r = n,
                      a *= -1,
                      this.ctx.lineTo(o, r),
                      p = 0;
                    p < l;
                    p++
                  )
                    this.ctx.bezierCurveTo(
                      o - t,
                      r + a * t,
                      o - 2 * t,
                      r + a * t,
                      o - 3 * t,
                      r
                    ),
                      (o -= 3 * t),
                      (a *= -1);
                } else if ("zigzag" === this.type) {
                  for (
                    a = 1, r = d - t, l = (s - (o = h + t)) / t / 2, p = 0;
                    p < l;
                    p++
                  )
                    this.ctx.lineTo(o, r),
                      (r += 2 * a * t),
                      (o += 2 * t),
                      (a *= -1);
                  for (this.ctx.lineTo(o, r), r += n - d, p = 0; p < l + 1; p++)
                    this.ctx.lineTo(o, r),
                      (r += 2 * a * t),
                      (o -= 2 * t),
                      (a *= -1);
                  this.ctx.lineTo(o + t, r + a * t);
                }
              0 < c && this.ctx.stroke(),
                this.ctx.closePath(),
                (this.ctx.globalAlpha = this.fillOpacity),
                (this.ctx.globalCompositeOperation = "destination-over"),
                this.ctx.fill(),
                this.ctx.restore(),
                (this.ctx.globalAlpha = i),
                (this.ctx = e);
            }
          }),
          t(d, L),
          (d.prototype.createUserOptions = function (t) {
            if (void 0 !== t || this.options._isPlaceholder) {
              var e = 0;
              this.parent.options._isPlaceholder &&
                this.parent.createUserOptions(),
                this.options._isPlaceholder ||
                  (q(this.parent.stripLines),
                  (e = this.parent.options.stripLines.indexOf(this.options))),
                (this.options = void 0 === t ? {} : t),
                (this.parent.options.stripLines[e] = this.options);
            }
          }),
          (d.prototype.render = function () {
            this.ctx.save();
            var t = this.parent.getPixelCoordinatesOnAxis(this.value),
              e = Math.abs(
                "pixel" === this._thicknessType
                  ? this.thickness
                  : this.parent.conversionParameters.pixelPerUnit *
                      this.thickness
              );
            if (0 < e) {
              var i = null === this.opacity ? 1 : this.opacity;
              (this.ctx.strokeStyle = this.color), this.ctx.beginPath();
              var a,
                s,
                n,
                o,
                r = this.ctx.globalAlpha;
              (this.ctx.globalAlpha = i),
                N(this.id),
                (this.ctx.lineWidth = e),
                this.ctx.setLineDash &&
                  this.ctx.setLineDash(K(this.lineDashType, e)),
                "bottom" === this.parent._position ||
                "top" === this.parent._position
                  ? ((a = s =
                      1 == this.ctx.lineWidth % 2
                        ? 0.5 + (t.x << 0)
                        : t.x << 0),
                    (n = this.chart.plotArea.y1),
                    (o = this.chart.plotArea.y2),
                    (this.bounds = {
                      x1: a - e / 2,
                      y1: n,
                      x2: s + e / 2,
                      y2: o,
                    }))
                  : ("left" !== this.parent._position &&
                      "right" !== this.parent._position) ||
                    ((n = o =
                      1 == this.ctx.lineWidth % 2
                        ? 0.5 + (t.y << 0)
                        : t.y << 0),
                    (a = this.chart.plotArea.x1),
                    (s = this.chart.plotArea.x2),
                    (this.bounds = {
                      x1: a,
                      y1: n - e / 2,
                      x2: s,
                      y2: o + e / 2,
                    })),
                this.ctx.moveTo(a, n),
                this.ctx.lineTo(s, o),
                this.ctx.stroke(),
                (this.ctx.globalAlpha = r);
            }
            this.ctx.restore();
          }),
          t(c, L),
          (c.prototype.render = function (t, e) {
            var i,
              a,
              s,
              n,
              o = null,
              r = (o = null),
              l = "";
            if (!this.valueFormatString)
              if ("dateTime" === this.parent.valueType)
                this.valueFormatString = this.parent.valueFormatString;
              else {
                var h = 0;
                h =
                  "xySwapped" === this.chart.plotInfo.axisPlacement
                    ? 50 < this.parent.range
                      ? 0
                      : 500 < this.chart.width && this.parent.range < 25
                      ? 2
                      : Math.floor(
                          Math.abs(Math.log(this.parent.range) / Math.LN10)
                        ) +
                        (this.parent.range < 5
                          ? 2
                          : this.parent.range < 10
                          ? 1
                          : 0)
                    : 50 < this.parent.range
                    ? 0
                    : Math.floor(
                        Math.abs(Math.log(this.parent.range) / Math.LN10)
                      ) +
                      (this.parent.range < 5
                        ? 2
                        : this.parent.range < 10
                        ? 1
                        : 0);
                this.valueFormatString = v.generateValueFormatString(
                  this.parent.range,
                  h
                );
              }
            (r = null === this.opacity ? 1 : this.opacity),
              (h = Math.abs(
                "pixel" === this._thicknessType
                  ? this.thickness
                  : this.parent.conversionParameters.pixelPerUnit *
                      this.thickness
              ));
            var d = this.chart.overlaidCanvasCtx,
              c = d.globalAlpha;
            if (
              ((d.globalAlpha = r),
              d.beginPath(),
              (d.strokeStyle = this.color),
              (d.lineWidth = h),
              d.save(),
              (this.labelFontSize = U(this.options.labelFontSize)
                ? this.parent.labelFontSize
                : this.labelFontSize),
              "left" === this.parent._position ||
              "right" === this.parent._position
                ? ((this.labelMaxWidth = U(this.options.labelMaxWidth)
                    ? this.parent.bounds.x2 - this.parent.bounds.x1
                    : this.labelMaxWidth),
                  (this.labelMaxHeight =
                    U(this.options.labelWrap) || this.labelWrap
                      ? 3 * this.chart.height
                      : 2 * this.labelFontSize))
                : ("top" !== this.parent._position &&
                    "bottom" !== this.parent._position) ||
                  ((this.labelMaxWidth = U(this.options.labelMaxWidth)
                    ? 3 * this.chart.width
                    : this.labelMaxWidth),
                  (this.labelMaxHeight =
                    U(this.options.labelWrap) || this.labelWrap
                      ? this.parent.bounds.height
                      : 2 * this.labelFontSize)),
              0 < h && d.setLineDash && d.setLineDash(K(this.lineDashType, h)),
              (r = new Q(d, {
                x: 0,
                y: 0,
                padding: { top: 2, right: 3, bottom: 2, left: 4 },
                backgroundColor: this.labelBackgroundColor,
                borderColor: this.labelBorderColor,
                borderThickness: this.labelBorderThickness,
                cornerRadius: this.labelCornerRadius,
                maxWidth: this.labelMaxWidth,
                maxHeight: this.labelMaxHeight,
                angle: this.labelAngle,
                text: l,
                horizontalAlign: "left",
                fontSize: this.labelFontSize,
                fontFamily: this.labelFontFamily,
                fontWeight: this.labelFontWeight,
                fontColor: this.labelFontColor,
                fontStyle: this.labelFontStyle,
                textBaseline: "middle",
              })),
              this.snapToDataPoint)
            ) {
              var p = 0;
              o = [];
              if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                var u = null;
                "bottom" === this.parent._position ||
                "top" === this.parent._position
                  ? (p = this.parent.dataSeries[0].axisX.convertPixelToValue({
                      y: e,
                    }))
                  : ("left" !== this.parent._position &&
                      "right" !== this.parent._position) ||
                    (p = this.parent.convertPixelToValue({ y: e }));
                for (var x = 0; x < this.parent.dataSeries.length; x++)
                  (u = this.parent.dataSeries[x].getDataPointAtX(p, !0)) &&
                    0 <= u.index &&
                    ((u.dataSeries = this.parent.dataSeries[x]),
                    null !== u.dataPoint.y && o.push(u));
                if (((u = null), 0 === o.length)) return;
                if (
                  (o.sort(function (t, e) {
                    return t.distance - e.distance;
                  }),
                  (u = Math.abs(
                    t - this.parent.convertValueToPixel(o[0].dataPoint.y)
                  )),
                  "rangeBar" === o[(x = 0)].dataSeries.type ||
                    "error" === o[0].dataSeries.type)
                ) {
                  u = Math.abs(
                    t - this.parent.convertValueToPixel(o[x].dataPoint.y[0])
                  );
                  var m = 0;
                  for (p = 0; p < o.length; p++)
                    if (o[p].dataPoint.y && o[p].dataPoint.y.length)
                      for (l = 0; l < o[p].dataPoint.y.length; l++)
                        (m = Math.abs(
                          t -
                            this.parent.convertValueToPixel(o[p].dataPoint.y[l])
                        )) < u && ((u = m), (x = p));
                    else
                      (m = Math.abs(
                        t - this.parent.convertValueToPixel(o[p].dataPoint.y)
                      )) < u && ((u = m), (x = p));
                } else if ("stackedBar" === o[0].dataSeries.type) {
                  u = Math.abs(
                    t - this.parent.convertValueToPixel(o[0].dataPoint.y)
                  );
                  var g = (m = 0);
                  for (p = x = 0; p < o.length; p++)
                    if (o[p].dataPoint.y && o[p].dataPoint.y.length)
                      for (l = 0; l < o[p].dataPoint.y.length; l++)
                        (m = Math.abs(
                          t -
                            this.parent.convertValueToPixel(o[p].dataPoint.y[l])
                        )) < u && ((u = m), (x = p));
                    else
                      (g += o[p].dataPoint.y),
                        (m = Math.abs(t - this.parent.convertValueToPixel(g))) <
                          u && ((u = m), (x = p));
                } else if ("stackedBar100" === o[0].dataSeries.type) {
                  u = Math.abs(
                    t - this.parent.convertValueToPixel(o[0].dataPoint.y)
                  );
                  var b = (g = m = 0);
                  for (p = 0; p < o.length; p++)
                    if (o[p].dataPoint.y && o[p].dataPoint.y.length)
                      for (l = 0; l < o[p].dataPoint.y.length; l++)
                        (m = Math.abs(
                          t -
                            this.parent.convertValueToPixel(o[p].dataPoint.y[l])
                        )) < u && ((u = m), (x = p));
                    else
                      (g += o[p].dataPoint.y),
                        (b = o[p].dataPoint.x.getTime
                          ? o[p].dataPoint.x.getTime()
                          : o[p].dataPoint.x),
                        (b =
                          (g / o[p].dataSeries.plotUnit.dataPointYSums[b]) *
                          100),
                        (m = Math.abs(t - this.parent.convertValueToPixel(b))) <
                          u && ((u = m), (x = p));
                } else
                  for (
                    u = Math.abs(
                      t - this.parent.convertValueToPixel(o[0].dataPoint.y)
                    ),
                      p = x = m = 0;
                    p < o.length;
                    p++
                  )
                    if (o[p].dataPoint.y && o[p].dataPoint.y.length)
                      for (l = 0; l < o[p].dataPoint.y.length; l++)
                        (m = Math.abs(
                          t -
                            this.parent.convertValueToPixel(o[p].dataPoint.y[l])
                        )) < u && ((u = m), (x = p));
                    else
                      (m = Math.abs(
                        t - this.parent.convertValueToPixel(o[p].dataPoint.y)
                      )) < u && ((u = m), (x = p));
                if (
                  ((l = o[x]),
                  "bottom" === this.parent._position ||
                    "top" === this.parent._position)
                ) {
                  if (
                    ((i = 0),
                    "rangeBar" === this.parent.dataSeries[x].type ||
                      "error" === this.parent.dataSeries[x].type)
                  ) {
                    for (
                      u = Math.abs(
                        t - this.parent.convertValueToPixel(l.dataPoint.y[0])
                      ),
                        p = m = 0;
                      p < l.dataPoint.y.length;
                      p++
                    )
                      (m = Math.abs(
                        t - this.parent.convertValueToPixel(l.dataPoint.y[p])
                      )) < u && ((u = m), (i = p));
                    (o =
                      1 == d.lineWidth % 2
                        ? 0.5 +
                          (this.parent.convertValueToPixel(l.dataPoint.y[i]) <<
                            0)
                        : this.parent.convertValueToPixel(l.dataPoint.y[i]) <<
                          0),
                      (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: l.dataPoint.y[i],
                          })
                        : U(this.options.label)
                        ? at(
                            l.dataPoint.y[i],
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label);
                  } else if ("stackedBar" === this.parent.dataSeries[x].type) {
                    for (
                      u = Math.abs(
                        t - this.parent.convertValueToPixel(o[0].dataPoint.y)
                      ),
                        g = m = 0,
                        p = x;
                      0 <= p;
                      p--
                    )
                      (g += o[p].dataPoint.y),
                        (m = Math.abs(t - this.parent.convertValueToPixel(g))) <
                          u && ((u = m), (i = p));
                    (o =
                      1 == d.lineWidth % 2
                        ? 0.5 + (this.parent.convertValueToPixel(g) << 0)
                        : this.parent.convertValueToPixel(g) << 0),
                      (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: l.dataPoint.y,
                          })
                        : U(this.options.label)
                        ? at(
                            l.dataPoint.y,
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label);
                  } else if (
                    "stackedBar100" === this.parent.dataSeries[x].type
                  ) {
                    for (
                      u = Math.abs(
                        t - this.parent.convertValueToPixel(o[0].dataPoint.y)
                      ),
                        b = g = m = 0,
                        p = x;
                      0 <= p;
                      p--
                    )
                      (g += o[p].dataPoint.y),
                        (b = o[p].dataPoint.x.getTime
                          ? o[p].dataPoint.x.getTime()
                          : o[p].dataPoint.x),
                        (b =
                          (g / o[p].dataSeries.plotUnit.dataPointYSums[b]) *
                          100),
                        (m = Math.abs(t - this.parent.convertValueToPixel(b))) <
                          u && ((u = m), (i = p));
                    (o =
                      1 == d.lineWidth % 2
                        ? 0.5 + (this.parent.convertValueToPixel(b) << 0)
                        : this.parent.convertValueToPixel(b) << 0),
                      (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: b,
                          })
                        : U(this.options.label)
                        ? at(b, this.valueFormatString, this.chart._cultureInfo)
                        : this.label);
                  } else
                    (o =
                      1 == d.lineWidth % 2
                        ? 0.5 +
                          (this.parent.convertValueToPixel(l.dataPoint.y) << 0)
                        : this.parent.convertValueToPixel(l.dataPoint.y) << 0),
                      (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: l.dataPoint.y,
                          })
                        : U(this.options.label)
                        ? at(
                            l.dataPoint.y,
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label);
                  (i = a = o),
                    (s = this.chart.plotArea.y1),
                    (n = this.chart.plotArea.y2),
                    (this.bounds = {
                      x1: i - h / 2,
                      y1: s,
                      x2: a + h / 2,
                      y2: n,
                    }),
                    (r.x = i - r.measureText().width / 2),
                    r.x + r.width > this.chart.bounds.x2
                      ? (r.x = this.chart.bounds.x2 - r.width)
                      : r.x < this.chart.bounds.x1 &&
                        (r.x = this.chart.bounds.x1),
                    (r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2);
                } else if (
                  "left" === this.parent._position ||
                  "right" === this.parent._position
                ) {
                  if (
                    ((s =
                      n =
                      o =
                        1 == d.lineWidth % 2
                          ? 0.5 +
                            (this.parent.convertValueToPixel(l.dataPoint.x) <<
                              0)
                          : this.parent.convertValueToPixel(l.dataPoint.x) <<
                            0),
                    (i = this.chart.plotArea.x1),
                    (a = this.chart.plotArea.x2),
                    (b = !(this.bounds = {
                      x1: i,
                      y1: s - h / 2,
                      x2: a,
                      y2: n + h / 2,
                    })),
                    this.parent.labels)
                  )
                    for (
                      o = Math.ceil(this.parent.interval), p = 0;
                      p < this.parent.viewportMaximum;
                      p += o
                    ) {
                      if (!this.parent.labels[p]) {
                        b = !1;
                        break;
                      }
                      b = !0;
                    }
                  if (b) {
                    if ("axisX" === this.parent.type)
                      for (
                        p = this.parent.convertPixelToValue({ y: e }),
                          u = null,
                          x = 0;
                        x < this.parent.dataSeries.length;
                        x++
                      )
                        (u = this.parent.dataSeries[x].getDataPointAtX(
                          p,
                          !0
                        )) &&
                          0 <= u.index &&
                          (r.text = this.labelFormatter
                            ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.parent.options,
                                crosshair: this.options,
                                value: l.dataPoint.x,
                              })
                            : U(this.options.label)
                            ? u.dataPoint.label
                            : this.label);
                  } else
                    "dateTime" === this.parent.valueType
                      ? (r.text = this.labelFormatter
                          ? this.labelFormatter({
                              chart: this.chart,
                              axis: this.parent.options,
                              crosshair: this.options,
                              value: l.dataPoint.x,
                            })
                          : U(this.options.label)
                          ? it(
                              l.dataPoint.x,
                              this.valueFormatString,
                              this.chart._cultureInfo
                            )
                          : this.label)
                      : "number" === this.parent.valueType &&
                        (r.text = this.labelFormatter
                          ? this.labelFormatter({
                              chart: this.chart,
                              axis: this.parent.options,
                              crosshair: this.options,
                              value: l.dataPoint.x,
                            })
                          : U(this.options.label)
                          ? at(
                              l.dataPoint.x,
                              this.valueFormatString,
                              this.chart._cultureInfo
                            )
                          : this.label);
                  (r.y = n + r.fontSize / 2 - r.measureText().height / 2 + 2),
                    r.y - r.fontSize / 2 < this.chart.bounds.y1
                      ? (r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2)
                      : r.y + r.measureText().height - r.fontSize / 2 >
                          this.chart.bounds.y2 &&
                        (r.y =
                          this.chart.bounds.y2 -
                          r.measureText().height +
                          r.fontSize / 2),
                    "left" === this.parent._position
                      ? (r.x =
                          this.parent.lineCoordinates.x2 -
                          r.measureText().width)
                      : "right" === this.parent._position &&
                        (r.x = this.parent.lineCoordinates.x2);
                }
              } else if (
                "bottom" === this.parent._position ||
                "top" === this.parent._position
              ) {
                for (
                  p = this.parent.convertPixelToValue({ x: t }), x = 0;
                  x < this.parent.dataSeries.length;
                  x++
                )
                  (u = this.parent.dataSeries[x].getDataPointAtX(p, !0)) &&
                    0 <= u.index &&
                    ((u.dataSeries = this.parent.dataSeries[x]),
                    null !== u.dataPoint.y && o.push(u));
                if (0 === o.length) return;
                if (
                  (o.sort(function (t, e) {
                    return t.distance - e.distance;
                  }),
                  (l = o[0]),
                  (i =
                    a =
                    o =
                      1 == d.lineWidth % 2
                        ? 0.5 +
                          (this.parent.convertValueToPixel(l.dataPoint.x) << 0)
                        : this.parent.convertValueToPixel(l.dataPoint.x) << 0),
                  (s = this.chart.plotArea.y1),
                  (n = this.chart.plotArea.y2),
                  (b = !(this.bounds = {
                    x1: i - h / 2,
                    y1: s,
                    x2: a + h / 2,
                    y2: n,
                  })),
                  this.parent.labels)
                )
                  for (
                    o = Math.ceil(this.parent.interval), p = 0;
                    p < this.parent.viewportMaximum;
                    p += o
                  ) {
                    if (!this.parent.labels[p]) {
                      b = !1;
                      break;
                    }
                    b = !0;
                  }
                if (b) {
                  if ("axisX" === this.parent.type)
                    for (
                      p = this.parent.convertPixelToValue({ x: t }),
                        u = null,
                        x = 0;
                      x < this.parent.dataSeries.length;
                      x++
                    )
                      (u = this.parent.dataSeries[x].getDataPointAtX(p, !0)) &&
                        0 <= u.index &&
                        (r.text = this.labelFormatter
                          ? this.labelFormatter({
                              chart: this.chart,
                              axis: this.parent.options,
                              crosshair: this.options,
                              value: l.dataPoint.x,
                            })
                          : U(this.options.label)
                          ? u.dataPoint.label
                          : this.label);
                } else
                  "dateTime" === this.parent.valueType
                    ? (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: l.dataPoint.x,
                          })
                        : U(this.options.label)
                        ? it(
                            l.dataPoint.x,
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label)
                    : "number" === this.parent.valueType &&
                      (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: l.dataPoint.x,
                          })
                        : U(this.options.label)
                        ? at(
                            l.dataPoint.x,
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label);
                (r.x = i - r.measureText().width / 2),
                  r.x + r.width > this.chart.bounds.x2 &&
                    (r.x = this.chart.bounds.x2 - r.width),
                  r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1),
                  "bottom" === this.parent._position
                    ? (r.y =
                        this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2)
                    : "top" === this.parent._position &&
                      (r.y =
                        this.parent.lineCoordinates.y1 -
                        r.height +
                        r.fontSize / 2 +
                        2);
              } else if (
                "left" === this.parent._position ||
                "right" === this.parent._position
              ) {
                for (
                  !U(this.parent.dataSeries) &&
                    0 < this.parent.dataSeries.length &&
                    (p = this.parent.dataSeries[0].axisX.convertPixelToValue({
                      x: t,
                    })),
                    x = 0;
                  x < this.parent.dataSeries.length;
                  x++
                )
                  (u = this.parent.dataSeries[x].getDataPointAtX(p, !0)) &&
                    0 <= u.index &&
                    ((u.dataSeries = this.parent.dataSeries[x]),
                    null !== u.dataPoint.y && o.push(u));
                if (0 === o.length) return;
                if (
                  (o.sort(function (t, e) {
                    return t.distance - e.distance;
                  }),
                  "rangeColumn" === o[(x = 0)].dataSeries.type ||
                    "rangeArea" === o[0].dataSeries.type ||
                    "error" === o[0].dataSeries.type ||
                    "rangeSplineArea" === o[0].dataSeries.type ||
                    "candlestick" === o[0].dataSeries.type ||
                    "ohlc" === o[0].dataSeries.type ||
                    "boxAndWhisker" === o[0].dataSeries.type)
                )
                  for (
                    u = Math.abs(
                      e - this.parent.convertValueToPixel(o[0].dataPoint.y[0])
                    ),
                      p = m = 0;
                    p < o.length;
                    p++
                  )
                    if (o[p].dataPoint.y && o[p].dataPoint.y.length)
                      for (l = 0; l < o[p].dataPoint.y.length; l++)
                        (m = Math.abs(
                          e -
                            this.parent.convertValueToPixel(o[p].dataPoint.y[l])
                        )) < u && ((u = m), (x = p));
                    else
                      (m = Math.abs(
                        e - this.parent.convertValueToPixel(o[p].dataPoint.y)
                      )) < u && ((u = m), (x = p));
                else if (
                  "stackedColumn" === o[0].dataSeries.type ||
                  "stackedArea" === o[0].dataSeries.type
                )
                  for (
                    u = Math.abs(
                      e - this.parent.convertValueToPixel(o[0].dataPoint.y)
                    ),
                      p = g = m = 0;
                    p < o.length;
                    p++
                  )
                    if (o[p].dataPoint.y && o[p].dataPoint.y.length)
                      for (l = 0; l < o[p].dataPoint.y.length; l++)
                        (m = Math.abs(
                          e -
                            this.parent.convertValueToPixel(o[p].dataPoint.y[l])
                        )) < u && ((u = m), (x = p));
                    else
                      (g += o[p].dataPoint.y),
                        (m = Math.abs(e - this.parent.convertValueToPixel(g))) <
                          u && ((u = m), (x = p));
                else if (
                  "stackedColumn100" === o[0].dataSeries.type ||
                  "stackedArea100" === o[0].dataSeries.type
                )
                  for (
                    u = Math.abs(
                      e - this.parent.convertValueToPixel(o[0].dataPoint.y)
                    ),
                      p = b = g = m = 0;
                    p < o.length;
                    p++
                  )
                    if (o[p].dataPoint.y && o[p].dataPoint.y.length)
                      for (l = 0; l < o[p].dataPoint.y.length; l++)
                        (m = Math.abs(
                          e -
                            this.parent.convertValueToPixel(o[p].dataPoint.y[l])
                        )) < u && ((u = m), (x = p));
                    else
                      (g += o[p].dataPoint.y),
                        (b = o[p].dataPoint.x.getTime
                          ? o[p].dataPoint.x.getTime()
                          : o[p].dataPoint.x),
                        (b =
                          (g / o[p].dataSeries.plotUnit.dataPointYSums[b]) *
                          100),
                        (m = Math.abs(e - this.parent.convertValueToPixel(b))) <
                          u && ((u = m), (x = p));
                else
                  for (
                    u = Math.abs(
                      e - this.parent.convertValueToPixel(o[0].dataPoint.y)
                    ),
                      p = m = 0;
                    p < o.length;
                    p++
                  )
                    if (o[p].dataPoint.y && o[p].dataPoint.y.length)
                      for (l = 0; l < o[p].dataPoint.y.length; l++)
                        (m = Math.abs(
                          e -
                            this.parent.convertValueToPixel(o[p].dataPoint.y[l])
                        )) < u && ((u = m), (x = p));
                    else
                      (m = Math.abs(
                        e - this.parent.convertValueToPixel(o[p].dataPoint.y)
                      )) < u && ((u = m), (x = p));
                if (
                  ((l = o[x]),
                  (i = 0),
                  "rangeColumn" === this.parent.dataSeries[x].type ||
                    "rangeArea" === this.parent.dataSeries[x].type ||
                    "error" === this.parent.dataSeries[x].type ||
                    "rangeSplineArea" === this.parent.dataSeries[x].type ||
                    "candlestick" === this.parent.dataSeries[x].type ||
                    "ohlc" === this.parent.dataSeries[x].type ||
                    "boxAndWhisker" === this.parent.dataSeries[x].type)
                ) {
                  for (
                    u = Math.abs(
                      e - this.parent.convertValueToPixel(l.dataPoint.y[0])
                    ),
                      p = m = 0;
                    p < l.dataPoint.y.length;
                    p++
                  )
                    (m = Math.abs(
                      e - this.parent.convertValueToPixel(l.dataPoint.y[p])
                    )) < u && ((u = m), (i = p));
                  (o =
                    1 == d.lineWidth % 2
                      ? 0.5 +
                        (this.parent.convertValueToPixel(l.dataPoint.y[i]) << 0)
                      : this.parent.convertValueToPixel(l.dataPoint.y[i]) << 0),
                    (r.text = this.labelFormatter
                      ? this.labelFormatter({
                          chart: this.chart,
                          axis: this.parent.options,
                          crosshair: this.options,
                          value: l.dataPoint.y[i],
                        })
                      : U(this.options.label)
                      ? at(
                          l.dataPoint.y[i],
                          this.valueFormatString,
                          this.chart._cultureInfo
                        )
                      : this.label);
                } else if (
                  "stackedColumn" === this.parent.dataSeries[x].type ||
                  "stackedArea" === this.parent.dataSeries[x].type
                ) {
                  for (
                    u = Math.abs(
                      e - this.parent.convertValueToPixel(o[0].dataPoint.y)
                    ),
                      g = m = 0,
                      p = x;
                    0 <= p;
                    p--
                  )
                    (g += o[p].dataPoint.y),
                      (m = Math.abs(e - this.parent.convertValueToPixel(g))) <
                        u && ((u = m), (i = p));
                  (o =
                    1 == d.lineWidth % 2
                      ? 0.5 + (this.parent.convertValueToPixel(g) << 0)
                      : this.parent.convertValueToPixel(g) << 0),
                    (r.text = this.labelFormatter
                      ? this.labelFormatter({
                          chart: this.chart,
                          axis: this.parent.options,
                          crosshair: this.options,
                          value: l.dataPoint.y,
                        })
                      : U(this.options.label)
                      ? at(
                          l.dataPoint.y,
                          this.valueFormatString,
                          this.chart._cultureInfo
                        )
                      : this.label);
                } else if (
                  "stackedColumn100" === this.parent.dataSeries[x].type ||
                  "stackedArea100" === this.parent.dataSeries[x].type
                ) {
                  for (
                    u = Math.abs(
                      e - this.parent.convertValueToPixel(o[0].dataPoint.y)
                    ),
                      g = m = 0,
                      p = x;
                    0 <= p;
                    p--
                  )
                    (g += o[p].dataPoint.y),
                      (b = o[p].dataPoint.x.getTime
                        ? o[p].dataPoint.x.getTime()
                        : o[p].dataPoint.x),
                      (b =
                        (g / o[p].dataSeries.plotUnit.dataPointYSums[b]) * 100),
                      (m = Math.abs(e - this.parent.convertValueToPixel(b))) <
                        u && ((u = m), (i = p));
                  (o =
                    1 == d.lineWidth % 2
                      ? 0.5 + (this.parent.convertValueToPixel(b) << 0)
                      : this.parent.convertValueToPixel(b) << 0),
                    (r.text = this.labelFormatter
                      ? this.labelFormatter({
                          chart: this.chart,
                          axis: this.parent.options,
                          crosshair: this.options,
                          value: b,
                        })
                      : U(this.options.label)
                      ? at(b, this.valueFormatString, this.chart._cultureInfo)
                      : this.label);
                } else
                  "waterfall" === this.parent.dataSeries[x].type
                    ? ((o =
                        1 == d.lineWidth % 2
                          ? 0.5 +
                            (this.parent.convertValueToPixel(
                              l.dataSeries.dataPointEOs[l.index].cumulativeSum
                            ) <<
                              0)
                          : this.parent.convertValueToPixel(
                              l.dataSeries.dataPointEOs[l.index].cumulativeSum
                            ) << 0),
                      (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value:
                              l.dataSeries.dataPointEOs[l.index].cumulativeSum,
                          })
                        : U(this.options.label)
                        ? at(
                            l.dataSeries.dataPointEOs[l.index].cumulativeSum,
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label))
                    : ((o =
                        1 == d.lineWidth % 2
                          ? 0.5 +
                            (this.parent.convertValueToPixel(l.dataPoint.y) <<
                              0)
                          : this.parent.convertValueToPixel(l.dataPoint.y) <<
                            0),
                      (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: l.dataPoint.y,
                          })
                        : U(this.options.label)
                        ? at(
                            l.dataPoint.y,
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label));
                (s = n = o),
                  (i = this.chart.plotArea.x1),
                  (a = this.chart.plotArea.x2),
                  (this.bounds = {
                    x1: i,
                    y1: s - h / 2,
                    x2: a,
                    y2: n + h / 2,
                  }),
                  (r.y = n + r.fontSize / 2 - r.measureText().height / 2 + 2),
                  r.y - r.fontSize / 2 < this.chart.bounds.y1
                    ? (r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2)
                    : r.y + r.measureText().height - r.fontSize / 2 >
                        this.chart.bounds.y2 &&
                      (r.y =
                        this.chart.bounds.y2 -
                        r.measureText().height +
                        r.fontSize / 2),
                  "left" === this.parent._position
                    ? (r.x =
                        this.parent.lineCoordinates.x2 - r.measureText().width)
                    : "right" === this.parent._position &&
                      (r.x = this.parent.lineCoordinates.x2);
              }
              (o = null),
                ("bottom" === this.parent._position ||
                  "top" === this.parent._position) &&
                  i >=
                    this.parent.convertValueToPixel(
                      this.parent.viewportMinimum
                    ) &&
                  a <=
                    this.parent.convertValueToPixel(
                      this.parent.viewportMaximum
                    ) &&
                  (0 < h && (d.moveTo(i, s), d.lineTo(a, n), d.stroke()),
                  d.restore(),
                  !U(r.text) &&
                    ("number" == typeof r.text.valueOf() ||
                      0 < r.text.length) &&
                    r.render(!0)),
                ("left" === this.parent._position ||
                  "right" === this.parent._position) &&
                  n >=
                    this.parent.convertValueToPixel(
                      this.parent.viewportMaximum
                    ) &&
                  s <=
                    this.parent.convertValueToPixel(
                      this.parent.viewportMinimum
                    ) &&
                  (0 < h && (d.moveTo(i, s), d.lineTo(a, n), d.stroke()),
                  d.restore(),
                  !U(r.text) &&
                    ("number" == typeof r.text.valueOf() ||
                      0 < r.text.length) &&
                    r.render(!0));
            } else {
              if (
                ("bottom" === this.parent._position ||
                "top" === this.parent._position
                  ? ((i =
                      a =
                      o =
                        1 == d.lineWidth % 2 ? 0.5 + (t << 0) : t << 0),
                    (s = this.chart.plotArea.y1),
                    (n = this.chart.plotArea.y2),
                    (this.bounds = {
                      x1: i - h / 2,
                      y1: s,
                      x2: a + h / 2,
                      y2: n,
                    }))
                  : ("left" !== this.parent._position &&
                      "right" !== this.parent._position) ||
                    ((s =
                      n =
                      o =
                        1 == d.lineWidth % 2 ? 0.5 + (e << 0) : e << 0),
                    (i = this.chart.plotArea.x1),
                    (a = this.chart.plotArea.x2),
                    (this.bounds = {
                      x1: i,
                      y1: s - h / 2,
                      x2: a,
                      y2: n + h / 2,
                    })),
                "xySwapped" === this.chart.plotInfo.axisPlacement)
              )
                if (
                  "left" === this.parent._position ||
                  "right" === this.parent._position
                ) {
                  if (((b = !1), this.parent.labels))
                    for (
                      o = Math.ceil(this.parent.interval), p = 0;
                      p < this.parent.viewportMaximum;
                      p += o
                    ) {
                      if (!this.parent.labels[p]) {
                        b = !1;
                        break;
                      }
                      b = !0;
                    }
                  if (b) {
                    if ("axisX" === this.parent.type)
                      for (
                        p = this.parent.convertPixelToValue({ y: e }),
                          u = null,
                          x = 0;
                        x < this.parent.dataSeries.length;
                        x++
                      )
                        (u = this.parent.dataSeries[x].getDataPointAtX(
                          p,
                          !0
                        )) &&
                          0 <= u.index &&
                          (r.text = this.labelFormatter
                            ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.parent.options,
                                crosshair: this.options,
                                value: this.parent.convertPixelToValue(t),
                              })
                            : U(this.options.label)
                            ? u.dataPoint.label
                            : this.label);
                  } else
                    "dateTime" === this.parent.valueType
                      ? (r.text = this.labelFormatter
                          ? this.labelFormatter({
                              chart: this.chart,
                              axis: this.parent.options,
                              crosshair: this.options,
                              value: this.parent.convertPixelToValue(e),
                            })
                          : U(this.options.label)
                          ? it(
                              this.parent.convertPixelToValue(e),
                              this.valueFormatString,
                              this.chart._cultureInfo
                            )
                          : this.label)
                      : "number" === this.parent.valueType &&
                        (r.text = this.labelFormatter
                          ? this.labelFormatter({
                              chart: this.chart,
                              axis: this.parent.options,
                              crosshair: this.options,
                              value: this.parent.convertPixelToValue(e),
                            })
                          : U(this.options.label)
                          ? at(
                              this.parent.convertPixelToValue(e),
                              this.valueFormatString,
                              this.chart._cultureInfo
                            )
                          : this.label);
                  (r.y = e + r.fontSize / 2 - r.measureText().height / 2 + 2),
                    r.y - r.fontSize / 2 < this.chart.bounds.y1
                      ? (r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2)
                      : r.y + r.measureText().height - r.fontSize / 2 >
                          this.chart.bounds.y2 &&
                        (r.y =
                          this.chart.bounds.y2 -
                          r.measureText().height +
                          r.fontSize / 2),
                    "left" === this.parent._position
                      ? (r.x =
                          this.parent.lineCoordinates.x1 -
                          r.measureText().width)
                      : "right" === this.parent._position &&
                        (r.x = this.parent.lineCoordinates.x2);
                } else
                  ("bottom" !== this.parent._position &&
                    "top" !== this.parent._position) ||
                    ((r.text = this.labelFormatter
                      ? this.labelFormatter({
                          chart: this.chart,
                          axis: this.parent.options,
                          crosshair: this.options,
                          value: this.parent.convertPixelToValue(t),
                        })
                      : U(this.options.label)
                      ? at(
                          this.parent.convertPixelToValue(t),
                          this.valueFormatString,
                          this.chart._cultureInfo
                        )
                      : this.label),
                    (r.x = i - r.measureText().width / 2),
                    r.x + r.width > this.chart.bounds.x2 &&
                      (r.x = this.chart.bounds.x2 - r.width),
                    r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1),
                    "bottom" === this.parent._position &&
                      (r.y =
                        this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2),
                    "top" === this.parent._position &&
                      (r.y =
                        this.parent.lineCoordinates.y1 -
                        r.height +
                        r.fontSize / 2 +
                        2));
              else if (
                "bottom" === this.parent._position ||
                "top" === this.parent._position
              ) {
                if (((b = !1), (l = ""), this.parent.labels))
                  for (
                    o = Math.ceil(this.parent.interval), p = 0;
                    p < this.parent.viewportMaximum;
                    p += o
                  ) {
                    if (!this.parent.labels[p]) {
                      b = !1;
                      break;
                    }
                    b = !0;
                  }
                if (b) {
                  if ("axisX" === this.parent.type)
                    for (
                      p = this.parent.convertPixelToValue({ x: t }),
                        u = null,
                        x = 0;
                      x < this.parent.dataSeries.length;
                      x++
                    )
                      (u = this.parent.dataSeries[x].getDataPointAtX(p, !0)) &&
                        0 <= u.index &&
                        (r.text = this.labelFormatter
                          ? this.labelFormatter({
                              chart: this.chart,
                              axis: this.parent.options,
                              crosshair: this.options,
                              value: this.parent.convertPixelToValue(t),
                            })
                          : U(this.options.label)
                          ? u.dataPoint.label
                          : this.label);
                } else
                  "dateTime" === this.parent.valueType
                    ? (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: this.parent.convertPixelToValue(t),
                          })
                        : U(this.options.label)
                        ? it(
                            this.parent.convertPixelToValue(t),
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label)
                    : "number" === this.parent.valueType &&
                      (r.text = this.labelFormatter
                        ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value:
                              0 < this.parent.dataSeries.length
                                ? this.parent.convertPixelToValue(t)
                                : "",
                          })
                        : U(this.options.label)
                        ? at(
                            this.parent.convertPixelToValue(t),
                            this.valueFormatString,
                            this.chart._cultureInfo
                          )
                        : this.label);
                (r.x = i - r.measureText().width / 2),
                  r.x + r.width > this.chart.bounds.x2 &&
                    (r.x = this.chart.bounds.x2 - r.width),
                  r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1),
                  "bottom" === this.parent._position
                    ? (r.y =
                        this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2)
                    : "top" === this.parent._position &&
                      (r.y =
                        this.parent.lineCoordinates.y1 -
                        r.height +
                        r.fontSize / 2 +
                        2);
              } else
                ("left" !== this.parent._position &&
                  "right" !== this.parent._position) ||
                  ((r.text = this.labelFormatter
                    ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: this.parent.convertPixelToValue(e),
                      })
                    : U(this.options.label)
                    ? at(
                        this.parent.convertPixelToValue(e),
                        this.valueFormatString,
                        this.chart._cultureInfo
                      )
                    : this.label),
                  (r.y = e + r.fontSize / 2 - r.measureText().height / 2 + 2),
                  r.y - r.fontSize / 2 < this.chart.bounds.y1
                    ? (r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2)
                    : r.y + r.measureText().height - r.fontSize / 2 >
                        this.chart.bounds.y2 &&
                      (r.y =
                        this.chart.bounds.y2 -
                        r.measureText().height +
                        r.fontSize / 2),
                  "left" === this.parent._position
                    ? (r.x =
                        this.parent.lineCoordinates.x2 - r.measureText().width)
                    : "right" === this.parent._position &&
                      (r.x = this.parent.lineCoordinates.x2));
              0 < h && (d.moveTo(i, s), d.lineTo(a, n), d.stroke()),
                d.restore(),
                !U(r.text) &&
                  ("number" == typeof r.text.valueOf() || 0 < r.text.length) &&
                  r.render(!0);
            }
            d.globalAlpha = c;
          }),
          t(n, L),
          (n.prototype._initialize = function () {
            var t;
            this.enabled &&
              ((this.container = document.createElement("div")),
              this.container.setAttribute("class", "canvasjs-chart-tooltip"),
              (this.container.style.position = "absolute"),
              (this.container.style.height = "auto"),
              (this.container.style.boxShadow =
                "1px 1px 2px 2px rgba(0,0,0,0.1)"),
              (this.container.style.zIndex = "1000"),
              (this.container.style.pointerEvents = "none"),
              (this.container.style.display = "none"),
              (t = '<div style=" width: auto;height: auto;min-width: 50px;'),
              (t += "line-height: auto;"),
              (t += "margin: 0px 0px 0px 0px;"),
              (t += "padding: 5px;"),
              (t += "font-family: Calibri, Arial, Georgia, serif;"),
              (t += "font-weight: normal;"),
              (t += "font-style: " + (Z ? "italic;" : "normal;")),
              (t += "font-size: 14px;"),
              (t += "color: #000000;"),
              (t += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);"),
              (t += "text-align: left;"),
              (t += "border: 2px solid gray;"),
              (t += Z
                ? "background: rgba(255,255,255,.9);"
                : "background: rgb(255,255,255);"),
              (t += "text-indent: 0px;"),
              (t += "white-space: nowrap;"),
              (t += "border-radius: 5px;"),
              (t += "-moz-user-select:none;"),
              (t += "-khtml-user-select: none;"),
              (t += "-webkit-user-select: none;"),
              (t += "-ms-user-select: none;"),
              (t += "user-select: none;"),
              Z ||
                ((t += "filter: alpha(opacity = 90);"),
                (t +=
                  "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');")),
              (t += '} "> Sample Tooltip</div>'),
              (this.container.innerHTML = t),
              (this.contentDiv = this.container.firstChild),
              (this.container.style.borderRadius =
                this.contentDiv.style.borderRadius),
              this.chart._canvasJSContainer.appendChild(this.container));
          }),
          (n.prototype.mouseMoveHandler = function (t, e) {
            (this._lastUpdated &&
              new Date().getTime() - this._lastUpdated < 4) ||
              ((this._lastUpdated = new Date().getTime()),
              this.chart.resetOverlayedCanvas(),
              this._updateToolTip(t, e));
          }),
          (n.prototype._updateToolTip = function (t, e, i) {
            if (
              ((i = void 0 === i || i),
              this.container || this._initialize(),
              this.enabled || this.hide(),
              !this.chart.disableToolTip)
            ) {
              if (void 0 === t || void 0 === e) {
                if (isNaN(this._prevX) || isNaN(this._prevY)) return;
                (t = this._prevX), (e = this._prevY);
              } else (this._prevX = t), (this._prevY = e);
              var a = null,
                s = null,
                n = [],
                o = 0;
              if (
                this.shared &&
                this.enabled &&
                "none" !== this.chart.plotInfo.axisPlacement
              ) {
                if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                  var r = [];
                  if (this.chart.axisX)
                    for (var l = 0; l < this.chart.axisX.length; l++) {
                      o = this.chart.axisX[l].convertPixelToValue({ y: e });
                      var h = null;
                      for (
                        a = 0;
                        a < this.chart.axisX[l].dataSeries.length;
                        a++
                      )
                        (h = this.chart.axisX[l].dataSeries[a].getDataPointAtX(
                          o,
                          i
                        )) &&
                          0 <= h.index &&
                          ((h.dataSeries = this.chart.axisX[l].dataSeries[a]),
                          null !== h.dataPoint.y && r.push(h));
                      h = null;
                    }
                  if (this.chart.axisX2)
                    for (l = 0; l < this.chart.axisX2.length; l++) {
                      for (
                        o = this.chart.axisX2[l].convertPixelToValue({ y: e }),
                          h = null,
                          a = 0;
                        a < this.chart.axisX2[l].dataSeries.length;
                        a++
                      )
                        (h = this.chart.axisX2[l].dataSeries[a].getDataPointAtX(
                          o,
                          i
                        )) &&
                          0 <= h.index &&
                          ((h.dataSeries = this.chart.axisX2[l].dataSeries[a]),
                          null !== h.dataPoint.y && r.push(h));
                      h = null;
                    }
                } else {
                  if (((r = []), this.chart.axisX))
                    for (l = 0; l < this.chart.axisX.length; l++)
                      for (
                        o = this.chart.axisX[l].convertPixelToValue({ x: t }),
                          h = null,
                          a = 0;
                        a < this.chart.axisX[l].dataSeries.length;
                        a++
                      )
                        (h = this.chart.axisX[l].dataSeries[a].getDataPointAtX(
                          o,
                          i
                        )) &&
                          0 <= h.index &&
                          ((h.dataSeries = this.chart.axisX[l].dataSeries[a]),
                          null !== h.dataPoint.y && r.push(h));
                  if (this.chart.axisX2)
                    for (l = 0; l < this.chart.axisX2.length; l++)
                      for (
                        o = this.chart.axisX2[l].convertPixelToValue({ x: t }),
                          h = null,
                          a = 0;
                        a < this.chart.axisX2[l].dataSeries.length;
                        a++
                      )
                        (h = this.chart.axisX2[l].dataSeries[a].getDataPointAtX(
                          o,
                          i
                        )) &&
                          0 <= h.index &&
                          ((h.dataSeries = this.chart.axisX2[l].dataSeries[a]),
                          null !== h.dataPoint.y && r.push(h));
                }
                if (0 === r.length) return;
                for (
                  r.sort(function (t, e) {
                    return t.distance - e.distance;
                  }),
                    i = r[0],
                    a = 0;
                  a < r.length;
                  a++
                )
                  r[a].dataPoint.x.valueOf() === i.dataPoint.x.valueOf() &&
                    n.push(r[a]);
                r = null;
              } else {
                if ((h = this.chart.getDataPointAtXY(t, e, i)))
                  (this.currentDataPointIndex = h.dataPointIndex),
                    (this.currentSeriesIndex = h.dataSeries.index);
                else if (Z)
                  if (
                    0 < (h = y(t, e, this.chart._eventManager.ghostCtx)) &&
                    void 0 !== this.chart._eventManager.objectMap[h]
                  ) {
                    if (
                      "legendItem" ===
                      (h = this.chart._eventManager.objectMap[h]).objectType
                    )
                      return;
                    (this.currentSeriesIndex = h.dataSeriesIndex),
                      (this.currentDataPointIndex =
                        0 <= h.dataPointIndex ? h.dataPointIndex : -1);
                  } else this.currentDataPointIndex = -1;
                else this.currentDataPointIndex = -1;
                if (0 <= this.currentSeriesIndex) {
                  if (
                    ((s = this.chart.data[this.currentSeriesIndex]),
                    (h = {}),
                    0 <= this.currentDataPointIndex)
                  )
                    (a = s.dataPoints[this.currentDataPointIndex]),
                      (h.dataSeries = s),
                      (h.dataPoint = a),
                      (h.index = this.currentDataPointIndex),
                      (h.distance = Math.abs(a.x - o)),
                      "waterfall" === s.type &&
                        ((h.cumulativeSumYStartValue =
                          s.dataPointEOs[
                            this.currentDataPointIndex
                          ].cumulativeSumYStartValue),
                        (h.cumulativeSum =
                          s.dataPointEOs[
                            this.currentDataPointIndex
                          ].cumulativeSum));
                  else {
                    if (
                      !this.enabled ||
                      ("line" !== s.type &&
                        "stepLine" !== s.type &&
                        "spline" !== s.type &&
                        "area" !== s.type &&
                        "stepArea" !== s.type &&
                        "splineArea" !== s.type &&
                        "stackedArea" !== s.type &&
                        "stackedArea100" !== s.type &&
                        "rangeArea" !== s.type &&
                        "rangeSplineArea" !== s.type &&
                        "candlestick" !== s.type &&
                        "ohlc" !== s.type &&
                        "boxAndWhisker" !== s.type)
                    )
                      return;
                    (o = s.axisX.convertPixelToValue({ x: t })),
                      ((h = s.getDataPointAtX(o, i)).dataSeries = s),
                      (this.currentDataPointIndex = h.index),
                      (a = h.dataPoint);
                  }
                  if (!U(h.dataPoint.y))
                    if (h.dataSeries.axisY)
                      if (0 < h.dataPoint.y.length) {
                        for (a = i = 0; a < h.dataPoint.y.length; a++)
                          h.dataPoint.y[a] < h.dataSeries.axisY.viewportMinimum
                            ? i--
                            : h.dataPoint.y[a] >
                                h.dataSeries.axisY.viewportMaximum && i++;
                        i < h.dataPoint.y.length &&
                          i > -h.dataPoint.y.length &&
                          n.push(h);
                      } else
                        "column" === s.type || "bar" === s.type
                          ? h.dataPoint.y < 0
                            ? h.dataSeries.axisY.viewportMinimum < 0 &&
                              h.dataSeries.axisY.viewportMaximum >=
                                h.dataPoint.y &&
                              n.push(h)
                            : h.dataSeries.axisY.viewportMinimum <=
                                h.dataPoint.y &&
                              0 <= h.dataSeries.axisY.viewportMaximum &&
                              n.push(h)
                          : "bubble" === s.type
                          ? ((i =
                              this.chart._eventManager.objectMap[
                                s.dataPointIds[h.index]
                              ].size / 2),
                            h.dataPoint.y >=
                              h.dataSeries.axisY.viewportMinimum - i &&
                              h.dataPoint.y <=
                                h.dataSeries.axisY.viewportMaximum + i &&
                              n.push(h))
                          : "waterfall" === s.type
                          ? ((i = 0),
                            h.cumulativeSumYStartValue <
                            h.dataSeries.axisY.viewportMinimum
                              ? i--
                              : h.cumulativeSumYStartValue >
                                  h.dataSeries.axisY.viewportMaximum && i++,
                            h.cumulativeSum < h.dataSeries.axisY.viewportMinimum
                              ? i--
                              : h.cumulativeSum >
                                  h.dataSeries.axisY.viewportMaximum && i++,
                            i < 2 && -2 < i && n.push(h))
                          : (0 <= h.dataSeries.type.indexOf("100") ||
                              "stackedColumn" === s.type ||
                              "stackedBar" === s.type ||
                              (h.dataPoint.y >=
                                h.dataSeries.axisY.viewportMinimum &&
                                h.dataPoint.y <=
                                  h.dataSeries.axisY.viewportMaximum)) &&
                            n.push(h);
                    else n.push(h);
                }
              }
              if (0 < n.length && (this.highlightObjects(n), this.enabled))
                if (
                  ((i = ""),
                  null !== (i = this.getToolTipInnerHTML({ entries: n })))
                ) {
                  (this.contentDiv.innerHTML = i),
                    (i = !1),
                    "none" === this.container.style.display &&
                      ((i = !0), (this.container.style.display = "block"));
                  try {
                    (this.contentDiv.style.background = this.backgroundColor
                      ? this.backgroundColor
                      : Z
                      ? "rgba(255,255,255,.9)"
                      : "rgb(255,255,255)"),
                      (this.borderColor =
                        "waterfall" === n[0].dataSeries.type
                          ? (this.contentDiv.style.borderRightColor =
                              this.contentDiv.style.borderLeftColor =
                              this.contentDiv.style.borderColor =
                                this.options.borderColor
                                  ? this.options.borderColor
                                  : n[0].dataPoint.color
                                  ? n[0].dataPoint.color
                                  : 0 < n[0].dataPoint.y
                                  ? n[0].dataSeries.risingColor
                                  : n[0].dataSeries.fallingColor)
                          : "error" === n[0].dataSeries.type
                          ? (this.contentDiv.style.borderRightColor =
                              this.contentDiv.style.borderLeftColor =
                              this.contentDiv.style.borderColor =
                                this.options.borderColor
                                  ? this.options.borderColor
                                  : n[0].dataSeries.color
                                  ? n[0].dataSeries.color
                                  : n[0].dataSeries._colorSet[
                                      s.index % n[0].dataSeries._colorSet.length
                                    ])
                          : (this.contentDiv.style.borderRightColor =
                              this.contentDiv.style.borderLeftColor =
                              this.contentDiv.style.borderColor =
                                this.options.borderColor
                                  ? this.options.borderColor
                                  : n[0].dataPoint.color
                                  ? n[0].dataPoint.color
                                  : n[0].dataSeries.color
                                  ? n[0].dataSeries.color
                                  : n[0].dataSeries._colorSet[
                                      n[0].index %
                                        n[0].dataSeries._colorSet.length
                                    ])),
                      (this.contentDiv.style.borderWidth =
                        this.borderThickness || 0 === this.borderThickness
                          ? this.borderThickness + "px"
                          : "2px"),
                      (this.contentDiv.style.borderRadius =
                        this.cornerRadius || 0 === this.cornerRadius
                          ? this.cornerRadius + "px"
                          : "5px"),
                      (this.container.style.borderRadius =
                        this.contentDiv.style.borderRadius),
                      (this.contentDiv.style.fontSize =
                        this.fontSize || 0 === this.fontSize
                          ? this.fontSize + "px"
                          : "14px"),
                      (this.contentDiv.style.color = this.fontColor
                        ? this.fontColor
                        : "#000000"),
                      (this.contentDiv.style.fontFamily = this.fontFamily
                        ? this.fontFamily
                        : "Calibri, Arial, Georgia, serif;"),
                      (this.contentDiv.style.fontWeight = this.fontWeight
                        ? this.fontWeight
                        : "normal"),
                      (this.contentDiv.style.fontStyle = this.fontStyle
                        ? this.fontStyle
                        : Z
                        ? "italic"
                        : "normal");
                  } catch (t) {}
                  "pie" === n[0].dataSeries.type ||
                  "doughnut" === n[0].dataSeries.type ||
                  "funnel" === n[0].dataSeries.type ||
                  "pyramid" === n[0].dataSeries.type ||
                  "bar" === n[0].dataSeries.type ||
                  "rangeBar" === n[0].dataSeries.type ||
                  "stackedBar" === n[0].dataSeries.type ||
                  "stackedBar100" === n[0].dataSeries.type
                    ? (t = t - 10 - this.container.clientWidth)
                    : ((t =
                        (n[0].dataSeries.axisX.convertValueToPixel(
                          n[0].dataPoint.x
                        ) -
                          this.container.clientWidth) <<
                        0),
                      (t -= 10)),
                    t < 0 && (t += this.container.clientWidth + 20),
                    t + this.container.clientWidth >
                      Math.max(
                        this.chart.container.clientWidth,
                        this.chart.width
                      ) &&
                      (t = Math.max(
                        0,
                        Math.max(
                          this.chart.container.clientWidth,
                          this.chart.width
                        ) - this.container.clientWidth
                      )),
                    0 <
                      (e =
                        10 -
                        (e =
                          1 !== n.length ||
                          this.shared ||
                          ("line" !== n[0].dataSeries.type &&
                            "stepLine" !== n[0].dataSeries.type &&
                            "spline" !== n[0].dataSeries.type &&
                            "area" !== n[0].dataSeries.type &&
                            "stepArea" !== n[0].dataSeries.type &&
                            "splineArea" !== n[0].dataSeries.type)
                            ? "bar" === n[0].dataSeries.type ||
                              "rangeBar" === n[0].dataSeries.type ||
                              "stackedBar" === n[0].dataSeries.type ||
                              "stackedBar100" === n[0].dataSeries.type
                              ? n[0].dataSeries.axisX.convertValueToPixel(
                                  n[0].dataPoint.x
                                )
                              : e
                            : n[0].dataSeries.axisY.convertValueToPixel(
                                n[0].dataPoint.y
                              ))) +
                        this.container.clientHeight +
                        5 && (e -= e + this.container.clientHeight + 5 - 0),
                    this.fixMozTransitionDelay(t, e),
                    !this.animationEnabled || i
                      ? this.disableAnimation()
                      : (this.enableAnimation(),
                        (this.container.style.MozTransition =
                          this.mozContainerTransition)),
                    (this.container.style.left = t + "px"),
                    (this.container.style.bottom = e + "px");
                } else this.hide(!1);
            }
          }),
          (n.prototype.highlightObjects = function (t) {
            var e = this.chart.overlaidCanvasCtx;
            this.chart.resetOverlayedCanvas(),
              e.clearRect(0, 0, this.chart.width, this.chart.height),
              e.save();
            var i = this.chart.plotArea,
              a = 0;
            for (
              e.beginPath(),
                e.rect(i.x1, i.y1, i.x2 - i.x1, i.y2 - i.y1),
                e.clip(),
                i = 0;
              i < t.length;
              i++
            ) {
              var s = t[i];
              if (
                (s =
                  this.chart._eventManager.objectMap[
                    s.dataSeries.dataPointIds[s.index]
                  ]) &&
                s.objectType &&
                "dataPoint" === s.objectType
              ) {
                var n = (a = this.chart.data[s.dataSeriesIndex]).dataPoints[
                    s.dataPointIndex
                  ],
                  o = s.dataPointIndex;
                !1 === n.highlightEnabled ||
                  (!0 !== a.highlightEnabled && !0 !== n.highlightEnabled) ||
                  ("line" === a.type ||
                  "stepLine" === a.type ||
                  "spline" === a.type ||
                  "scatter" === a.type ||
                  "area" === a.type ||
                  "stepArea" === a.type ||
                  "splineArea" === a.type ||
                  "stackedArea" === a.type ||
                  "stackedArea100" === a.type ||
                  "rangeArea" === a.type ||
                  "rangeSplineArea" === a.type
                    ? (((n = a.getMarkerProperties(
                        o,
                        s.x1,
                        s.y1,
                        this.chart.overlaidCanvasCtx
                      )).size = Math.max((1.5 * n.size) << 0, 10)),
                      (n.borderColor = n.borderColor || "#FFFFFF"),
                      (n.borderThickness =
                        n.borderThickness || Math.ceil(0.1 * n.size)),
                      I.drawMarkers([n]),
                      void 0 !== s.y2 &&
                        (((n = a.getMarkerProperties(
                          o,
                          s.x1,
                          s.y2,
                          this.chart.overlaidCanvasCtx
                        )).size = Math.max((1.5 * n.size) << 0, 10)),
                        (n.borderColor = n.borderColor || "#FFFFFF"),
                        (n.borderThickness =
                          n.borderThickness || Math.ceil(0.1 * n.size)),
                        I.drawMarkers([n])))
                    : "bubble" === a.type
                    ? (((n = a.getMarkerProperties(
                        o,
                        s.x1,
                        s.y1,
                        this.chart.overlaidCanvasCtx
                      )).size = s.size),
                      (n.color = "white"),
                      (n.borderColor = "white"),
                      (e.globalAlpha = 0.3),
                      I.drawMarkers([n]),
                      (e.globalAlpha = 1))
                    : "column" === a.type ||
                      "stackedColumn" === a.type ||
                      "stackedColumn100" === a.type ||
                      "bar" === a.type ||
                      "rangeBar" === a.type ||
                      "stackedBar" === a.type ||
                      "stackedBar100" === a.type ||
                      "rangeColumn" === a.type ||
                      "waterfall" === a.type
                    ? R(
                        e,
                        s.x1,
                        s.y1,
                        s.x2,
                        s.y2,
                        "white",
                        0,
                        null,
                        !1,
                        !1,
                        !1,
                        !1,
                        0.3
                      )
                    : "pie" === a.type || "doughnut" === a.type
                    ? B(
                        e,
                        s.center,
                        s.radius,
                        "white",
                        a.type,
                        s.startAngle,
                        s.endAngle,
                        0.3,
                        s.percentInnerRadius
                      )
                    : "funnel" === a.type || "pyramid" === a.type
                    ? $(e, s.funnelSection, 0.3, "white")
                    : "candlestick" === a.type
                    ? ((e.globalAlpha = 1),
                      (e.strokeStyle = s.color),
                      (e.lineWidth = 2 * s.borderThickness),
                      (a = 0 == e.lineWidth % 2 ? 0 : 0.5),
                      e.beginPath(),
                      e.moveTo(s.x3 - a, Math.min(s.y2, s.y3)),
                      e.lineTo(s.x3 - a, Math.min(s.y1, s.y4)),
                      e.stroke(),
                      e.beginPath(),
                      e.moveTo(s.x3 - a, Math.max(s.y1, s.y4)),
                      e.lineTo(s.x3 - a, Math.max(s.y2, s.y3)),
                      e.stroke(),
                      R(
                        e,
                        s.x1,
                        Math.min(s.y1, s.y4),
                        s.x2,
                        Math.max(s.y1, s.y4),
                        "transparent",
                        2 * s.borderThickness,
                        s.color,
                        !1,
                        !1,
                        !1,
                        !1
                      ),
                      (e.globalAlpha = 1))
                    : "ohlc" === a.type
                    ? ((e.globalAlpha = 1),
                      (e.strokeStyle = s.color),
                      (e.lineWidth = 2 * s.borderThickness),
                      (a = 0 == e.lineWidth % 2 ? 0 : 0.5),
                      e.beginPath(),
                      e.moveTo(s.x3 - a, s.y2),
                      e.lineTo(s.x3 - a, s.y3),
                      e.stroke(),
                      e.beginPath(),
                      e.moveTo(s.x3, s.y1),
                      e.lineTo(s.x1, s.y1),
                      e.stroke(),
                      e.beginPath(),
                      e.moveTo(s.x3, s.y4),
                      e.lineTo(s.x2, s.y4),
                      e.stroke(),
                      (e.globalAlpha = 1))
                    : "boxAndWhisker" === a.type
                    ? (e.save(),
                      (e.globalAlpha = 1),
                      (e.strokeStyle = s.stemColor),
                      (e.lineWidth = 2 * s.stemThickness),
                      0 < s.stemThickness &&
                        (e.beginPath(),
                        e.moveTo(s.x3, s.y2 + s.borderThickness / 2),
                        e.lineTo(s.x3, s.y1 + s.whiskerThickness / 2),
                        e.stroke(),
                        e.beginPath(),
                        e.moveTo(s.x3, s.y4 - s.whiskerThickness / 2),
                        e.lineTo(s.x3, s.y3 - s.borderThickness / 2),
                        e.stroke()),
                      e.beginPath(),
                      R(
                        e,
                        s.x1 - s.borderThickness / 2,
                        Math.max(
                          s.y2 + s.borderThickness / 2,
                          s.y3 + s.borderThickness / 2
                        ),
                        s.x2 + s.borderThickness / 2,
                        Math.min(
                          s.y2 - s.borderThickness / 2,
                          s.y3 - s.borderThickness / 2
                        ),
                        "transparent",
                        s.borderThickness,
                        s.color,
                        !1,
                        !1,
                        !1,
                        !1
                      ),
                      (e.globalAlpha = 1),
                      (e.strokeStyle = s.whiskerColor),
                      (e.lineWidth = 2 * s.whiskerThickness),
                      0 < s.whiskerThickness &&
                        (e.beginPath(),
                        e.moveTo(Math.floor(s.x3 - s.whiskerLength / 2), s.y4),
                        e.lineTo(Math.ceil(s.x3 + s.whiskerLength / 2), s.y4),
                        e.stroke(),
                        e.beginPath(),
                        e.moveTo(Math.floor(s.x3 - s.whiskerLength / 2), s.y1),
                        e.lineTo(Math.ceil(s.x3 + s.whiskerLength / 2), s.y1),
                        e.stroke()),
                      (e.globalAlpha = 1),
                      (e.strokeStyle = s.lineColor),
                      (e.lineWidth = 2 * s.lineThickness),
                      0 < s.lineThickness &&
                        (e.beginPath(),
                        e.moveTo(s.x1, s.y5),
                        e.lineTo(s.x2, s.y5),
                        e.stroke()),
                      e.restore(),
                      (e.globalAlpha = 1))
                    : "error" === a.type &&
                      _(
                        e,
                        s.x1,
                        s.y1,
                        s.x2,
                        s.y2,
                        "white",
                        s.whiskerProperties,
                        s.stemProperties,
                        s.isXYSwapped,
                        0.3
                      ));
              }
            }
            e.restore(), (e.globalAlpha = 1), e.beginPath();
          }),
          (n.prototype.getToolTipInnerHTML = function (t) {
            t = t.entries;
            for (
              var e = null, i = null, a = null, s = 0, n = "", o = !0, r = 0;
              r < t.length;
              r++
            )
              if (
                t[r].dataSeries.toolTipContent ||
                t[r].dataPoint.toolTipContent
              ) {
                o = !1;
                break;
              }
            if (
              o &&
              ((this.content && "function" == typeof this.content) ||
                this.contentFormatter)
            )
              (t = { chart: this.chart, toolTip: this.options, entries: t }),
                (e = this.contentFormatter
                  ? this.contentFormatter(t)
                  : this.content(t));
            else if (
              this.shared &&
              "none" !== this.chart.plotInfo.axisPlacement
            ) {
              var l = null,
                h = "";
              for (r = 0; r < t.length; r++)
                (i = t[r].dataSeries),
                  (a = t[r].dataPoint),
                  (s = t[r].index),
                  (n = ""),
                  0 === r &&
                    o &&
                    !this.content &&
                    (this.chart.axisX && 0 < this.chart.axisX.length
                      ? (h +=
                          void 0 !== this.chart.axisX[0].labels[a.x]
                            ? this.chart.axisX[0].labels[a.x]
                            : "{x}")
                      : this.chart.axisX2 &&
                        0 < this.chart.axisX2.length &&
                        (h +=
                          void 0 !== this.chart.axisX2[0].labels[a.x]
                            ? this.chart.axisX2[0].labels[a.x]
                            : "{x}"),
                    (h += "</br>"),
                    (h = this.chart.replaceKeywordsWithValue(h, a, i, s))),
                  null === a.toolTipContent ||
                    (void 0 === a.toolTipContent &&
                      null === i.options.toolTipContent) ||
                    ("line" === i.type ||
                    "stepLine" === i.type ||
                    "spline" === i.type ||
                    "area" === i.type ||
                    "stepArea" === i.type ||
                    "splineArea" === i.type ||
                    "column" === i.type ||
                    "bar" === i.type ||
                    "scatter" === i.type ||
                    "stackedColumn" === i.type ||
                    "stackedColumn100" === i.type ||
                    "stackedBar" === i.type ||
                    "stackedBar100" === i.type ||
                    "stackedArea" === i.type ||
                    "stackedArea100" === i.type ||
                    "waterfall" === i.type
                      ? (this.chart.axisX &&
                          1 < this.chart.axisX.length &&
                          (n +=
                            l != i.axisXIndex
                              ? i.axisX.title
                                ? i.axisX.title + "<br/>"
                                : "X:{axisXIndex}<br/>"
                              : ""),
                        (n += a.toolTipContent
                          ? a.toolTipContent
                          : i.toolTipContent
                          ? i.toolTipContent
                          : this.content && "function" != typeof this.content
                          ? this.content
                          : "<span style='\"" +
                            (this.options.fontColor ? "" : "'color:{color};'") +
                            "\"'>{name}:</span>&nbsp;&nbsp;{y}"),
                        (l = i.axisXIndex))
                      : "bubble" === i.type
                      ? (this.chart.axisX &&
                          1 < this.chart.axisX.length &&
                          (n +=
                            l != i.axisXIndex
                              ? i.axisX.title
                                ? i.axisX.title + "<br/>"
                                : "X:{axisXIndex}<br/>"
                              : ""),
                        (n += a.toolTipContent
                          ? a.toolTipContent
                          : i.toolTipContent
                          ? i.toolTipContent
                          : this.content && "function" != typeof this.content
                          ? this.content
                          : "<span style='\"" +
                            (this.options.fontColor ? "" : "'color:{color};'") +
                            "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}"))
                      : "rangeColumn" === i.type ||
                        "rangeBar" === i.type ||
                        "rangeArea" === i.type ||
                        "rangeSplineArea" === i.type ||
                        "error" === i.type
                      ? (this.chart.axisX &&
                          1 < this.chart.axisX.length &&
                          (n +=
                            l != i.axisXIndex
                              ? i.axisX.title
                                ? i.axisX.title + "<br/>"
                                : "X:{axisXIndex}<br/>"
                              : ""),
                        (n += a.toolTipContent
                          ? a.toolTipContent
                          : i.toolTipContent
                          ? i.toolTipContent
                          : this.content && "function" != typeof this.content
                          ? this.content
                          : "<span style='\"" +
                            (this.options.fontColor ? "" : "'color:{color};'") +
                            "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}"))
                      : "candlestick" === i.type || "ohlc" === i.type
                      ? (this.chart.axisX &&
                          1 < this.chart.axisX.length &&
                          (n +=
                            l != i.axisXIndex
                              ? i.axisX.title
                                ? i.axisX.title + "<br/>"
                                : "X:{axisXIndex}<br/>"
                              : ""),
                        (n += a.toolTipContent
                          ? a.toolTipContent
                          : i.toolTipContent
                          ? i.toolTipContent
                          : this.content && "function" != typeof this.content
                          ? this.content
                          : "<span style='\"" +
                            (this.options.fontColor ? "" : "'color:{color};'") +
                            "\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}"))
                      : "boxAndWhisker" === i.type &&
                        (this.chart.axisX &&
                          1 < this.chart.axisX.length &&
                          (n +=
                            l != i.axisXIndex
                              ? i.axisX.title
                                ? i.axisX.title + "<br/>"
                                : "X:{axisXIndex}<br/>"
                              : ""),
                        (n += a.toolTipContent
                          ? a.toolTipContent
                          : i.toolTipContent
                          ? i.toolTipContent
                          : this.content && "function" != typeof this.content
                          ? this.content
                          : "<span style='\"" +
                            (this.options.fontColor ? "" : "'color:{color};'") +
                            "\"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}")),
                    null === e && (e = ""),
                    !0 === this.reversed
                      ? ((e =
                          this.chart.replaceKeywordsWithValue(n, a, i, s) + e),
                        r < t.length - 1 && (e = "</br>" + e))
                      : ((e += this.chart.replaceKeywordsWithValue(n, a, i, s)),
                        r < t.length - 1 && (e += "</br>")));
              null !== e && (e = h + e);
            } else {
              if (
                ((i = t[0].dataSeries),
                (a = t[0].dataPoint),
                (s = t[0].index),
                null === a.toolTipContent ||
                  (void 0 === a.toolTipContent &&
                    null === i.options.toolTipContent))
              )
                return null;
              "line" === i.type ||
              "stepLine" === i.type ||
              "spline" === i.type ||
              "area" === i.type ||
              "stepArea" === i.type ||
              "splineArea" === i.type ||
              "column" === i.type ||
              "bar" === i.type ||
              "scatter" === i.type ||
              "stackedColumn" === i.type ||
              "stackedColumn100" === i.type ||
              "stackedBar" === i.type ||
              "stackedBar100" === i.type ||
              "stackedArea" === i.type ||
              "stackedArea100" === i.type ||
              "waterfall" === i.type
                ? (n = a.toolTipContent
                    ? a.toolTipContent
                    : i.toolTipContent
                    ? i.toolTipContent
                    : this.content && "function" != typeof this.content
                    ? this.content
                    : "<span style='\"" +
                      (this.options.fontColor ? "" : "'color:{color};'") +
                      "\"'>" +
                      (a.label ? "{label}" : "{x}") +
                      ":</span>&nbsp;&nbsp;{y}")
                : "bubble" === i.type
                ? (n = a.toolTipContent
                    ? a.toolTipContent
                    : i.toolTipContent
                    ? i.toolTipContent
                    : this.content && "function" != typeof this.content
                    ? this.content
                    : "<span style='\"" +
                      (this.options.fontColor ? "" : "'color:{color};'") +
                      "\"'>" +
                      (a.label ? "{label}" : "{x}") +
                      ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}")
                : "pie" === i.type ||
                  "doughnut" === i.type ||
                  "funnel" === i.type ||
                  "pyramid" === i.type
                ? (n = a.toolTipContent
                    ? a.toolTipContent
                    : i.toolTipContent
                    ? i.toolTipContent
                    : this.content && "function" != typeof this.content
                    ? this.content
                    : "<span style='\"" +
                      (this.options.fontColor ? "" : "'color:{color};'") +
                      "\"'>" +
                      (a.name
                        ? "{name}:</span>&nbsp;&nbsp;"
                        : a.label
                        ? "{label}:</span>&nbsp;&nbsp;"
                        : "</span>") +
                      "{y}")
                : "rangeColumn" === i.type ||
                  "rangeBar" === i.type ||
                  "rangeArea" === i.type ||
                  "rangeSplineArea" === i.type ||
                  "error" === i.type
                ? (n = a.toolTipContent
                    ? a.toolTipContent
                    : i.toolTipContent
                    ? i.toolTipContent
                    : this.content && "function" != typeof this.content
                    ? this.content
                    : "<span style='\"" +
                      (this.options.fontColor ? "" : "'color:{color};'") +
                      "\"'>" +
                      (a.label ? "{label}" : "{x}") +
                      " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}")
                : "candlestick" === i.type || "ohlc" === i.type
                ? (n = a.toolTipContent
                    ? a.toolTipContent
                    : i.toolTipContent
                    ? i.toolTipContent
                    : this.content && "function" != typeof this.content
                    ? this.content
                    : "<span style='\"" +
                      (this.options.fontColor ? "" : "'color:{color};'") +
                      "\"'>" +
                      (a.label ? "{label}" : "{x}") +
                      "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}")
                : "boxAndWhisker" === i.type &&
                  (n = a.toolTipContent
                    ? a.toolTipContent
                    : i.toolTipContent
                    ? i.toolTipContent
                    : this.content && "function" != typeof this.content
                    ? this.content
                    : "<span style='\"" +
                      (this.options.fontColor ? "" : "'color:{color};'") +
                      "\"'>" +
                      (a.label ? "{label}" : "{x}") +
                      "</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"),
                null === e && (e = ""),
                (e += this.chart.replaceKeywordsWithValue(n, a, i, s));
            }
            return e;
          }),
          (n.prototype.enableAnimation = function () {
            if (!this.container.style.WebkitTransition) {
              var t = this.getContainerTransition(
                this.containerTransitionDuration
              );
              (this.container.style.WebkitTransition = t),
                (this.container.style.MsTransition = t),
                (this.container.style.transition = t),
                (this.container.style.MozTransition =
                  this.mozContainerTransition);
            }
          }),
          (n.prototype.disableAnimation = function () {
            this.container.style.WebkitTransition &&
              ((this.container.style.WebkitTransition = ""),
              (this.container.style.MozTransition = ""),
              (this.container.style.MsTransition = ""),
              (this.container.style.transition = ""));
          }),
          (n.prototype.hide = function (t) {
            this.container &&
              ((this.container.style.display = "none"),
              (this.currentSeriesIndex = -1),
              (this._prevY = this._prevX = NaN),
              (void 0 === t || t) && this.chart.resetOverlayedCanvas());
          }),
          (n.prototype.show = function (t, e, i) {
            this._updateToolTip(t, e, void 0 !== i && i);
          }),
          (n.prototype.fixMozTransitionDelay = function (t, e) {
            if (20 < this.chart._eventManager.lastObjectId)
              this.mozContainerTransition = this.getContainerTransition(0);
            else {
              var i = parseFloat(this.container.style.left),
                a =
                  ((i = isNaN(i) ? 0 : i),
                  parseFloat(this.container.style.bottom));
              a = isNaN(a) ? 0 : a;
              10 < Math.sqrt(Math.pow(i - t, 2) + Math.pow(a - e, 2))
                ? (this.mozContainerTransition =
                    this.getContainerTransition(0.1))
                : (this.mozContainerTransition =
                    this.getContainerTransition(0));
            }
          }),
          (n.prototype.getContainerTransition = function (t) {
            return "left " + t + "s ease-out 0s, bottom " + t + "s ease-out 0s";
          }),
          (u.prototype.reset = function () {
            (this.lastObjectId = 0),
              (this.objectMap = []),
              (this.rectangularRegionEventSubscriptions = []),
              (this.previousDataPointEventObject = null),
              (this.eventObjects = []),
              Z &&
                (this.ghostCtx.clearRect(
                  0,
                  0,
                  this.chart.width,
                  this.chart.height
                ),
                this.ghostCtx.beginPath());
          }),
          (u.prototype.getNewObjectTrackingId = function () {
            return ++this.lastObjectId;
          }),
          (u.prototype.mouseEventHandler = function (t) {
            if ("mousemove" === t.type || "click" === t.type) {
              var e = [],
                i = st(t),
                a = null;
              if (
                (a = this.chart.getObjectAtXY(i.x, i.y, !1)) &&
                void 0 !== this.objectMap[a]
              )
                if ("dataPoint" === (a = this.objectMap[a]).objectType) {
                  var s = this.chart.data[a.dataSeriesIndex],
                    n = s.dataPoints[a.dataPointIndex],
                    o = a.dataPointIndex;
                  (a.eventParameter = {
                    x: i.x,
                    y: i.y,
                    dataPoint: n,
                    dataSeries: s.options,
                    dataPointIndex: o,
                    dataSeriesIndex: s.index,
                    chart: this.chart,
                  }),
                    (a.eventContext = {
                      context: n,
                      userContext: n,
                      mouseover: "mouseover",
                      mousemove: "mousemove",
                      mouseout: "mouseout",
                      click: "click",
                    }),
                    e.push(a),
                    ((a = this.objectMap[s.id]).eventParameter = {
                      x: i.x,
                      y: i.y,
                      dataPoint: n,
                      dataSeries: s.options,
                      dataPointIndex: o,
                      dataSeriesIndex: s.index,
                      chart: this.chart,
                    }),
                    (a.eventContext = {
                      context: s,
                      userContext: s.options,
                      mouseover: "mouseover",
                      mousemove: "mousemove",
                      mouseout: "mouseout",
                      click: "click",
                    }),
                    e.push(this.objectMap[s.id]);
                } else
                  "legendItem" === a.objectType &&
                    ((s = this.chart.data[a.dataSeriesIndex]),
                    (n =
                      null !== a.dataPointIndex
                        ? s.dataPoints[a.dataPointIndex]
                        : null),
                    (a.eventParameter = {
                      x: i.x,
                      y: i.y,
                      dataSeries: s.options,
                      dataPoint: n,
                      dataPointIndex: a.dataPointIndex,
                      dataSeriesIndex: a.dataSeriesIndex,
                      chart: this.chart,
                    }),
                    (a.eventContext = {
                      context: this.chart.legend,
                      userContext: this.chart.legend.options,
                      mouseover: "itemmouseover",
                      mousemove: "itemmousemove",
                      mouseout: "itemmouseout",
                      click: "itemclick",
                    }),
                    e.push(a));
              for (s = [], i = 0; i < this.mouseoveredObjectMaps.length; i++) {
                for (n = !0, a = 0; a < e.length; a++)
                  if (e[a].id === this.mouseoveredObjectMaps[i].id) {
                    n = !1;
                    break;
                  }
                n
                  ? this.fireEvent(this.mouseoveredObjectMaps[i], "mouseout", t)
                  : s.push(this.mouseoveredObjectMaps[i]);
              }
              for (this.mouseoveredObjectMaps = s, i = 0; i < e.length; i++) {
                for (s = !1, a = 0; a < this.mouseoveredObjectMaps.length; a++)
                  if (e[i].id === this.mouseoveredObjectMaps[a].id) {
                    s = !0;
                    break;
                  }
                s ||
                  (this.fireEvent(e[i], "mouseover", t),
                  this.mouseoveredObjectMaps.push(e[i])),
                  "click" === t.type
                    ? this.fireEvent(e[i], "click", t)
                    : "mousemove" === t.type &&
                      this.fireEvent(e[i], "mousemove", t);
              }
            }
          }),
          (u.prototype.fireEvent = function (t, e, i) {
            if (t && e) {
              var a = t.eventParameter,
                s = t.eventContext,
                n = t.eventContext.userContext;
              n && s && n[s[e]] && n[s[e]].call(n, a),
                "mouseout" !== e
                  ? n.cursor &&
                    n.cursor !== i.target.style.cursor &&
                    (i.target.style.cursor = n.cursor)
                  : ((i.target.style.cursor = this.chart._defaultCursor),
                    delete t.eventParameter,
                    delete t.eventContext),
                "click" === e &&
                  "dataPoint" === t.objectType &&
                  this.chart.pieDoughnutClickHandler &&
                  this.chart.pieDoughnutClickHandler.call(
                    this.chart.data[t.dataSeriesIndex],
                    a
                  ),
                "click" === e &&
                  "dataPoint" === t.objectType &&
                  this.chart.funnelPyramidClickHandler &&
                  this.chart.funnelPyramidClickHandler.call(
                    this.chart.data[t.dataSeriesIndex],
                    a
                  );
            }
          }),
          (m.prototype.animate = function (t, e, i, a, s) {
            var n = this;
            for (
              this.chart.isAnimating = !0,
                s = s || j.easing.linear,
                i &&
                  this.animations.push({
                    startTime: new Date().getTime() + (t || 0),
                    duration: e,
                    animationCallback: i,
                    onComplete: a,
                  }),
                t = [];
              0 < this.animations.length;

            )
              (e = this.animations.shift()),
                (i = new Date().getTime()),
                (a = 0),
                e.startTime <= i &&
                  ((a = s(
                    Math.min(i - e.startTime, e.duration),
                    0,
                    1,
                    e.duration
                  )),
                  (a = Math.min(a, 1)),
                  isNaN(a) || !isFinite(a)) &&
                  (a = 1),
                a < 1 && t.push(e),
                e.animationCallback(a),
                1 <= a && e.onComplete && e.onComplete();
            (this.animations = t),
              0 < this.animations.length
                ? (this.animationRequestId = this.chart.requestAnimFrame.call(
                    window,
                    function () {
                      n.animate.call(n);
                    }
                  ))
                : (this.chart.isAnimating = !1);
          }),
          (m.prototype.cancelAllAnimations = function () {
            (this.animations = []),
              this.animationRequestId &&
                this.chart.cancelRequestAnimFrame.call(
                  window,
                  this.animationRequestId
                ),
              (this.animationRequestId = null),
              (this.chart.isAnimating = !1);
          });
        var j = {
            yScaleAnimation: function (t, e) {
              if (0 !== t) {
                var i = e.dest,
                  a = e.source.canvas,
                  s = e.animationBase;
                i.drawImage(
                  a,
                  0,
                  0,
                  a.width,
                  a.height,
                  0,
                  s - s * t,
                  i.canvas.width / lt,
                  (t * i.canvas.height) / lt
                );
              }
            },
            xScaleAnimation: function (t, e) {
              if (0 !== t) {
                var i = e.dest,
                  a = e.source.canvas,
                  s = e.animationBase;
                i.drawImage(
                  a,
                  0,
                  0,
                  a.width,
                  a.height,
                  s - s * t,
                  0,
                  (t * i.canvas.width) / lt,
                  i.canvas.height / lt
                );
              }
            },
            xClipAnimation: function (t, e) {
              if (0 !== t) {
                var i = e.dest,
                  a = e.source.canvas;
                i.save(),
                  0 < t &&
                    i.drawImage(
                      a,
                      0,
                      0,
                      a.width * t,
                      a.height,
                      0,
                      0,
                      (a.width * t) / lt,
                      a.height / lt
                    ),
                  i.restore();
              }
            },
            fadeInAnimation: function (t, e) {
              if (0 !== t) {
                var i = e.dest,
                  a = e.source.canvas;
                i.save(),
                  (i.globalAlpha = t),
                  i.drawImage(
                    a,
                    0,
                    0,
                    a.width,
                    a.height,
                    0,
                    0,
                    i.canvas.width / lt,
                    i.canvas.height / lt
                  ),
                  i.restore();
              }
            },
            easing: {
              linear: function (t, e, i, a) {
                return (i * t) / a + e;
              },
              easeOutQuad: function (t, e, i, a) {
                return -i * (t /= a) * (t - 2) + e;
              },
              easeOutQuart: function (t, e, i, a) {
                return -i * ((t = t / a - 1) * t * t * t - 1) + e;
              },
              easeInQuad: function (t, e, i, a) {
                return i * (t /= a) * t + e;
              },
              easeInQuart: function (t, e, i, a) {
                return i * (t /= a) * t * t * t + e;
              },
            },
          },
          I = {
            drawMarker: function (t, e, i, a, s, n, o, r) {
              if (i) {
                var l = 1;
                (i.fillStyle = n || "#000000"),
                  (i.strokeStyle = o || "#000000"),
                  (i.lineWidth = r || 0),
                  i.setLineDash && i.setLineDash(K("solid", r)),
                  "circle" === a
                    ? (i.moveTo(t, e),
                      i.beginPath(),
                      i.arc(t, e, s / 2, 0, 2 * Math.PI, !1),
                      n && i.fill(),
                      r &&
                        (o
                          ? i.stroke()
                          : ((l = i.globalAlpha),
                            (i.globalAlpha = 0.15),
                            (i.strokeStyle = "black"),
                            i.stroke(),
                            (i.globalAlpha = l))))
                    : "square" === a
                    ? (i.beginPath(),
                      i.rect(t - s / 2, e - s / 2, s, s),
                      n && i.fill(),
                      r &&
                        (o
                          ? i.stroke()
                          : ((l = i.globalAlpha),
                            (i.globalAlpha = 0.15),
                            (i.strokeStyle = "black"),
                            i.stroke(),
                            (i.globalAlpha = l))))
                    : "triangle" === a
                    ? (i.beginPath(),
                      i.moveTo(t - s / 2, e + s / 2),
                      i.lineTo(t + s / 2, e + s / 2),
                      i.lineTo(t, e - s / 2),
                      i.closePath(),
                      n && i.fill(),
                      r &&
                        (o
                          ? i.stroke()
                          : ((l = i.globalAlpha),
                            (i.globalAlpha = 0.15),
                            (i.strokeStyle = "black"),
                            i.stroke(),
                            (i.globalAlpha = l))),
                      i.beginPath())
                    : "cross" === a &&
                      ((i.strokeStyle = n),
                      (i.lineWidth = s / 4),
                      i.beginPath(),
                      i.moveTo(t - s / 2, e - s / 2),
                      i.lineTo(t + s / 2, e + s / 2),
                      i.stroke(),
                      i.moveTo(t + s / 2, e - s / 2),
                      i.lineTo(t - s / 2, e + s / 2),
                      i.stroke());
              }
            },
            drawMarkers: function (t) {
              for (var e = 0; e < t.length; e++) {
                var i = t[e];
                I.drawMarker(
                  i.x,
                  i.y,
                  i.ctx,
                  i.type,
                  i.size,
                  i.color,
                  i.borderColor,
                  i.borderThickness
                );
              }
            },
          };
        return r;
      })()),
      (ut.Chart.version = "v2.2 GA");
  })(),
  document.createElement("canvas").getContext ||
    (function () {
      function i() {
        return this.context_ || (this.context_ = new t(this));
      }
      function u(t) {
        return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
      }
      function a(t) {
        t.namespaces.g_vml_ ||
          t.namespaces.add(
            "g_vml_",
            "urn:schemas-microsoft-com:vml",
            "#default#VML"
          ),
          t.namespaces.g_o_ ||
            t.namespaces.add(
              "g_o_",
              "urn:schemas-microsoft-com:office:office",
              "#default#VML"
            ),
          t.styleSheets.ex_canvas_ ||
            (((t = t.createStyleSheet()).owningElement.id = "ex_canvas_"),
            (t.cssText =
              "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}"));
      }
      function s(t) {
        var e = t.srcElement;
        switch (t.propertyName) {
          case "width":
            e.getContext().clearRect(),
              (e.style.width = e.attributes.width.nodeValue + "px"),
              (e.firstChild.style.width = e.clientWidth + "px");
            break;
          case "height":
            e.getContext().clearRect(),
              (e.style.height = e.attributes.height.nodeValue + "px"),
              (e.firstChild.style.height = e.clientHeight + "px");
        }
      }
      function n(t) {
        (t = t.srcElement).firstChild &&
          ((t.firstChild.style.width = t.clientWidth + "px"),
          (t.firstChild.style.height = t.clientHeight + "px"));
      }
      function o(t, e) {
        for (
          var i = [
              [1, 0, 0],
              [0, 1, 0],
              [0, 0, 1],
            ],
            a = 0;
          a < 3;
          a++
        )
          for (var s = 0; s < 3; s++) {
            for (var n = 0, o = 0; o < 3; o++) n += t[a][o] * e[o][s];
            i[a][s] = n;
          }
        return i;
      }
      function e(t, e) {
        (e.fillStyle = t.fillStyle),
          (e.lineCap = t.lineCap),
          (e.lineJoin = t.lineJoin),
          (e.lineWidth = t.lineWidth),
          (e.miterLimit = t.miterLimit),
          (e.shadowBlur = t.shadowBlur),
          (e.shadowColor = t.shadowColor),
          (e.shadowOffsetX = t.shadowOffsetX),
          (e.shadowOffsetY = t.shadowOffsetY),
          (e.strokeStyle = t.strokeStyle),
          (e.globalAlpha = t.globalAlpha),
          (e.font = t.font),
          (e.textAlign = t.textAlign),
          (e.textBaseline = t.textBaseline),
          (e.arcScaleX_ = t.arcScaleX_),
          (e.arcScaleY_ = t.arcScaleY_),
          (e.lineScale_ = t.lineScale_);
      }
      function r(t) {
        var e = t.indexOf("(", 3),
          i = t.indexOf(")", e + 1);
        return (
          (4 == (e = t.substring(e + 1, i).split(",")).length &&
            "a" == t.charAt(3)) ||
            (e[3] = 1),
          e
        );
      }
      function l(t, e, i) {
        return Math.min(i, Math.max(e, t));
      }
      function h(t, e, i) {
        return (
          i < 0 && i++,
          1 < i && i--,
          6 * i < 1
            ? t + 6 * (e - t) * i
            : 2 * i < 1
            ? e
            : 3 * i < 2
            ? t + 6 * (e - t) * (2 / 3 - i)
            : t
        );
      }
      function g(t) {
        if (t in E) return E[t];
        var e,
          i = 1;
        if ("#" == (t = String(t)).charAt(0)) e = t;
        else if (/^rgb/.test(t)) {
          (i = r(t)), (e = "#");
          for (var a, s = 0; s < 3; s++)
            (a =
              -1 != i[s].indexOf("%")
                ? Math.floor((parseFloat(i[s]) / 100) * 255)
                : +i[s]),
              (e += B[l(a, 0, 255)]);
          i = +i[3];
        } else if (/^hsl/.test(t)) {
          if (
            ((s = i = r(t)),
            (e = (parseFloat(s[0]) / 360) % 360) < 0 && e++,
            (a = l(parseFloat(s[1]) / 100, 0, 1)),
            (s = l(parseFloat(s[2]) / 100, 0, 1)),
            0 == a)
          )
            a = s = e = s;
          else {
            var n = s < 0.5 ? s * (1 + a) : s + a - s * a,
              o = 2 * s - n;
            (a = h(o, n, e + 1 / 3)),
              (s = h(o, n, e)),
              (e = h(o, n, e - 1 / 3));
          }
          (e =
            "#" +
            B[Math.floor(255 * a)] +
            B[Math.floor(255 * s)] +
            B[Math.floor(255 * e)]),
            (i = i[3]);
        } else e = I[t] || t;
        return (E[t] = { color: e, alpha: i });
      }
      function t(t) {
        (this.m_ = [
          [1, 0, 0],
          [0, 1, 0],
          [0, 0, 1],
        ]),
          (this.mStack_ = []),
          (this.aStack_ = []),
          (this.currentPath_ = []),
          (this.fillStyle = this.strokeStyle = "#000"),
          (this.lineWidth = 1),
          (this.lineJoin = "miter"),
          (this.lineCap = "butt"),
          (this.miterLimit = 1 * P),
          (this.globalAlpha = 1),
          (this.font = "10px sans-serif"),
          (this.textAlign = "left"),
          (this.textBaseline = "alphabetic");
        var e =
            "width:" +
            (this.canvas = t).clientWidth +
            "px;height:" +
            t.clientHeight +
            "px;overflow:hidden;position:absolute",
          i = t.ownerDocument.createElement("div");
        (i.style.cssText = e),
          t.appendChild(i),
          ((e = i.cloneNode(!1)).style.backgroundColor = "red"),
          (e.style.filter = "alpha(opacity=0)"),
          t.appendChild(e),
          (this.element_ = i),
          (this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1);
      }
      function d(t, e, i, a) {
        t.currentPath_.push({
          type: "bezierCurveTo",
          cp1x: e.x,
          cp1y: e.y,
          cp2x: i.x,
          cp2y: i.y,
          x: a.x,
          y: a.y,
        }),
          (t.currentX_ = a.x),
          (t.currentY_ = a.y);
      }
      function x(t, e) {
        var i = (a = g(t.strokeStyle)).color,
          a = a.alpha * t.globalAlpha,
          s = t.lineScale_ * t.lineWidth;
        s < 1 && (a *= s),
          e.push(
            "<g_vml_:stroke",
            ' opacity="',
            a,
            '"',
            ' joinstyle="',
            t.lineJoin,
            '"',
            ' miterlimit="',
            t.miterLimit,
            '"',
            ' endcap="',
            V[t.lineCap] || "square",
            '"',
            ' weight="',
            s,
            'px"',
            ' color="',
            i,
            '" />'
          );
      }
      function m(t, e, i, a) {
        var s = t.fillStyle,
          n = t.arcScaleX_,
          o = t.arcScaleY_,
          r = a.x - i.x,
          l = a.y - i.y;
        if (s instanceof v) {
          var h = 0,
            d = (a = 0),
            c = 0,
            p = 1;
          if ("gradient" == s.type_) {
            (h = s.x1_ / n), (i = s.y1_ / o);
            var u = b(t, s.x0_ / n, s.y0_ / o);
            h = b(t, h, i);
            (h = (180 * Math.atan2(h.x - u.x, h.y - u.y)) / Math.PI) < 0 &&
              (h += 360),
              h < 1e-6 && (h = 0);
          } else
            (a = ((u = b(t, s.x0_, s.y0_)).x - i.x) / r),
              (d = (u.y - i.y) / l),
              (r /= n * P),
              (l /= o * P),
              (p = y.max(r, l)),
              (c = (2 * s.r0_) / p),
              (p = (2 * s.r1_) / p - c);
          (n = s.colors_).sort(function (t, e) {
            return t.offset - e.offset;
          }),
            (o = n.length),
            (u = n[0].color),
            (i = n[o - 1].color),
            (r = n[0].alpha * t.globalAlpha),
            (t = n[o - 1].alpha * t.globalAlpha);
          l = [];
          for (var x = 0; x < o; x++) {
            var m = n[x];
            l.push(m.offset * p + c + " " + m.color);
          }
          e.push(
            '<g_vml_:fill type="',
            s.type_,
            '"',
            ' method="none" focus="100%"',
            ' color="',
            u,
            '"',
            ' color2="',
            i,
            '"',
            ' colors="',
            l.join(","),
            '"',
            ' opacity="',
            t,
            '"',
            ' g_o_:opacity2="',
            r,
            '"',
            ' angle="',
            h,
            '"',
            ' focusposition="',
            a,
            ",",
            d,
            '" />'
          );
        } else
          s instanceof f
            ? r &&
              l &&
              e.push(
                "<g_vml_:fill",
                ' position="',
                (-i.x / r) * n * n,
                ",",
                (-i.y / l) * o * o,
                '"',
                ' type="tile"',
                ' src="',
                s.src_,
                '" />'
              )
            : ((s = g(t.fillStyle)),
              e.push(
                '<g_vml_:fill color="',
                s.color,
                '" opacity="',
                s.alpha * t.globalAlpha,
                '" />'
              ));
      }
      function b(t, e, i) {
        return (
          (t = t.m_),
          {
            x: P * (e * t[0][0] + i * t[1][0] + t[2][0]) - S,
            y: P * (e * t[0][1] + i * t[1][1] + t[2][1]) - S,
          }
        );
      }
      function c(t, e, i) {
        isFinite(e[0][0]) &&
          isFinite(e[0][1]) &&
          isFinite(e[1][0]) &&
          isFinite(e[1][1]) &&
          isFinite(e[2][0]) &&
          isFinite(e[2][1]) &&
          ((t.m_ = e),
          i && (t.lineScale_ = C(T(e[0][0] * e[1][1] - e[0][1] * e[1][0]))));
      }
      function v(t) {
        (this.type_ = t),
          (this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0),
          (this.colors_ = []);
      }
      function f(t, e) {
        if (!t || 1 != t.nodeType || "IMG" != t.tagName)
          throw new p("TYPE_MISMATCH_ERR");
        if ("complete" != t.readyState) throw new p("INVALID_STATE_ERR");
        switch (e) {
          case "repeat":
          case null:
          case "":
            this.repetition_ = "repeat";
            break;
          case "repeat-x":
          case "repeat-y":
          case "no-repeat":
            this.repetition_ = e;
            break;
          default:
            throw new p("SYNTAX_ERR");
        }
        (this.src_ = t.src), (this.width_ = t.width), (this.height_ = t.height);
      }
      function p(t) {
        (this.code = this[t]),
          (this.message = t + ": DOM Exception " + this.code);
      }
      var y = Math,
        M = y.round,
        k = y.sin,
        w = y.cos,
        T = y.abs,
        C = y.sqrt,
        P = 10,
        S = P / 2;
      navigator.userAgent.match(/MSIE ([\d.]+)?/);
      var A = Array.prototype.slice;
      a(document);
      var _ = {
        init: function (t) {
          (t = t || document).createElement("canvas"),
            t.attachEvent(
              "onreadystatechange",
              (function (t, e, i) {
                var a = A.call(arguments, 2);
                return function () {
                  return t.apply(e, a.concat(A.call(arguments)));
                };
              })(this.init_, this, t)
            );
        },
        init_: function (t) {
          t = t.getElementsByTagName("canvas");
          for (var e = 0; e < t.length; e++) this.initElement(t[e]);
        },
        initElement: function (t) {
          if (!t.getContext) {
            (t.getContext = i),
              a(t.ownerDocument),
              (t.innerHTML = ""),
              t.attachEvent("onpropertychange", s),
              t.attachEvent("onresize", n);
            var e = t.attributes;
            e.width && e.width.specified
              ? (t.style.width = e.width.nodeValue + "px")
              : (t.width = t.clientWidth),
              e.height && e.height.specified
                ? (t.style.height = e.height.nodeValue + "px")
                : (t.height = t.clientHeight);
          }
          return t;
        },
      };
      _.init();
      for (var B = [], F = 0; F < 16; F++)
        for (var L = 0; L < 16; L++)
          B[16 * F + L] = F.toString(16) + L.toString(16);
      var I = {
          aliceblue: "#F0F8FF",
          antiquewhite: "#FAEBD7",
          aquamarine: "#7FFFD4",
          azure: "#F0FFFF",
          beige: "#F5F5DC",
          bisque: "#FFE4C4",
          black: "#000000",
          blanchedalmond: "#FFEBCD",
          blueviolet: "#8A2BE2",
          brown: "#A52A2A",
          burlywood: "#DEB887",
          cadetblue: "#5F9EA0",
          chartreuse: "#7FFF00",
          chocolate: "#D2691E",
          coral: "#FF7F50",
          cornflowerblue: "#6495ED",
          cornsilk: "#FFF8DC",
          crimson: "#DC143C",
          cyan: "#00FFFF",
          darkblue: "#00008B",
          darkcyan: "#008B8B",
          darkgoldenrod: "#B8860B",
          darkgray: "#A9A9A9",
          darkgreen: "#006400",
          darkgrey: "#A9A9A9",
          darkkhaki: "#BDB76B",
          darkmagenta: "#8B008B",
          darkolivegreen: "#556B2F",
          darkorange: "#FF8C00",
          darkorchid: "#9932CC",
          darkred: "#8B0000",
          darksalmon: "#E9967A",
          darkseagreen: "#8FBC8F",
          darkslateblue: "#483D8B",
          darkslategray: "#2F4F4F",
          darkslategrey: "#2F4F4F",
          darkturquoise: "#00CED1",
          darkviolet: "#9400D3",
          deeppink: "#FF1493",
          deepskyblue: "#00BFFF",
          dimgray: "#696969",
          dimgrey: "#696969",
          dodgerblue: "#1E90FF",
          firebrick: "#B22222",
          floralwhite: "#FFFAF0",
          forestgreen: "#228B22",
          gainsboro: "#DCDCDC",
          ghostwhite: "#F8F8FF",
          gold: "#FFD700",
          goldenrod: "#DAA520",
          grey: "#808080",
          greenyellow: "#ADFF2F",
          honeydew: "#F0FFF0",
          hotpink: "#FF69B4",
          indianred: "#CD5C5C",
          indigo: "#4B0082",
          ivory: "#FFFFF0",
          khaki: "#F0E68C",
          lavender: "#E6E6FA",
          lavenderblush: "#FFF0F5",
          lawngreen: "#7CFC00",
          lemonchiffon: "#FFFACD",
          lightblue: "#ADD8E6",
          lightcoral: "#F08080",
          lightcyan: "#E0FFFF",
          lightgoldenrodyellow: "#FAFAD2",
          lightgreen: "#90EE90",
          lightgrey: "#D3D3D3",
          lightpink: "#FFB6C1",
          lightsalmon: "#FFA07A",
          lightseagreen: "#20B2AA",
          lightskyblue: "#87CEFA",
          lightslategray: "#778899",
          lightslategrey: "#778899",
          lightsteelblue: "#B0C4DE",
          lightyellow: "#FFFFE0",
          limegreen: "#32CD32",
          linen: "#FAF0E6",
          magenta: "#FF00FF",
          mediumaquamarine: "#66CDAA",
          mediumblue: "#0000CD",
          mediumorchid: "#BA55D3",
          mediumpurple: "#9370DB",
          mediumseagreen: "#3CB371",
          mediumslateblue: "#7B68EE",
          mediumspringgreen: "#00FA9A",
          mediumturquoise: "#48D1CC",
          mediumvioletred: "#C71585",
          midnightblue: "#191970",
          mintcream: "#F5FFFA",
          mistyrose: "#FFE4E1",
          moccasin: "#FFE4B5",
          navajowhite: "#FFDEAD",
          oldlace: "#FDF5E6",
          olivedrab: "#6B8E23",
          orange: "#FFA500",
          orangered: "#FF4500",
          orchid: "#DA70D6",
          palegoldenrod: "#EEE8AA",
          palegreen: "#98FB98",
          paleturquoise: "#AFEEEE",
          palevioletred: "#DB7093",
          papayawhip: "#FFEFD5",
          peachpuff: "#FFDAB9",
          peru: "#CD853F",
          pink: "#FFC0CB",
          plum: "#DDA0DD",
          powderblue: "#B0E0E6",
          rosybrown: "#BC8F8F",
          royalblue: "#4169E1",
          saddlebrown: "#8B4513",
          salmon: "#FA8072",
          sandybrown: "#F4A460",
          seagreen: "#2E8B57",
          seashell: "#FFF5EE",
          sienna: "#A0522D",
          skyblue: "#87CEEB",
          slateblue: "#6A5ACD",
          slategray: "#708090",
          slategrey: "#708090",
          snow: "#FFFAFA",
          springgreen: "#00FF7F",
          steelblue: "#4682B4",
          tan: "#D2B48C",
          thistle: "#D8BFD8",
          tomato: "#FF6347",
          turquoise: "#40E0D0",
          violet: "#EE82EE",
          wheat: "#F5DEB3",
          whitesmoke: "#F5F5F5",
          yellowgreen: "#9ACD32",
        },
        E = {},
        D = {},
        V = { butt: "flat", round: "round" };
      ((F = t.prototype).clearRect = function () {
        this.textMeasureEl_ &&
          (this.textMeasureEl_.removeNode(!0), (this.textMeasureEl_ = null)),
          (this.element_.innerHTML = "");
      }),
        (F.beginPath = function () {
          this.currentPath_ = [];
        }),
        (F.moveTo = function (t, e) {
          var i = b(this, t, e);
          this.currentPath_.push({ type: "moveTo", x: i.x, y: i.y }),
            (this.currentX_ = i.x),
            (this.currentY_ = i.y);
        }),
        (F.lineTo = function (t, e) {
          var i = b(this, t, e);
          this.currentPath_.push({ type: "lineTo", x: i.x, y: i.y }),
            (this.currentX_ = i.x),
            (this.currentY_ = i.y);
        }),
        (F.bezierCurveTo = function (t, e, i, a, s, n) {
          (s = b(this, s, n)),
            d(this, (t = b(this, t, e)), (i = b(this, i, a)), s);
        }),
        (F.quadraticCurveTo = function (t, e, i, a) {
          (t = b(this, t, e)),
            (i = b(this, i, a)),
            d(
              this,
              (a = {
                x: this.currentX_ + (2 / 3) * (t.x - this.currentX_),
                y: this.currentY_ + (2 / 3) * (t.y - this.currentY_),
              }),
              {
                x: a.x + (i.x - this.currentX_) / 3,
                y: a.y + (i.y - this.currentY_) / 3,
              },
              i
            );
        }),
        (F.arc = function (t, e, i, a, s, n) {
          i *= P;
          var o = n ? "at" : "wa",
            r = t + w(a) * i - S,
            l = e + k(a) * i - S;
          (a = t + w(s) * i - S),
            (s = e + k(s) * i - S),
            r != a || n || (r += 0.125),
            (t = b(this, t, e)),
            (r = b(this, r, l)),
            (a = b(this, a, s)),
            this.currentPath_.push({
              type: o,
              x: t.x,
              y: t.y,
              radius: i,
              xStart: r.x,
              yStart: r.y,
              xEnd: a.x,
              yEnd: a.y,
            });
        }),
        (F.rect = function (t, e, i, a) {
          this.moveTo(t, e),
            this.lineTo(t + i, e),
            this.lineTo(t + i, e + a),
            this.lineTo(t, e + a),
            this.closePath();
        }),
        (F.strokeRect = function (t, e, i, a) {
          var s = this.currentPath_;
          this.beginPath(),
            this.moveTo(t, e),
            this.lineTo(t + i, e),
            this.lineTo(t + i, e + a),
            this.lineTo(t, e + a),
            this.closePath(),
            this.stroke(),
            (this.currentPath_ = s);
        }),
        (F.fillRect = function (t, e, i, a) {
          var s = this.currentPath_;
          this.beginPath(),
            this.moveTo(t, e),
            this.lineTo(t + i, e),
            this.lineTo(t + i, e + a),
            this.lineTo(t, e + a),
            this.closePath(),
            this.fill(),
            (this.currentPath_ = s);
        }),
        (F.createLinearGradient = function (t, e, i, a) {
          var s = new v("gradient");
          return (s.x0_ = t), (s.y0_ = e), (s.x1_ = i), (s.y1_ = a), s;
        }),
        (F.createRadialGradient = function (t, e, i, a, s, n) {
          var o = new v("gradientradial");
          return (
            (o.x0_ = t),
            (o.y0_ = e),
            (o.r0_ = i),
            (o.x1_ = a),
            (o.y1_ = s),
            (o.r1_ = n),
            o
          );
        }),
        (F.drawImage = function (t, e) {
          var i, a, s, n, o, r, l, h;
          (s = t.runtimeStyle.width),
            (n = t.runtimeStyle.height),
            (t.runtimeStyle.width = "auto"),
            (t.runtimeStyle.height = "auto");
          var d = t.width,
            c = t.height;
          if (
            ((t.runtimeStyle.width = s),
            (t.runtimeStyle.height = n),
            3 == arguments.length)
          )
            (i = e), (a = arguments[2]), (o = r = 0), (l = s = d), (h = n = c);
          else if (5 == arguments.length)
            (i = e),
              (a = arguments[2]),
              (s = arguments[3]),
              (n = arguments[4]),
              (o = r = 0),
              (l = d),
              (h = c);
          else {
            if (9 != arguments.length)
              throw Error("Invalid number of arguments");
            (o = e),
              (r = arguments[2]),
              (l = arguments[3]),
              (h = arguments[4]),
              (i = arguments[5]),
              (a = arguments[6]),
              (s = arguments[7]),
              (n = arguments[8]);
          }
          var p = b(this, i, a),
            u = [];
          if (
            (u.push(
              " <g_vml_:group",
              ' coordsize="',
              10 * P,
              ",",
              10 * P,
              '"',
              ' coordorigin="0,0"',
              ' style="width:',
              10,
              "px;height:",
              10,
              "px;position:absolute;"
            ),
            1 != this.m_[0][0] ||
              this.m_[0][1] ||
              1 != this.m_[1][1] ||
              this.m_[1][0])
          ) {
            var x = [];
            x.push(
              "M11=",
              this.m_[0][0],
              ",",
              "M12=",
              this.m_[1][0],
              ",",
              "M21=",
              this.m_[0][1],
              ",",
              "M22=",
              this.m_[1][1],
              ",",
              "Dx=",
              M(p.x / P),
              ",",
              "Dy=",
              M(p.y / P),
              ""
            );
            var m = b(this, i + s, a),
              g = b(this, i, a + n);
            (i = b(this, i + s, a + n)),
              (p.x = y.max(p.x, m.x, g.x, i.x)),
              (p.y = y.max(p.y, m.y, g.y, i.y)),
              u.push(
                "padding:0 ",
                M(p.x / P),
                "px ",
                M(p.y / P),
                "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(",
                x.join(""),
                ", sizingmethod='clip');"
              );
          } else u.push("top:", M(p.y / P), "px;left:", M(p.x / P), "px;");
          u.push(
            ' ">',
            '<g_vml_:image src="',
            t.src,
            '"',
            ' style="width:',
            P * s,
            "px;",
            " height:",
            P * n,
            'px"',
            ' cropleft="',
            o / d,
            '"',
            ' croptop="',
            r / c,
            '"',
            ' cropright="',
            (d - o - l) / d,
            '"',
            ' cropbottom="',
            (c - r - h) / c,
            '"',
            " />",
            "</g_vml_:group>"
          ),
            this.element_.insertAdjacentHTML("BeforeEnd", u.join(""));
        }),
        (F.stroke = function (t) {
          var e = [];
          e.push(
            "<g_vml_:shape",
            ' filled="',
            !!t,
            '"',
            ' style="position:absolute;width:',
            10,
            "px;height:",
            10,
            'px;"',
            ' coordorigin="0,0"',
            ' coordsize="',
            10 * P,
            ",",
            10 * P,
            '"',
            ' stroked="',
            !t,
            '"',
            ' path="'
          );
          for (
            var i = { x: null, y: null }, a = { x: null, y: null }, s = 0;
            s < this.currentPath_.length;
            s++
          ) {
            var n = this.currentPath_[s];
            switch (n.type) {
              case "moveTo":
                e.push(" m ", M(n.x), ",", M(n.y));
                break;
              case "lineTo":
                e.push(" l ", M(n.x), ",", M(n.y));
                break;
              case "close":
                e.push(" x "), (n = null);
                break;
              case "bezierCurveTo":
                e.push(
                  " c ",
                  M(n.cp1x),
                  ",",
                  M(n.cp1y),
                  ",",
                  M(n.cp2x),
                  ",",
                  M(n.cp2y),
                  ",",
                  M(n.x),
                  ",",
                  M(n.y)
                );
                break;
              case "at":
              case "wa":
                e.push(
                  " ",
                  n.type,
                  " ",
                  M(n.x - this.arcScaleX_ * n.radius),
                  ",",
                  M(n.y - this.arcScaleY_ * n.radius),
                  " ",
                  M(n.x + this.arcScaleX_ * n.radius),
                  ",",
                  M(n.y + this.arcScaleY_ * n.radius),
                  " ",
                  M(n.xStart),
                  ",",
                  M(n.yStart),
                  " ",
                  M(n.xEnd),
                  ",",
                  M(n.yEnd)
                );
            }
            n &&
              ((null == i.x || n.x < i.x) && (i.x = n.x),
              (null == a.x || n.x > a.x) && (a.x = n.x),
              (null == i.y || n.y < i.y) && (i.y = n.y),
              (null == a.y || n.y > a.y) && (a.y = n.y));
          }
          e.push(' ">'),
            t ? m(this, e, i, a) : x(this, e),
            e.push("</g_vml_:shape>"),
            this.element_.insertAdjacentHTML("beforeEnd", e.join(""));
        }),
        (F.fill = function () {
          this.stroke(!0);
        }),
        (F.closePath = function () {
          this.currentPath_.push({ type: "close" });
        }),
        (F.save = function () {
          var t = {};
          e(this, t),
            this.aStack_.push(t),
            this.mStack_.push(this.m_),
            (this.m_ = o(
              [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1],
              ],
              this.m_
            ));
        }),
        (F.restore = function () {
          this.aStack_.length &&
            (e(this.aStack_.pop(), this), (this.m_ = this.mStack_.pop()));
        }),
        (F.translate = function (t, e) {
          c(
            this,
            o(
              [
                [1, 0, 0],
                [0, 1, 0],
                [t, e, 1],
              ],
              this.m_
            ),
            !1
          );
        }),
        (F.rotate = function (t) {
          var e = w(t);
          c(
            this,
            o(
              [
                [e, (t = k(t)), 0],
                [-t, e, 0],
                [0, 0, 1],
              ],
              this.m_
            ),
            !1
          );
        }),
        (F.scale = function (t, e) {
          (this.arcScaleX_ *= t),
            (this.arcScaleY_ *= e),
            c(
              this,
              o(
                [
                  [t, 0, 0],
                  [0, e, 0],
                  [0, 0, 1],
                ],
                this.m_
              ),
              !0
            );
        }),
        (F.transform = function (t, e, i, a, s, n) {
          c(
            this,
            o(
              [
                [t, e, 0],
                [i, a, 0],
                [s, n, 1],
              ],
              this.m_
            ),
            !0
          );
        }),
        (F.setTransform = function (t, e, i, a, s, n) {
          c(
            this,
            [
              [t, e, 0],
              [i, a, 0],
              [s, n, 1],
            ],
            !0
          );
        }),
        (F.drawText_ = function (t, e, i, a, s) {
          var n,
            o = this.m_,
            r = 1e3,
            l = (a = 0),
            h = [];
          if (((n = this.font), D[n])) n = D[n];
          else {
            var d = document.createElement("div").style;
            try {
              d.font = n;
            } catch (t) {}
            n = D[n] = {
              style: d.fontStyle || "normal",
              variant: d.fontVariant || "normal",
              weight: d.fontWeight || "normal",
              size: d.fontSize || 10,
              family: d.fontFamily || "sans-serif",
            };
          }
          d = n;
          var c = this.element_;
          for (var p in ((n = {}), d)) n[p] = d[p];
          switch (
            ((p = parseFloat(c.currentStyle.fontSize)),
            (c = parseFloat(d.size)),
            "number" == typeof d.size
              ? (n.size = d.size)
              : -1 != d.size.indexOf("px")
              ? (n.size = c)
              : -1 != d.size.indexOf("em")
              ? (n.size = p * c)
              : -1 != d.size.indexOf("%")
              ? (n.size = (p / 100) * c)
              : -1 != d.size.indexOf("pt")
              ? (n.size = c / 0.75)
              : (n.size = p),
            (n.size *= 0.981),
            (p =
              n.style +
              " " +
              n.variant +
              " " +
              n.weight +
              " " +
              n.size +
              "px " +
              n.family),
            (c = this.element_.currentStyle),
            (d = this.textAlign.toLowerCase()))
          ) {
            case "left":
            case "center":
            case "right":
              break;
            case "end":
              d = "ltr" == c.direction ? "right" : "left";
              break;
            case "start":
              d = "rtl" == c.direction ? "right" : "left";
              break;
            default:
              d = "left";
          }
          switch (this.textBaseline) {
            case "hanging":
            case "top":
              l = n.size / 1.75;
              break;
            case "middle":
              break;
            default:
            case null:
            case "alphabetic":
            case "ideographic":
            case "bottom":
              l = -n.size / 2.25;
          }
          switch (d) {
            case "right":
              (a = 1e3), (r = 0.05);
              break;
            case "center":
              a = r = 500;
          }
          (e = b(this, e + 0, i + l)),
            h.push(
              '<g_vml_:line from="',
              -a,
              ' 0" to="',
              r,
              ' 0.05" ',
              ' coordsize="100 100" coordorigin="0 0"',
              ' filled="',
              !s,
              '" stroked="',
              !!s,
              '" style="position:absolute;width:1px;height:1px;">'
            ),
            s ? x(this, h) : m(this, h, { x: -a, y: 0 }, { x: r, y: n.size }),
            (s =
              o[0][0].toFixed(3) +
              "," +
              o[1][0].toFixed(3) +
              "," +
              o[0][1].toFixed(3) +
              "," +
              o[1][1].toFixed(3) +
              ",0,0"),
            (e = M(e.x / P) + "," + M(e.y / P)),
            h.push(
              '<g_vml_:skew on="t" matrix="',
              s,
              '" ',
              ' offset="',
              e,
              '" origin="',
              a,
              ' 0" />',
              '<g_vml_:path textpathok="true" />',
              '<g_vml_:textpath on="true" string="',
              u(t),
              '" style="v-text-align:',
              d,
              ";font:",
              u(p),
              '" /></g_vml_:line>'
            ),
            this.element_.insertAdjacentHTML("beforeEnd", h.join(""));
        }),
        (F.fillText = function (t, e, i, a) {
          this.drawText_(t, e, i, a, !1);
        }),
        (F.strokeText = function (t, e, i, a) {
          this.drawText_(t, e, i, a, !0);
        }),
        (F.measureText = function (t) {
          this.textMeasureEl_ ||
            (this.element_.insertAdjacentHTML(
              "beforeEnd",
              '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'
            ),
            (this.textMeasureEl_ = this.element_.lastChild));
          var e = this.element_.ownerDocument;
          return (
            (this.textMeasureEl_.innerHTML = ""),
            (this.textMeasureEl_.style.font = this.font),
            this.textMeasureEl_.appendChild(e.createTextNode(t)),
            { width: this.textMeasureEl_.offsetWidth }
          );
        }),
        (F.clip = function () {}),
        (F.arcTo = function () {}),
        (F.createPattern = function (t, e) {
          return new f(t, e);
        }),
        (v.prototype.addColorStop = function (t, e) {
          (e = g(e)),
            this.colors_.push({ offset: t, color: e.color, alpha: e.alpha });
        }),
        ((F = p.prototype = Error()).INDEX_SIZE_ERR = 1),
        (F.DOMSTRING_SIZE_ERR = 2),
        (F.HIERARCHY_REQUEST_ERR = 3),
        (F.WRONG_DOCUMENT_ERR = 4),
        (F.INVALID_CHARACTER_ERR = 5),
        (F.NO_DATA_ALLOWED_ERR = 6),
        (F.NO_MODIFICATION_ALLOWED_ERR = 7),
        (F.NOT_FOUND_ERR = 8),
        (F.NOT_SUPPORTED_ERR = 9),
        (F.INUSE_ATTRIBUTE_ERR = 10),
        (F.INVALID_STATE_ERR = 11),
        (F.SYNTAX_ERR = 12),
        (F.INVALID_MODIFICATION_ERR = 13),
        (F.NAMESPACE_ERR = 14),
        (F.INVALID_ACCESS_ERR = 15),
        (F.VALIDATION_ERR = 16),
        (F.TYPE_MISMATCH_ERR = 17),
        (G_vmlCanvasManager = _),
        (CanvasRenderingContext2D = t),
        (CanvasGradient = v),
        (CanvasPattern = f),
        (DOMException = p);
    })(),
  $(document).ready(function () {
    "use strict";
    if (
      ($("body").addClass(currentBrowser()).addClass(detectmob()),
      showScrollTop(),
      $(window).scroll(function () {
        showScrollTop();
      }),
      $("#sidebar")[0] &&
        1024 < $(window).width() &&
        $(window).on("load", function () {
          fixedSidebar();
        }),
      $(window).bind("resize", function () {
        $("#sidebar")[0] &&
          1024 < $(window).width() &&
          $(window).on("load", function () {
            fixedSidebar();
          });
      }),
      $("#to_top").on("click", "a", function (t) {
        t.preventDefault();
        var e = $(this).attr("href"),
          i = $(e).offset().top;
        $("html, body").animate({ scrollTop: i }, 1e3);
      }),
      $("#menuOpen button.hamburger").on("click", function (t) {
        $("#mainMenu").toggleClass("opened"),
          $(this).parent().toggleClass("opened"),
          $(this).toggleClass("is-active"),
          $("body").toggleClass("hidden");
      }),
      $("#mainMenu li.menu-item-has-children").append(
        '<span class="subMenuButton i-angle-down"></span>'
      ),
      $(".subMenuButton").on("click", function () {
        var t = $(this);
        t.hasClass("open")
          ? t.removeClass("open").prev().slideUp(300)
          : (t.removeClass("open").prev().slideDown(300), t.addClass("open"));
      }),
      $(this).on("click", ".wpcf7-not-valid-tip", function () {
        $(this).prev().trigger("focus"),
          $(this).fadeOut(500, function () {
            $(this).remove();
          });
      }),
      !getCookie("privacy"))
    ) {
      var t = $("#privacy");
      t.show(),
        $("body").css("padding-bottom", t.innerHeight()),
        $("#to_top a").css("bottom", t.innerHeight() + 15);
    }
    $("#privacy .privacy_close").on("click", function () {
      $("#privacy").addClass("hide"),
        $("body").css("padding-bottom", 0),
        $("#to_top a").css("bottom", "15px"),
        setCookie("privacy", "true", 1);
    });
    var e = new Swiper(".top_block_slider .swiper-container", {
        loop: !0,
        slidesPerView: 2,
        spaceBetween: 83,
        speed: 2e3,
        autoplay: { delay: 4e3, disableOnInteraction: !1 },
        pagination: { el: ".swiper-pagination", clickable: !0 },
        breakpoints: { 767: { slidesPerView: 1 } },
      }),
      i = new Swiper(".latest_order_slider .swiper-container", {
        loop: !0,
        slidesPerView: 3,
        spaceBetween: 56,
        speed: 2e3,
        autoplay: { delay: 2e3, disableOnInteraction: !1 },
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
        breakpoints: { 1024: { slidesPerView: 2 }, 767: { slidesPerView: 1 } },
      }),
      a = new Swiper(".latest_order_slider2 .swiper-container", {
        loop: !0,
        slidesPerView: 2,
        spaceBetween: 60,
        speed: 2e3,
        autoplay: { delay: 2e3, disableOnInteraction: !1 },
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
        breakpoints: { 1024: { slidesPerView: 1 } },
      });
    $(".top_block_slider .swiper-container").hover(
      function () {
        e.autoplay.stop();
      },
      function () {
        e.autoplay.start();
      }
    ),
      $(".latest_order_slider .swiper-container").hover(
        function () {
          i.autoplay.stop();
        },
        function () {
          i.autoplay.start();
        }
      ),
      $(".latest_order_slider2 .swiper-container").hover(
        function () {
          a.autoplay.stop();
        },
        function () {
          a.autoplay.start();
        }
      ),
      $(".content_more_block .content_more_full").css("display", "none"),
      $(".content_more_block .content_more_btn").click(function () {
        $(this).hasClass("active")
          ? ($(this).prev().show(500),
            $(this).removeClass("active"),
            $(this).html("Read less &#8594;"))
          : ($(this).prev().hide(500),
            $(this).addClass("active"),
            $(this).html("Read more &#8594;"));
      }),
      $(".countdown").hasClass("active") &&
        $(".stat-number").each(function () {
          var t = $(this);
          $({ countNum: t.text() }).animate(
            { countNum: t.attr("data-count") },
            {
              duration: 1500,
              easing: "linear",
              step: function () {
                t.text(Math.floor(this.countNum));
              },
              complete: function () {
                t.text(this.countNum);
              },
            }
          );
        });
    var s = $(".faq").find(".acc_title");
    s.click(function () {
      $(this).hasClass("opened")
        ? (s.removeClass("opened"),
          $(this).next().slideToggle(300).parent().removeClass("open"),
          $(".faq").find(".info").slideUp(300).parent().removeClass("open"))
        : ($(".faq").find(".info").slideUp(300).parent().removeClass("open"),
          $(this).next().slideToggle(300).parent().addClass("open"),
          s.removeClass("opened"),
          $(this).addClass("opened"));
    }),
      s.eq(2).click(),
      formLabel(),
      $(".order_form input").keypress(function (t) {
        if (13 == t.which) return $("form.order_form").submit(), !1;
      });
  }),
  $("[data-get-started1]").on("click", function (t) {
    "undefined" != typeof ga &&
      ga("send", "event", "CTA", "Click", "Get Started first screen");
  }),
  $("[data-get-started2]").on("click", function (t) {
    "undefined" != typeof ga &&
      ga("send", "event", "CTA", "Click", "Get Started main requirements");
  }),
  $("[data-get-started3]").on("click", function (t) {
    "undefined" != typeof ga &&
      ga("send", "event", "CTA", "Click", "Get Started evolve with us");
  }),
  $("[data-get-started4]").on("click", function (t) {
    "undefined" != typeof ga &&
      ga("send", "event", "CTA", "Click", "Start registration");
  }),
  scrollToElement("countdown-effect"),
  scrollToElement("line-effect"),
  scrollToElement("requirements-effect"),
  scrollToElement("believe-effect"),
  scrollToElement("map_svg_block"),
  $(window).scroll(function () {
    scrollToElement("countdown-effect"),
      scrollToElement("line-effect"),
      scrollToElement("requirements-effect"),
      scrollToElement("believe-effect"),
      scrollToElement("map_svg_block");
  }),
  (function () {
    var e = jQuery.fn.addClass;
    jQuery.fn.addClass = function () {
      var t = e.apply(this, arguments);
      return jQuery(this).trigger("cssClassChanged"), t;
    };
  })(),
  $("div, ul").is(".countdown") &&
    $(".countdown").bind("cssClassChanged", function () {
      $(".stat-number").each(function () {
        var t = $(this);
        $({ countNum: t.text() }).animate(
          { countNum: t.attr("data-count") },
          {
            duration: 1500,
            easing: "linear",
            step: function () {
              t.text(Math.floor(this.countNum));
            },
            complete: function () {
              t.text(this.countNum);
            },
          }
        );
      });
    }),
  (window.onload = function () {
    $("div").is("#chartContainer") &&
      (CanvasJS.addColorSet("ownColor", [
        "#4cc9ff",
        "#f6e61c",
        "#fe6478",
        "#20d0c2",
        "#bb64fe",
        "#ff980d",
      ]),
      new CanvasJS.Chart("chartContainer", {
        animationEnabled: !0,
        colorSet: "ownColor",
        title: { horizontalAlign: "left" },
        data: [
          {
            type: "doughnut",
            startAngle: -40,
            innerRadius: 90,
            indexLabelFontSize: 14,
            indexLabel: "#percent%",
            toolTipContent: "<strong>{label}:</strong>(#percent%)",
            dataPoints: [
              { y: 16, label: "Humanities" },
              { y: 22, label: "Applied sciences" },
              { y: 18, label: "Social sciences" },
              { y: 30, label: "Formal sciences" },
              { y: 4, label: "Natural sciences" },
              { y: 10, label: "Other academic fields", exploded: !0 },
            ],
          },
        ],
      }).render());
  }),
  $(document).ready(function () {
    $(".open_popup").click(function () {
      $("#myPopupOverlay").fadeIn(400, function () {
        $("#myPopup")
          .css("display", "flex")
          .animate({ opacity: 1, top: "0" }, 200);
      });
    }),
      $(".popup-header .close").click(function () {
        $("#myPopup").animate({ opacity: 0, top: "45%" }, 200, function () {
          $(this).css("display", "none"), $("#myPopupOverlay").fadeOut(400);
        });
      }),
      $(document).mouseup(function (t) {
        var e = $("#myPopup .popup-content"),
          i = $(".open_popup");
        e.is(t.target) ||
          i.is(t.target) ||
          0 !== e.has(t.target).length ||
          $("#myPopup").animate({ opacity: 0, top: "45%" }, 200, function () {
            $(this).css("display", "none"), $("#myPopupOverlay").fadeOut(400);
          });
      });
  }),
  "undefined" != typeof ajaxurl &&
    setTimeout(function () {
      $.ajax({
        url: ajaxurl,
        data: { action: "loadmore" },
        type: "POST",
        success: function (t) {
          $(".map_svg_block").html(t),
            $(".map_svg_block").css(
              "height",
              $(".map_svg_block svg").height() + 80
            );
        },
      });
    }, 1);
